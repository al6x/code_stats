<!DOCTYPE html>
<!-- saved from url=(0078)file://localhost/Users/alex/other_projects/code_stats/projects_statistics.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <style type="text/css">
      body {font-size: 14px; font-family: Arial, sans-serif;}
      h1 {margin: 20px; font-size: 20px;}
      p {margin: 20px;}
      
      .nowrap {white-space:nowrap;}
      .bold {font-weight: bold;}
      .report {font-size: 12px; border-collapse: collapse; text-align:left; margin: 20px;}
      .report th{font-size: 14px; font-weight:normal; border-bottom: 2px solid; padding: 10px 8px;}
      .report td{border-bottom: 1px solid; padding: 6px 8px;}
      
      .plot {margin: 20px; margin-bottom: 50px; width: 800px; height: 600px;}
      
      p.powered {font-size: 10px; margin: 25px; color: gray; text-align: right; position: absolute; top: 0; right: 0; border: 0;}
      p.powered a {text-decoration: none;}
    </style>
    <!-- Ignore all this JS stuff, it's just some JS libraries explicitly embedded into single HTML file -->
    <script type="text/javascript">
      /*!
       * jQuery JavaScript Library v1.6.1
       * http://jquery.com/
       *
       * Copyright 2011, John Resig
       * Dual licensed under the MIT or GPL Version 2 licenses.
       * http://jquery.org/license
       *
       * Includes Sizzle.js
       * http://sizzlejs.com/
       * Copyright 2011, The Dojo Foundation
       * Released under the MIT, BSD, and GPL Licenses.
       *
       * Date: Thu May 12 15:04:36 2011 -0400
       */
      (function( window, undefined ) {
      
      // Use the correct document accordingly with window argument (sandbox)
      var document = window.document,
      	navigator = window.navigator,
      	location = window.location;
      var jQuery = (function() {
      
      // Define a local copy of jQuery
      var jQuery = function( selector, context ) {
      		// The jQuery object is actually just the init constructor 'enhanced'
      		return new jQuery.fn.init( selector, context, rootjQuery );
      	},
      
      	// Map over jQuery in case of overwrite
      	_jQuery = window.jQuery,
      
      	// Map over the $ in case of overwrite
      	_$ = window.$,
      
      	// A central reference to the root jQuery(document)
      	rootjQuery,
      
      	// A simple way to check for HTML strings or ID strings
      	// (both of which we optimize for)
      	quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
      
      	// Check if a string has a non-whitespace character in it
      	rnotwhite = /\S/,
      
      	// Used for trimming whitespace
      	trimLeft = /^\s+/,
      	trimRight = /\s+$/,
      
      	// Check for digits
      	rdigit = /\d/,
      
      	// Match a standalone tag
      	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
      
      	// JSON RegExp
      	rvalidchars = /^[\],:{}\s]*$/,
      	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
      	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
      	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
      
      	// Useragent RegExp
      	rwebkit = /(webkit)[ \/]([\w.]+)/,
      	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
      	rmsie = /(msie) ([\w.]+)/,
      	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
      
      	// Keep a UserAgent string for use with jQuery.browser
      	userAgent = navigator.userAgent,
      
      	// For matching the engine and version of the browser
      	browserMatch,
      
      	// The deferred used on DOM ready
      	readyList,
      
      	// The ready event handler
      	DOMContentLoaded,
      
      	// Save a reference to some core methods
      	toString = Object.prototype.toString,
      	hasOwn = Object.prototype.hasOwnProperty,
      	push = Array.prototype.push,
      	slice = Array.prototype.slice,
      	trim = String.prototype.trim,
      	indexOf = Array.prototype.indexOf,
      
      	// [[Class]] -> type pairs
      	class2type = {};
      
      jQuery.fn = jQuery.prototype = {
      	constructor: jQuery,
      	init: function( selector, context, rootjQuery ) {
      		var match, elem, ret, doc;
      
      		// Handle $(""), $(null), or $(undefined)
      		if ( !selector ) {
      			return this;
      		}
      
      		// Handle $(DOMElement)
      		if ( selector.nodeType ) {
      			this.context = this[0] = selector;
      			this.length = 1;
      			return this;
      		}
      
      		// The body element only exists once, optimize finding it
      		if ( selector === "body" && !context && document.body ) {
      			this.context = document;
      			this[0] = document.body;
      			this.selector = selector;
      			this.length = 1;
      			return this;
      		}
      
      		// Handle HTML strings
      		if ( typeof selector === "string" ) {
      			// Are we dealing with HTML string or an ID?
      			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
      				// Assume that strings that start and end with <> are HTML and skip the regex check
      				match = [ null, selector, null ];
      
      			} else {
      				match = quickExpr.exec( selector );
      			}
      
      			// Verify a match, and that no context was specified for #id
      			if ( match && (match[1] || !context) ) {
      
      				// HANDLE: $(html) -> $(array)
      				if ( match[1] ) {
      					context = context instanceof jQuery ? context[0] : context;
      					doc = (context ? context.ownerDocument || context : document);
      
      					// If a single string is passed in and it's a single tag
      					// just do a createElement and skip the rest
      					ret = rsingleTag.exec( selector );
      
      					if ( ret ) {
      						if ( jQuery.isPlainObject( context ) ) {
      							selector = [ document.createElement( ret[1] ) ];
      							jQuery.fn.attr.call( selector, context, true );
      
      						} else {
      							selector = [ doc.createElement( ret[1] ) ];
      						}
      
      					} else {
      						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
      						selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
      					}
      
      					return jQuery.merge( this, selector );
      
      				// HANDLE: $("#id")
      				} else {
      					elem = document.getElementById( match[2] );
      
      					// Check parentNode to catch when Blackberry 4.6 returns
      					// nodes that are no longer in the document #6963
      					if ( elem && elem.parentNode ) {
      						// Handle the case where IE and Opera return items
      						// by name instead of ID
      						if ( elem.id !== match[2] ) {
      							return rootjQuery.find( selector );
      						}
      
      						// Otherwise, we inject the element directly into the jQuery object
      						this.length = 1;
      						this[0] = elem;
      					}
      
      					this.context = document;
      					this.selector = selector;
      					return this;
      				}
      
      			// HANDLE: $(expr, $(...))
      			} else if ( !context || context.jquery ) {
      				return (context || rootjQuery).find( selector );
      
      			// HANDLE: $(expr, context)
      			// (which is just equivalent to: $(context).find(expr)
      			} else {
      				return this.constructor( context ).find( selector );
      			}
      
      		// HANDLE: $(function)
      		// Shortcut for document ready
      		} else if ( jQuery.isFunction( selector ) ) {
      			return rootjQuery.ready( selector );
      		}
      
      		if (selector.selector !== undefined) {
      			this.selector = selector.selector;
      			this.context = selector.context;
      		}
      
      		return jQuery.makeArray( selector, this );
      	},
      
      	// Start with an empty selector
      	selector: "",
      
      	// The current version of jQuery being used
      	jquery: "1.6.1",
      
      	// The default length of a jQuery object is 0
      	length: 0,
      
      	// The number of elements contained in the matched element set
      	size: function() {
      		return this.length;
      	},
      
      	toArray: function() {
      		return slice.call( this, 0 );
      	},
      
      	// Get the Nth element in the matched element set OR
      	// Get the whole matched element set as a clean array
      	get: function( num ) {
      		return num == null ?
      
      			// Return a 'clean' array
      			this.toArray() :
      
      			// Return just the object
      			( num < 0 ? this[ this.length + num ] : this[ num ] );
      	},
      
      	// Take an array of elements and push it onto the stack
      	// (returning the new matched element set)
      	pushStack: function( elems, name, selector ) {
      		// Build a new jQuery matched element set
      		var ret = this.constructor();
      
      		if ( jQuery.isArray( elems ) ) {
      			push.apply( ret, elems );
      
      		} else {
      			jQuery.merge( ret, elems );
      		}
      
      		// Add the old object onto the stack (as a reference)
      		ret.prevObject = this;
      
      		ret.context = this.context;
      
      		if ( name === "find" ) {
      			ret.selector = this.selector + (this.selector ? " " : "") + selector;
      		} else if ( name ) {
      			ret.selector = this.selector + "." + name + "(" + selector + ")";
      		}
      
      		// Return the newly-formed element set
      		return ret;
      	},
      
      	// Execute a callback for every element in the matched set.
      	// (You can seed the arguments with an array of args, but this is
      	// only used internally.)
      	each: function( callback, args ) {
      		return jQuery.each( this, callback, args );
      	},
      
      	ready: function( fn ) {
      		// Attach the listeners
      		jQuery.bindReady();
      
      		// Add the callback
      		readyList.done( fn );
      
      		return this;
      	},
      
      	eq: function( i ) {
      		return i === -1 ?
      			this.slice( i ) :
      			this.slice( i, +i + 1 );
      	},
      
      	first: function() {
      		return this.eq( 0 );
      	},
      
      	last: function() {
      		return this.eq( -1 );
      	},
      
      	slice: function() {
      		return this.pushStack( slice.apply( this, arguments ),
      			"slice", slice.call(arguments).join(",") );
      	},
      
      	map: function( callback ) {
      		return this.pushStack( jQuery.map(this, function( elem, i ) {
      			return callback.call( elem, i, elem );
      		}));
      	},
      
      	end: function() {
      		return this.prevObject || this.constructor(null);
      	},
      
      	// For internal use only.
      	// Behaves like an Array's method, not like a jQuery method.
      	push: push,
      	sort: [].sort,
      	splice: [].splice
      };
      
      // Give the init function the jQuery prototype for later instantiation
      jQuery.fn.init.prototype = jQuery.fn;
      
      jQuery.extend = jQuery.fn.extend = function() {
      	var options, name, src, copy, copyIsArray, clone,
      		target = arguments[0] || {},
      		i = 1,
      		length = arguments.length,
      		deep = false;
      
      	// Handle a deep copy situation
      	if ( typeof target === "boolean" ) {
      		deep = target;
      		target = arguments[1] || {};
      		// skip the boolean and the target
      		i = 2;
      	}
      
      	// Handle case when target is a string or something (possible in deep copy)
      	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
      		target = {};
      	}
      
      	// extend jQuery itself if only one argument is passed
      	if ( length === i ) {
      		target = this;
      		--i;
      	}
      
      	for ( ; i < length; i++ ) {
      		// Only deal with non-null/undefined values
      		if ( (options = arguments[ i ]) != null ) {
      			// Extend the base object
      			for ( name in options ) {
      				src = target[ name ];
      				copy = options[ name ];
      
      				// Prevent never-ending loop
      				if ( target === copy ) {
      					continue;
      				}
      
      				// Recurse if we're merging plain objects or arrays
      				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
      					if ( copyIsArray ) {
      						copyIsArray = false;
      						clone = src && jQuery.isArray(src) ? src : [];
      
      					} else {
      						clone = src && jQuery.isPlainObject(src) ? src : {};
      					}
      
      					// Never move original objects, clone them
      					target[ name ] = jQuery.extend( deep, clone, copy );
      
      				// Don't bring in undefined values
      				} else if ( copy !== undefined ) {
      					target[ name ] = copy;
      				}
      			}
      		}
      	}
      
      	// Return the modified object
      	return target;
      };
      
      jQuery.extend({
      	noConflict: function( deep ) {
      		if ( window.$ === jQuery ) {
      			window.$ = _$;
      		}
      
      		if ( deep && window.jQuery === jQuery ) {
      			window.jQuery = _jQuery;
      		}
      
      		return jQuery;
      	},
      
      	// Is the DOM ready to be used? Set to true once it occurs.
      	isReady: false,
      
      	// A counter to track how many items to wait for before
      	// the ready event fires. See #6781
      	readyWait: 1,
      
      	// Hold (or release) the ready event
      	holdReady: function( hold ) {
      		if ( hold ) {
      			jQuery.readyWait++;
      		} else {
      			jQuery.ready( true );
      		}
      	},
      
      	// Handle when the DOM is ready
      	ready: function( wait ) {
      		// Either a released hold or an DOMready/load event and not yet ready
      		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
      			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
      			if ( !document.body ) {
      				return setTimeout( jQuery.ready, 1 );
      			}
      
      			// Remember that the DOM is ready
      			jQuery.isReady = true;
      
      			// If a normal DOM Ready event fired, decrement, and wait if need be
      			if ( wait !== true && --jQuery.readyWait > 0 ) {
      				return;
      			}
      
      			// If there are functions bound, to execute
      			readyList.resolveWith( document, [ jQuery ] );
      
      			// Trigger any bound ready events
      			if ( jQuery.fn.trigger ) {
      				jQuery( document ).trigger( "ready" ).unbind( "ready" );
      			}
      		}
      	},
      
      	bindReady: function() {
      		if ( readyList ) {
      			return;
      		}
      
      		readyList = jQuery._Deferred();
      
      		// Catch cases where $(document).ready() is called after the
      		// browser event has already occurred.
      		if ( document.readyState === "complete" ) {
      			// Handle it asynchronously to allow scripts the opportunity to delay ready
      			return setTimeout( jQuery.ready, 1 );
      		}
      
      		// Mozilla, Opera and webkit nightlies currently support this event
      		if ( document.addEventListener ) {
      			// Use the handy event callback
      			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
      
      			// A fallback to window.onload, that will always work
      			window.addEventListener( "load", jQuery.ready, false );
      
      		// If IE event model is used
      		} else if ( document.attachEvent ) {
      			// ensure firing before onload,
      			// maybe late but safe also for iframes
      			document.attachEvent( "onreadystatechange", DOMContentLoaded );
      
      			// A fallback to window.onload, that will always work
      			window.attachEvent( "onload", jQuery.ready );
      
      			// If IE and not a frame
      			// continually check to see if the document is ready
      			var toplevel = false;
      
      			try {
      				toplevel = window.frameElement == null;
      			} catch(e) {}
      
      			if ( document.documentElement.doScroll && toplevel ) {
      				doScrollCheck();
      			}
      		}
      	},
      
      	// See test/unit/core.js for details concerning isFunction.
      	// Since version 1.3, DOM methods and functions like alert
      	// aren't supported. They return false on IE (#2968).
      	isFunction: function( obj ) {
      		return jQuery.type(obj) === "function";
      	},
      
      	isArray: Array.isArray || function( obj ) {
      		return jQuery.type(obj) === "array";
      	},
      
      	// A crude way of determining if an object is a window
      	isWindow: function( obj ) {
      		return obj && typeof obj === "object" && "setInterval" in obj;
      	},
      
      	isNaN: function( obj ) {
      		return obj == null || !rdigit.test( obj ) || isNaN( obj );
      	},
      
      	type: function( obj ) {
      		return obj == null ?
      			String( obj ) :
      			class2type[ toString.call(obj) ] || "object";
      	},
      
      	isPlainObject: function( obj ) {
      		// Must be an Object.
      		// Because of IE, we also have to check the presence of the constructor property.
      		// Make sure that DOM nodes and window objects don't pass through, as well
      		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
      			return false;
      		}
      
      		// Not own constructor property must be Object
      		if ( obj.constructor &&
      			!hasOwn.call(obj, "constructor") &&
      			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
      			return false;
      		}
      
      		// Own properties are enumerated firstly, so to speed up,
      		// if last one is own, then all properties are own.
      
      		var key;
      		for ( key in obj ) {}
      
      		return key === undefined || hasOwn.call( obj, key );
      	},
      
      	isEmptyObject: function( obj ) {
      		for ( var name in obj ) {
      			return false;
      		}
      		return true;
      	},
      
      	error: function( msg ) {
      		throw msg;
      	},
      
      	parseJSON: function( data ) {
      		if ( typeof data !== "string" || !data ) {
      			return null;
      		}
      
      		// Make sure leading/trailing whitespace is removed (IE can't handle it)
      		data = jQuery.trim( data );
      
      		// Attempt to parse using the native JSON parser first
      		if ( window.JSON && window.JSON.parse ) {
      			return window.JSON.parse( data );
      		}
      
      		// Make sure the incoming data is actual JSON
      		// Logic borrowed from http://json.org/json2.js
      		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
      			.replace( rvalidtokens, "]" )
      			.replace( rvalidbraces, "")) ) {
      
      			return (new Function( "return " + data ))();
      
      		}
      		jQuery.error( "Invalid JSON: " + data );
      	},
      
      	// Cross-browser xml parsing
      	// (xml & tmp used internally)
      	parseXML: function( data , xml , tmp ) {
      
      		if ( window.DOMParser ) { // Standard
      			tmp = new DOMParser();
      			xml = tmp.parseFromString( data , "text/xml" );
      		} else { // IE
      			xml = new ActiveXObject( "Microsoft.XMLDOM" );
      			xml.async = "false";
      			xml.loadXML( data );
      		}
      
      		tmp = xml.documentElement;
      
      		if ( ! tmp || ! tmp.nodeName || tmp.nodeName === "parsererror" ) {
      			jQuery.error( "Invalid XML: " + data );
      		}
      
      		return xml;
      	},
      
      	noop: function() {},
      
      	// Evaluates a script in a global context
      	// Workarounds based on findings by Jim Driscoll
      	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
      	globalEval: function( data ) {
      		if ( data && rnotwhite.test( data ) ) {
      			// We use execScript on Internet Explorer
      			// We use an anonymous function so that context is window
      			// rather than jQuery in Firefox
      			( window.execScript || function( data ) {
      				window[ "eval" ].call( window, data );
      			} )( data );
      		}
      	},
      
      	nodeName: function( elem, name ) {
      		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
      	},
      
      	// args is for internal usage only
      	each: function( object, callback, args ) {
      		var name, i = 0,
      			length = object.length,
      			isObj = length === undefined || jQuery.isFunction( object );
      
      		if ( args ) {
      			if ( isObj ) {
      				for ( name in object ) {
      					if ( callback.apply( object[ name ], args ) === false ) {
      						break;
      					}
      				}
      			} else {
      				for ( ; i < length; ) {
      					if ( callback.apply( object[ i++ ], args ) === false ) {
      						break;
      					}
      				}
      			}
      
      		// A special, fast, case for the most common use of each
      		} else {
      			if ( isObj ) {
      				for ( name in object ) {
      					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
      						break;
      					}
      				}
      			} else {
      				for ( ; i < length; ) {
      					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
      						break;
      					}
      				}
      			}
      		}
      
      		return object;
      	},
      
      	// Use native String.trim function wherever possible
      	trim: trim ?
      		function( text ) {
      			return text == null ?
      				"" :
      				trim.call( text );
      		} :
      
      		// Otherwise use our own trimming functionality
      		function( text ) {
      			return text == null ?
      				"" :
      				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
      		},
      
      	// results is for internal usage only
      	makeArray: function( array, results ) {
      		var ret = results || [];
      
      		if ( array != null ) {
      			// The window, strings (and functions) also have 'length'
      			// The extra typeof function check is to prevent crashes
      			// in Safari 2 (See: #3039)
      			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
      			var type = jQuery.type( array );
      
      			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
      				push.call( ret, array );
      			} else {
      				jQuery.merge( ret, array );
      			}
      		}
      
      		return ret;
      	},
      
      	inArray: function( elem, array ) {
      
      		if ( indexOf ) {
      			return indexOf.call( array, elem );
      		}
      
      		for ( var i = 0, length = array.length; i < length; i++ ) {
      			if ( array[ i ] === elem ) {
      				return i;
      			}
      		}
      
      		return -1;
      	},
      
      	merge: function( first, second ) {
      		var i = first.length,
      			j = 0;
      
      		if ( typeof second.length === "number" ) {
      			for ( var l = second.length; j < l; j++ ) {
      				first[ i++ ] = second[ j ];
      			}
      
      		} else {
      			while ( second[j] !== undefined ) {
      				first[ i++ ] = second[ j++ ];
      			}
      		}
      
      		first.length = i;
      
      		return first;
      	},
      
      	grep: function( elems, callback, inv ) {
      		var ret = [], retVal;
      		inv = !!inv;
      
      		// Go through the array, only saving the items
      		// that pass the validator function
      		for ( var i = 0, length = elems.length; i < length; i++ ) {
      			retVal = !!callback( elems[ i ], i );
      			if ( inv !== retVal ) {
      				ret.push( elems[ i ] );
      			}
      		}
      
      		return ret;
      	},
      
      	// arg is for internal usage only
      	map: function( elems, callback, arg ) {
      		var value, key, ret = [],
      			i = 0,
      			length = elems.length,
      			// jquery objects are treated as arrays
      			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
      
      		// Go through the array, translating each of the items to their
      		if ( isArray ) {
      			for ( ; i < length; i++ ) {
      				value = callback( elems[ i ], i, arg );
      
      				if ( value != null ) {
      					ret[ ret.length ] = value;
      				}
      			}
      
      		// Go through every key on the object,
      		} else {
      			for ( key in elems ) {
      				value = callback( elems[ key ], key, arg );
      
      				if ( value != null ) {
      					ret[ ret.length ] = value;
      				}
      			}
      		}
      
      		// Flatten any nested arrays
      		return ret.concat.apply( [], ret );
      	},
      
      	// A global GUID counter for objects
      	guid: 1,
      
      	// Bind a function to a context, optionally partially applying any
      	// arguments.
      	proxy: function( fn, context ) {
      		if ( typeof context === "string" ) {
      			var tmp = fn[ context ];
      			context = fn;
      			fn = tmp;
      		}
      
      		// Quick check to determine if target is callable, in the spec
      		// this throws a TypeError, but we will just return undefined.
      		if ( !jQuery.isFunction( fn ) ) {
      			return undefined;
      		}
      
      		// Simulated bind
      		var args = slice.call( arguments, 2 ),
      			proxy = function() {
      				return fn.apply( context, args.concat( slice.call( arguments ) ) );
      			};
      
      		// Set the guid of unique handler to the same of original handler, so it can be removed
      		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
      
      		return proxy;
      	},
      
      	// Mutifunctional method to get and set values to a collection
      	// The value/s can be optionally by executed if its a function
      	access: function( elems, key, value, exec, fn, pass ) {
      		var length = elems.length;
      
      		// Setting many attributes
      		if ( typeof key === "object" ) {
      			for ( var k in key ) {
      				jQuery.access( elems, k, key[k], exec, fn, value );
      			}
      			return elems;
      		}
      
      		// Setting one attribute
      		if ( value !== undefined ) {
      			// Optionally, function values get executed if exec is true
      			exec = !pass && exec && jQuery.isFunction(value);
      
      			for ( var i = 0; i < length; i++ ) {
      				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
      			}
      
      			return elems;
      		}
      
      		// Getting an attribute
      		return length ? fn( elems[0], key ) : undefined;
      	},
      
      	now: function() {
      		return (new Date()).getTime();
      	},
      
      	// Use of jQuery.browser is frowned upon.
      	// More details: http://docs.jquery.com/Utilities/jQuery.browser
      	uaMatch: function( ua ) {
      		ua = ua.toLowerCase();
      
      		var match = rwebkit.exec( ua ) ||
      			ropera.exec( ua ) ||
      			rmsie.exec( ua ) ||
      			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
      			[];
      
      		return { browser: match[1] || "", version: match[2] || "0" };
      	},
      
      	sub: function() {
      		function jQuerySub( selector, context ) {
      			return new jQuerySub.fn.init( selector, context );
      		}
      		jQuery.extend( true, jQuerySub, this );
      		jQuerySub.superclass = this;
      		jQuerySub.fn = jQuerySub.prototype = this();
      		jQuerySub.fn.constructor = jQuerySub;
      		jQuerySub.sub = this.sub;
      		jQuerySub.fn.init = function init( selector, context ) {
      			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
      				context = jQuerySub( context );
      			}
      
      			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
      		};
      		jQuerySub.fn.init.prototype = jQuerySub.fn;
      		var rootjQuerySub = jQuerySub(document);
      		return jQuerySub;
      	},
      
      	browser: {}
      });
      
      // Populate the class2type map
      jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
      	class2type[ "[object " + name + "]" ] = name.toLowerCase();
      });
      
      browserMatch = jQuery.uaMatch( userAgent );
      if ( browserMatch.browser ) {
      	jQuery.browser[ browserMatch.browser ] = true;
      	jQuery.browser.version = browserMatch.version;
      }
      
      // Deprecated, use jQuery.browser.webkit instead
      if ( jQuery.browser.webkit ) {
      	jQuery.browser.safari = true;
      }
      
      // IE doesn't match non-breaking spaces with \s
      if ( rnotwhite.test( "\xA0" ) ) {
      	trimLeft = /^[\s\xA0]+/;
      	trimRight = /[\s\xA0]+$/;
      }
      
      // All jQuery objects should point back to these
      rootjQuery = jQuery(document);
      
      // Cleanup functions for the document ready method
      if ( document.addEventListener ) {
      	DOMContentLoaded = function() {
      		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
      		jQuery.ready();
      	};
      
      } else if ( document.attachEvent ) {
      	DOMContentLoaded = function() {
      		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
      		if ( document.readyState === "complete" ) {
      			document.detachEvent( "onreadystatechange", DOMContentLoaded );
      			jQuery.ready();
      		}
      	};
      }
      
      // The DOM ready check for Internet Explorer
      function doScrollCheck() {
      	if ( jQuery.isReady ) {
      		return;
      	}
      
      	try {
      		// If IE is used, use the trick by Diego Perini
      		// http://javascript.nwbox.com/IEContentLoaded/
      		document.documentElement.doScroll("left");
      	} catch(e) {
      		setTimeout( doScrollCheck, 1 );
      		return;
      	}
      
      	// and execute any waiting functions
      	jQuery.ready();
      }
      
      // Expose jQuery to the global object
      return jQuery;
      
      })();
      
      
      var // Promise methods
      	promiseMethods = "done fail isResolved isRejected promise then always pipe".split( " " ),
      	// Static reference to slice
      	sliceDeferred = [].slice;
      
      jQuery.extend({
      	// Create a simple deferred (one callbacks list)
      	_Deferred: function() {
      		var // callbacks list
      			callbacks = [],
      			// stored [ context , args ]
      			fired,
      			// to avoid firing when already doing so
      			firing,
      			// flag to know if the deferred has been cancelled
      			cancelled,
      			// the deferred itself
      			deferred  = {
      
      				// done( f1, f2, ...)
      				done: function() {
      					if ( !cancelled ) {
      						var args = arguments,
      							i,
      							length,
      							elem,
      							type,
      							_fired;
      						if ( fired ) {
      							_fired = fired;
      							fired = 0;
      						}
      						for ( i = 0, length = args.length; i < length; i++ ) {
      							elem = args[ i ];
      							type = jQuery.type( elem );
      							if ( type === "array" ) {
      								deferred.done.apply( deferred, elem );
      							} else if ( type === "function" ) {
      								callbacks.push( elem );
      							}
      						}
      						if ( _fired ) {
      							deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
      						}
      					}
      					return this;
      				},
      
      				// resolve with given context and args
      				resolveWith: function( context, args ) {
      					if ( !cancelled && !fired && !firing ) {
      						// make sure args are available (#8421)
      						args = args || [];
      						firing = 1;
      						try {
      							while( callbacks[ 0 ] ) {
      								callbacks.shift().apply( context, args );
      							}
      						}
      						finally {
      							fired = [ context, args ];
      							firing = 0;
      						}
      					}
      					return this;
      				},
      
      				// resolve with this as context and given arguments
      				resolve: function() {
      					deferred.resolveWith( this, arguments );
      					return this;
      				},
      
      				// Has this deferred been resolved?
      				isResolved: function() {
      					return !!( firing || fired );
      				},
      
      				// Cancel
      				cancel: function() {
      					cancelled = 1;
      					callbacks = [];
      					return this;
      				}
      			};
      
      		return deferred;
      	},
      
      	// Full fledged deferred (two callbacks list)
      	Deferred: function( func ) {
      		var deferred = jQuery._Deferred(),
      			failDeferred = jQuery._Deferred(),
      			promise;
      		// Add errorDeferred methods, then and promise
      		jQuery.extend( deferred, {
      			then: function( doneCallbacks, failCallbacks ) {
      				deferred.done( doneCallbacks ).fail( failCallbacks );
      				return this;
      			},
      			always: function() {
      				return deferred.done.apply( deferred, arguments ).fail.apply( this, arguments );
      			},
      			fail: failDeferred.done,
      			rejectWith: failDeferred.resolveWith,
      			reject: failDeferred.resolve,
      			isRejected: failDeferred.isResolved,
      			pipe: function( fnDone, fnFail ) {
      				return jQuery.Deferred(function( newDefer ) {
      					jQuery.each( {
      						done: [ fnDone, "resolve" ],
      						fail: [ fnFail, "reject" ]
      					}, function( handler, data ) {
      						var fn = data[ 0 ],
      							action = data[ 1 ],
      							returned;
      						if ( jQuery.isFunction( fn ) ) {
      							deferred[ handler ](function() {
      								returned = fn.apply( this, arguments );
      								if ( returned && jQuery.isFunction( returned.promise ) ) {
      									returned.promise().then( newDefer.resolve, newDefer.reject );
      								} else {
      									newDefer[ action ]( returned );
      								}
      							});
      						} else {
      							deferred[ handler ]( newDefer[ action ] );
      						}
      					});
      				}).promise();
      			},
      			// Get a promise for this deferred
      			// If obj is provided, the promise aspect is added to the object
      			promise: function( obj ) {
      				if ( obj == null ) {
      					if ( promise ) {
      						return promise;
      					}
      					promise = obj = {};
      				}
      				var i = promiseMethods.length;
      				while( i-- ) {
      					obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];
      				}
      				return obj;
      			}
      		});
      		// Make sure only one callback list will be used
      		deferred.done( failDeferred.cancel ).fail( deferred.cancel );
      		// Unexpose cancel
      		delete deferred.cancel;
      		// Call given func if any
      		if ( func ) {
      			func.call( deferred, deferred );
      		}
      		return deferred;
      	},
      
      	// Deferred helper
      	when: function( firstParam ) {
      		var args = arguments,
      			i = 0,
      			length = args.length,
      			count = length,
      			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
      				firstParam :
      				jQuery.Deferred();
      		function resolveFunc( i ) {
      			return function( value ) {
      				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
      				if ( !( --count ) ) {
      					// Strange bug in FF4:
      					// Values changed onto the arguments object sometimes end up as undefined values
      					// outside the $.when method. Cloning the object into a fresh array solves the issue
      					deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );
      				}
      			};
      		}
      		if ( length > 1 ) {
      			for( ; i < length; i++ ) {
      				if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {
      					args[ i ].promise().then( resolveFunc(i), deferred.reject );
      				} else {
      					--count;
      				}
      			}
      			if ( !count ) {
      				deferred.resolveWith( deferred, args );
      			}
      		} else if ( deferred !== firstParam ) {
      			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
      		}
      		return deferred.promise();
      	}
      });
      
      
      
      jQuery.support = (function() {
      
      	var div = document.createElement( "div" ),
      		documentElement = document.documentElement,
      		all,
      		a,
      		select,
      		opt,
      		input,
      		marginDiv,
      		support,
      		fragment,
      		body,
      		bodyStyle,
      		tds,
      		events,
      		eventName,
      		i,
      		isSupported;
      
      	// Preliminary tests
      	div.setAttribute("className", "t");
      	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
      
      	all = div.getElementsByTagName( "*" );
      	a = div.getElementsByTagName( "a" )[ 0 ];
      
      	// Can't get basic test support
      	if ( !all || !all.length || !a ) {
      		return {};
      	}
      
      	// First batch of supports tests
      	select = document.createElement( "select" );
      	opt = select.appendChild( document.createElement("option") );
      	input = div.getElementsByTagName( "input" )[ 0 ];
      
      	support = {
      		// IE strips leading whitespace when .innerHTML is used
      		leadingWhitespace: ( div.firstChild.nodeType === 3 ),
      
      		// Make sure that tbody elements aren't automatically inserted
      		// IE will insert them into empty tables
      		tbody: !div.getElementsByTagName( "tbody" ).length,
      
      		// Make sure that link elements get serialized correctly by innerHTML
      		// This requires a wrapper element in IE
      		htmlSerialize: !!div.getElementsByTagName( "link" ).length,
      
      		// Get the style information from getAttribute
      		// (IE uses .cssText instead)
      		style: /top/.test( a.getAttribute("style") ),
      
      		// Make sure that URLs aren't manipulated
      		// (IE normalizes it by default)
      		hrefNormalized: ( a.getAttribute( "href" ) === "/a" ),
      
      		// Make sure that element opacity exists
      		// (IE uses filter instead)
      		// Use a regex to work around a WebKit issue. See #5145
      		opacity: /^0.55$/.test( a.style.opacity ),
      
      		// Verify style float existence
      		// (IE uses styleFloat instead of cssFloat)
      		cssFloat: !!a.style.cssFloat,
      
      		// Make sure that if no value is specified for a checkbox
      		// that it defaults to "on".
      		// (WebKit defaults to "" instead)
      		checkOn: ( input.value === "on" ),
      
      		// Make sure that a selected-by-default option has a working selected property.
      		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
      		optSelected: opt.selected,
      
      		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
      		getSetAttribute: div.className !== "t",
      
      		// Will be defined later
      		submitBubbles: true,
      		changeBubbles: true,
      		focusinBubbles: false,
      		deleteExpando: true,
      		noCloneEvent: true,
      		inlineBlockNeedsLayout: false,
      		shrinkWrapBlocks: false,
      		reliableMarginRight: true
      	};
      
      	// Make sure checked status is properly cloned
      	input.checked = true;
      	support.noCloneChecked = input.cloneNode( true ).checked;
      
      	// Make sure that the options inside disabled selects aren't marked as disabled
      	// (WebKit marks them as disabled)
      	select.disabled = true;
      	support.optDisabled = !opt.disabled;
      
      	// Test to see if it's possible to delete an expando from an element
      	// Fails in Internet Explorer
      	try {
      		delete div.test;
      	} catch( e ) {
      		support.deleteExpando = false;
      	}
      
      	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
      		div.attachEvent( "onclick", function click() {
      			// Cloning a node shouldn't copy over any
      			// bound event handlers (IE does this)
      			support.noCloneEvent = false;
      			div.detachEvent( "onclick", click );
      		});
      		div.cloneNode( true ).fireEvent( "onclick" );
      	}
      
      	// Check if a radio maintains it's value
      	// after being appended to the DOM
      	input = document.createElement("input");
      	input.value = "t";
      	input.setAttribute("type", "radio");
      	support.radioValue = input.value === "t";
      
      	input.setAttribute("checked", "checked");
      	div.appendChild( input );
      	fragment = document.createDocumentFragment();
      	fragment.appendChild( div.firstChild );
      
      	// WebKit doesn't clone checked state correctly in fragments
      	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
      
      	div.innerHTML = "";
      
      	// Figure out if the W3C box model works as expected
      	div.style.width = div.style.paddingLeft = "1px";
      
      	// We use our own, invisible, body
      	body = document.createElement( "body" );
      	bodyStyle = {
      		visibility: "hidden",
      		width: 0,
      		height: 0,
      		border: 0,
      		margin: 0,
      		// Set background to avoid IE crashes when removing (#9028)
      		background: "none"
      	};
      	for ( i in bodyStyle ) {
      		body.style[ i ] = bodyStyle[ i ];
      	}
      	body.appendChild( div );
      	documentElement.insertBefore( body, documentElement.firstChild );
      
      	// Check if a disconnected checkbox will retain its checked
      	// value of true after appended to the DOM (IE6/7)
      	support.appendChecked = input.checked;
      
      	support.boxModel = div.offsetWidth === 2;
      
      	if ( "zoom" in div.style ) {
      		// Check if natively block-level elements act like inline-block
      		// elements when setting their display to 'inline' and giving
      		// them layout
      		// (IE < 8 does this)
      		div.style.display = "inline";
      		div.style.zoom = 1;
      		support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );
      
      		// Check if elements with layout shrink-wrap their children
      		// (IE 6 does this)
      		div.style.display = "";
      		div.innerHTML = "<div style='width:4px;'></div>";
      		support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
      	}
      
      	div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
      	tds = div.getElementsByTagName( "td" );
      
      	// Check if table cells still have offsetWidth/Height when they are set
      	// to display:none and there are still other visible table cells in a
      	// table row; if so, offsetWidth/Height are not reliable for use when
      	// determining if an element has been hidden directly using
      	// display:none (it is still safe to use offsets if a parent element is
      	// hidden; don safety goggles and see bug #4512 for more information).
      	// (only IE 8 fails this test)
      	isSupported = ( tds[ 0 ].offsetHeight === 0 );
      
      	tds[ 0 ].style.display = "";
      	tds[ 1 ].style.display = "none";
      
      	// Check if empty table cells still have offsetWidth/Height
      	// (IE < 8 fail this test)
      	support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
      	div.innerHTML = "";
      
      	// Check if div with explicit width and no margin-right incorrectly
      	// gets computed margin-right based on width of container. For more
      	// info see bug #3333
      	// Fails in WebKit before Feb 2011 nightlies
      	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
      	if ( document.defaultView && document.defaultView.getComputedStyle ) {
      		marginDiv = document.createElement( "div" );
      		marginDiv.style.width = "0";
      		marginDiv.style.marginRight = "0";
      		div.appendChild( marginDiv );
      		support.reliableMarginRight =
      			( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
      	}
      
      	// Remove the body element we added
      	body.innerHTML = "";
      	documentElement.removeChild( body );
      
      	// Technique from Juriy Zaytsev
      	// http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
      	// We only care about the case where non-standard event systems
      	// are used, namely in IE. Short-circuiting here helps us to
      	// avoid an eval call (in setAttribute) which can cause CSP
      	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
      	if ( div.attachEvent ) {
      		for( i in {
      			submit: 1,
      			change: 1,
      			focusin: 1
      		} ) {
      			eventName = "on" + i;
      			isSupported = ( eventName in div );
      			if ( !isSupported ) {
      				div.setAttribute( eventName, "return;" );
      				isSupported = ( typeof div[ eventName ] === "function" );
      			}
      			support[ i + "Bubbles" ] = isSupported;
      		}
      	}
      
      	return support;
      })();
      
      // Keep track of boxModel
      jQuery.boxModel = jQuery.support.boxModel;
      
      
      
      
      var rbrace = /^(?:\{.*\}|\[.*\])$/,
      	rmultiDash = /([a-z])([A-Z])/g;
      
      jQuery.extend({
      	cache: {},
      
      	// Please use with caution
      	uuid: 0,
      
      	// Unique for each copy of jQuery on the page
      	// Non-digits removed to match rinlinejQuery
      	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),
      
      	// The following elements throw uncatchable exceptions if you
      	// attempt to add expando properties to them.
      	noData: {
      		"embed": true,
      		// Ban all objects except for Flash (which handle expandos)
      		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
      		"applet": true
      	},
      
      	hasData: function( elem ) {
      		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
      
      		return !!elem && !isEmptyDataObject( elem );
      	},
      
      	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
      		if ( !jQuery.acceptData( elem ) ) {
      			return;
      		}
      
      		var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,
      
      			// We have to handle DOM nodes and JS objects differently because IE6-7
      			// can't GC object references properly across the DOM-JS boundary
      			isNode = elem.nodeType,
      
      			// Only DOM nodes need the global jQuery cache; JS object data is
      			// attached directly to the object so GC can occur automatically
      			cache = isNode ? jQuery.cache : elem,
      
      			// Only defining an ID for JS objects if its cache already exists allows
      			// the code to shortcut on the same path as a DOM node with no cache
      			id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;
      
      		// Avoid doing any more work than we need to when trying to get data on an
      		// object that has no data at all
      		if ( (!id || (pvt && id && !cache[ id ][ internalKey ])) && getByName && data === undefined ) {
      			return;
      		}
      
      		if ( !id ) {
      			// Only DOM nodes need a new unique ID for each element since their data
      			// ends up in the global cache
      			if ( isNode ) {
      				elem[ jQuery.expando ] = id = ++jQuery.uuid;
      			} else {
      				id = jQuery.expando;
      			}
      		}
      
      		if ( !cache[ id ] ) {
      			cache[ id ] = {};
      
      			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
      			// metadata on plain JS objects when the object is serialized using
      			// JSON.stringify
      			if ( !isNode ) {
      				cache[ id ].toJSON = jQuery.noop;
      			}
      		}
      
      		// An object can be passed to jQuery.data instead of a key/value pair; this gets
      		// shallow copied over onto the existing cache
      		if ( typeof name === "object" || typeof name === "function" ) {
      			if ( pvt ) {
      				cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);
      			} else {
      				cache[ id ] = jQuery.extend(cache[ id ], name);
      			}
      		}
      
      		thisCache = cache[ id ];
      
      		// Internal jQuery data is stored in a separate object inside the object's data
      		// cache in order to avoid key collisions between internal data and user-defined
      		// data
      		if ( pvt ) {
      			if ( !thisCache[ internalKey ] ) {
      				thisCache[ internalKey ] = {};
      			}
      
      			thisCache = thisCache[ internalKey ];
      		}
      
      		if ( data !== undefined ) {
      			thisCache[ jQuery.camelCase( name ) ] = data;
      		}
      
      		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
      		// not attempt to inspect the internal events object using jQuery.data, as this
      		// internal data object is undocumented and subject to change.
      		if ( name === "events" && !thisCache[name] ) {
      			return thisCache[ internalKey ] && thisCache[ internalKey ].events;
      		}
      
      		return getByName ? thisCache[ jQuery.camelCase( name ) ] : thisCache;
      	},
      
      	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
      		if ( !jQuery.acceptData( elem ) ) {
      			return;
      		}
      
      		var internalKey = jQuery.expando, isNode = elem.nodeType,
      
      			// See jQuery.data for more information
      			cache = isNode ? jQuery.cache : elem,
      
      			// See jQuery.data for more information
      			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;
      
      		// If there is already no cache entry for this object, there is no
      		// purpose in continuing
      		if ( !cache[ id ] ) {
      			return;
      		}
      
      		if ( name ) {
      			var thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];
      
      			if ( thisCache ) {
      				delete thisCache[ name ];
      
      				// If there is no data left in the cache, we want to continue
      				// and let the cache object itself get destroyed
      				if ( !isEmptyDataObject(thisCache) ) {
      					return;
      				}
      			}
      		}
      
      		// See jQuery.data for more information
      		if ( pvt ) {
      			delete cache[ id ][ internalKey ];
      
      			// Don't destroy the parent cache unless the internal data object
      			// had been the only thing left in it
      			if ( !isEmptyDataObject(cache[ id ]) ) {
      				return;
      			}
      		}
      
      		var internalCache = cache[ id ][ internalKey ];
      
      		// Browsers that fail expando deletion also refuse to delete expandos on
      		// the window, but it will allow it on all other JS objects; other browsers
      		// don't care
      		if ( jQuery.support.deleteExpando || cache != window ) {
      			delete cache[ id ];
      		} else {
      			cache[ id ] = null;
      		}
      
      		// We destroyed the entire user cache at once because it's faster than
      		// iterating through each key, but we need to continue to persist internal
      		// data if it existed
      		if ( internalCache ) {
      			cache[ id ] = {};
      			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
      			// metadata on plain JS objects when the object is serialized using
      			// JSON.stringify
      			if ( !isNode ) {
      				cache[ id ].toJSON = jQuery.noop;
      			}
      
      			cache[ id ][ internalKey ] = internalCache;
      
      		// Otherwise, we need to eliminate the expando on the node to avoid
      		// false lookups in the cache for entries that no longer exist
      		} else if ( isNode ) {
      			// IE does not allow us to delete expando properties from nodes,
      			// nor does it have a removeAttribute function on Document nodes;
      			// we must handle all of these cases
      			if ( jQuery.support.deleteExpando ) {
      				delete elem[ jQuery.expando ];
      			} else if ( elem.removeAttribute ) {
      				elem.removeAttribute( jQuery.expando );
      			} else {
      				elem[ jQuery.expando ] = null;
      			}
      		}
      	},
      
      	// For internal use only.
      	_data: function( elem, name, data ) {
      		return jQuery.data( elem, name, data, true );
      	},
      
      	// A method for determining if a DOM node can handle the data expando
      	acceptData: function( elem ) {
      		if ( elem.nodeName ) {
      			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
      
      			if ( match ) {
      				return !(match === true || elem.getAttribute("classid") !== match);
      			}
      		}
      
      		return true;
      	}
      });
      
      jQuery.fn.extend({
      	data: function( key, value ) {
      		var data = null;
      
      		if ( typeof key === "undefined" ) {
      			if ( this.length ) {
      				data = jQuery.data( this[0] );
      
      				if ( this[0].nodeType === 1 ) {
      			    var attr = this[0].attributes, name;
      					for ( var i = 0, l = attr.length; i < l; i++ ) {
      						name = attr[i].name;
      
      						if ( name.indexOf( "data-" ) === 0 ) {
      							name = jQuery.camelCase( name.substring(5) );
      
      							dataAttr( this[0], name, data[ name ] );
      						}
      					}
      				}
      			}
      
      			return data;
      
      		} else if ( typeof key === "object" ) {
      			return this.each(function() {
      				jQuery.data( this, key );
      			});
      		}
      
      		var parts = key.split(".");
      		parts[1] = parts[1] ? "." + parts[1] : "";
      
      		if ( value === undefined ) {
      			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);
      
      			// Try to fetch any internally stored data first
      			if ( data === undefined && this.length ) {
      				data = jQuery.data( this[0], key );
      				data = dataAttr( this[0], key, data );
      			}
      
      			return data === undefined && parts[1] ?
      				this.data( parts[0] ) :
      				data;
      
      		} else {
      			return this.each(function() {
      				var $this = jQuery( this ),
      					args = [ parts[0], value ];
      
      				$this.triggerHandler( "setData" + parts[1] + "!", args );
      				jQuery.data( this, key, value );
      				$this.triggerHandler( "changeData" + parts[1] + "!", args );
      			});
      		}
      	},
      
      	removeData: function( key ) {
      		return this.each(function() {
      			jQuery.removeData( this, key );
      		});
      	}
      });
      
      function dataAttr( elem, key, data ) {
      	// If nothing was found internally, try to fetch any
      	// data from the HTML5 data-* attribute
      	if ( data === undefined && elem.nodeType === 1 ) {
      		var name = "data-" + key.replace( rmultiDash, "$1-$2" ).toLowerCase();
      
      		data = elem.getAttribute( name );
      
      		if ( typeof data === "string" ) {
      			try {
      				data = data === "true" ? true :
      				data === "false" ? false :
      				data === "null" ? null :
      				!jQuery.isNaN( data ) ? parseFloat( data ) :
      					rbrace.test( data ) ? jQuery.parseJSON( data ) :
      					data;
      			} catch( e ) {}
      
      			// Make sure we set the data so it isn't changed later
      			jQuery.data( elem, key, data );
      
      		} else {
      			data = undefined;
      		}
      	}
      
      	return data;
      }
      
      // TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
      // property to be considered empty objects; this property always exists in
      // order to make sure JSON.stringify does not expose internal metadata
      function isEmptyDataObject( obj ) {
      	for ( var name in obj ) {
      		if ( name !== "toJSON" ) {
      			return false;
      		}
      	}
      
      	return true;
      }
      
      
      
      
      function handleQueueMarkDefer( elem, type, src ) {
      	var deferDataKey = type + "defer",
      		queueDataKey = type + "queue",
      		markDataKey = type + "mark",
      		defer = jQuery.data( elem, deferDataKey, undefined, true );
      	if ( defer &&
      		( src === "queue" || !jQuery.data( elem, queueDataKey, undefined, true ) ) &&
      		( src === "mark" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {
      		// Give room for hard-coded callbacks to fire first
      		// and eventually mark/queue something else on the element
      		setTimeout( function() {
      			if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&
      				!jQuery.data( elem, markDataKey, undefined, true ) ) {
      				jQuery.removeData( elem, deferDataKey, true );
      				defer.resolve();
      			}
      		}, 0 );
      	}
      }
      
      jQuery.extend({
      
      	_mark: function( elem, type ) {
      		if ( elem ) {
      			type = (type || "fx") + "mark";
      			jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );
      		}
      	},
      
      	_unmark: function( force, elem, type ) {
      		if ( force !== true ) {
      			type = elem;
      			elem = force;
      			force = false;
      		}
      		if ( elem ) {
      			type = type || "fx";
      			var key = type + "mark",
      				count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );
      			if ( count ) {
      				jQuery.data( elem, key, count, true );
      			} else {
      				jQuery.removeData( elem, key, true );
      				handleQueueMarkDefer( elem, type, "mark" );
      			}
      		}
      	},
      
      	queue: function( elem, type, data ) {
      		if ( elem ) {
      			type = (type || "fx") + "queue";
      			var q = jQuery.data( elem, type, undefined, true );
      			// Speed up dequeue by getting out quickly if this is just a lookup
      			if ( data ) {
      				if ( !q || jQuery.isArray(data) ) {
      					q = jQuery.data( elem, type, jQuery.makeArray(data), true );
      				} else {
      					q.push( data );
      				}
      			}
      			return q || [];
      		}
      	},
      
      	dequeue: function( elem, type ) {
      		type = type || "fx";
      
      		var queue = jQuery.queue( elem, type ),
      			fn = queue.shift(),
      			defer;
      
      		// If the fx queue is dequeued, always remove the progress sentinel
      		if ( fn === "inprogress" ) {
      			fn = queue.shift();
      		}
      
      		if ( fn ) {
      			// Add a progress sentinel to prevent the fx queue from being
      			// automatically dequeued
      			if ( type === "fx" ) {
      				queue.unshift("inprogress");
      			}
      
      			fn.call(elem, function() {
      				jQuery.dequeue(elem, type);
      			});
      		}
      
      		if ( !queue.length ) {
      			jQuery.removeData( elem, type + "queue", true );
      			handleQueueMarkDefer( elem, type, "queue" );
      		}
      	}
      });
      
      jQuery.fn.extend({
      	queue: function( type, data ) {
      		if ( typeof type !== "string" ) {
      			data = type;
      			type = "fx";
      		}
      
      		if ( data === undefined ) {
      			return jQuery.queue( this[0], type );
      		}
      		return this.each(function() {
      			var queue = jQuery.queue( this, type, data );
      
      			if ( type === "fx" && queue[0] !== "inprogress" ) {
      				jQuery.dequeue( this, type );
      			}
      		});
      	},
      	dequeue: function( type ) {
      		return this.each(function() {
      			jQuery.dequeue( this, type );
      		});
      	},
      	// Based off of the plugin by Clint Helfers, with permission.
      	// http://blindsignals.com/index.php/2009/07/jquery-delay/
      	delay: function( time, type ) {
      		time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      		type = type || "fx";
      
      		return this.queue( type, function() {
      			var elem = this;
      			setTimeout(function() {
      				jQuery.dequeue( elem, type );
      			}, time );
      		});
      	},
      	clearQueue: function( type ) {
      		return this.queue( type || "fx", [] );
      	},
      	// Get a promise resolved when queues of a certain type
      	// are emptied (fx is the type by default)
      	promise: function( type, object ) {
      		if ( typeof type !== "string" ) {
      			object = type;
      			type = undefined;
      		}
      		type = type || "fx";
      		var defer = jQuery.Deferred(),
      			elements = this,
      			i = elements.length,
      			count = 1,
      			deferDataKey = type + "defer",
      			queueDataKey = type + "queue",
      			markDataKey = type + "mark",
      			tmp;
      		function resolve() {
      			if ( !( --count ) ) {
      				defer.resolveWith( elements, [ elements ] );
      			}
      		}
      		while( i-- ) {
      			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
      					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
      						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
      					jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true ) )) {
      				count++;
      				tmp.done( resolve );
      			}
      		}
      		resolve();
      		return defer.promise();
      	}
      });
      
      
      
      
      var rclass = /[\n\t\r]/g,
      	rspace = /\s+/,
      	rreturn = /\r/g,
      	rtype = /^(?:button|input)$/i,
      	rfocusable = /^(?:button|input|object|select|textarea)$/i,
      	rclickable = /^a(?:rea)?$/i,
      	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
      	rinvalidChar = /\:/,
      	formHook, boolHook;
      
      jQuery.fn.extend({
      	attr: function( name, value ) {
      		return jQuery.access( this, name, value, true, jQuery.attr );
      	},
      
      	removeAttr: function( name ) {
      		return this.each(function() {
      			jQuery.removeAttr( this, name );
      		});
      	},
      	
      	prop: function( name, value ) {
      		return jQuery.access( this, name, value, true, jQuery.prop );
      	},
      	
      	removeProp: function( name ) {
      		name = jQuery.propFix[ name ] || name;
      		return this.each(function() {
      			// try/catch handles cases where IE balks (such as removing a property on window)
      			try {
      				this[ name ] = undefined;
      				delete this[ name ];
      			} catch( e ) {}
      		});
      	},
      
      	addClass: function( value ) {
      		if ( jQuery.isFunction( value ) ) {
      			return this.each(function(i) {
      				var self = jQuery(this);
      				self.addClass( value.call(this, i, self.attr("class") || "") );
      			});
      		}
      
      		if ( value && typeof value === "string" ) {
      			var classNames = (value || "").split( rspace );
      
      			for ( var i = 0, l = this.length; i < l; i++ ) {
      				var elem = this[i];
      
      				if ( elem.nodeType === 1 ) {
      					if ( !elem.className ) {
      						elem.className = value;
      
      					} else {
      						var className = " " + elem.className + " ",
      							setClass = elem.className;
      
      						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
      							if ( className.indexOf( " " + classNames[c] + " " ) < 0 ) {
      								setClass += " " + classNames[c];
      							}
      						}
      						elem.className = jQuery.trim( setClass );
      					}
      				}
      			}
      		}
      
      		return this;
      	},
      
      	removeClass: function( value ) {
      		if ( jQuery.isFunction(value) ) {
      			return this.each(function(i) {
      				var self = jQuery(this);
      				self.removeClass( value.call(this, i, self.attr("class")) );
      			});
      		}
      
      		if ( (value && typeof value === "string") || value === undefined ) {
      			var classNames = (value || "").split( rspace );
      
      			for ( var i = 0, l = this.length; i < l; i++ ) {
      				var elem = this[i];
      
      				if ( elem.nodeType === 1 && elem.className ) {
      					if ( value ) {
      						var className = (" " + elem.className + " ").replace(rclass, " ");
      						for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
      							className = className.replace(" " + classNames[c] + " ", " ");
      						}
      						elem.className = jQuery.trim( className );
      
      					} else {
      						elem.className = "";
      					}
      				}
      			}
      		}
      
      		return this;
      	},
      
      	toggleClass: function( value, stateVal ) {
      		var type = typeof value,
      			isBool = typeof stateVal === "boolean";
      
      		if ( jQuery.isFunction( value ) ) {
      			return this.each(function(i) {
      				var self = jQuery(this);
      				self.toggleClass( value.call(this, i, self.attr("class"), stateVal), stateVal );
      			});
      		}
      
      		return this.each(function() {
      			if ( type === "string" ) {
      				// toggle individual class names
      				var className,
      					i = 0,
      					self = jQuery( this ),
      					state = stateVal,
      					classNames = value.split( rspace );
      
      				while ( (className = classNames[ i++ ]) ) {
      					// check each className given, space seperated list
      					state = isBool ? state : !self.hasClass( className );
      					self[ state ? "addClass" : "removeClass" ]( className );
      				}
      
      			} else if ( type === "undefined" || type === "boolean" ) {
      				if ( this.className ) {
      					// store className if set
      					jQuery._data( this, "__className__", this.className );
      				}
      
      				// toggle whole className
      				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
      			}
      		});
      	},
      
      	hasClass: function( selector ) {
      		var className = " " + selector + " ";
      		for ( var i = 0, l = this.length; i < l; i++ ) {
      			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
      				return true;
      			}
      		}
      
      		return false;
      	},
      
      	val: function( value ) {
      		var hooks, ret,
      			elem = this[0];
      		
      		if ( !arguments.length ) {
      			if ( elem ) {
      				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];
      
      				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
      					return ret;
      				}
      
      				return (elem.value || "").replace(rreturn, "");
      			}
      
      			return undefined;
      		}
      
      		var isFunction = jQuery.isFunction( value );
      
      		return this.each(function( i ) {
      			var self = jQuery(this), val;
      
      			if ( this.nodeType !== 1 ) {
      				return;
      			}
      
      			if ( isFunction ) {
      				val = value.call( this, i, self.val() );
      			} else {
      				val = value;
      			}
      
      			// Treat null/undefined as ""; convert numbers to string
      			if ( val == null ) {
      				val = "";
      			} else if ( typeof val === "number" ) {
      				val += "";
      			} else if ( jQuery.isArray( val ) ) {
      				val = jQuery.map(val, function ( value ) {
      					return value == null ? "" : value + "";
      				});
      			}
      
      			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];
      
      			// If set returns undefined, fall back to normal setting
      			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
      				this.value = val;
      			}
      		});
      	}
      });
      
      jQuery.extend({
      	valHooks: {
      		option: {
      			get: function( elem ) {
      				// attributes.value is undefined in Blackberry 4.7 but
      				// uses .value. See #6932
      				var val = elem.attributes.value;
      				return !val || val.specified ? elem.value : elem.text;
      			}
      		},
      		select: {
      			get: function( elem ) {
      				var value,
      					index = elem.selectedIndex,
      					values = [],
      					options = elem.options,
      					one = elem.type === "select-one";
      
      				// Nothing was selected
      				if ( index < 0 ) {
      					return null;
      				}
      
      				// Loop through all the selected options
      				for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
      					var option = options[ i ];
      
      					// Don't return options that are disabled or in a disabled optgroup
      					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
      							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {
      
      						// Get the specific value for the option
      						value = jQuery( option ).val();
      
      						// We don't need an array for one selects
      						if ( one ) {
      							return value;
      						}
      
      						// Multi-Selects return an array
      						values.push( value );
      					}
      				}
      
      				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
      				if ( one && !values.length && options.length ) {
      					return jQuery( options[ index ] ).val();
      				}
      
      				return values;
      			},
      
      			set: function( elem, value ) {
      				var values = jQuery.makeArray( value );
      
      				jQuery(elem).find("option").each(function() {
      					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
      				});
      
      				if ( !values.length ) {
      					elem.selectedIndex = -1;
      				}
      				return values;
      			}
      		}
      	},
      
      	attrFn: {
      		val: true,
      		css: true,
      		html: true,
      		text: true,
      		data: true,
      		width: true,
      		height: true,
      		offset: true
      	},
      	
      	attrFix: {
      		// Always normalize to ensure hook usage
      		tabindex: "tabIndex"
      	},
      	
      	attr: function( elem, name, value, pass ) {
      		var nType = elem.nodeType;
      		
      		// don't get/set attributes on text, comment and attribute nodes
      		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      			return undefined;
      		}
      
      		if ( pass && name in jQuery.attrFn ) {
      			return jQuery( elem )[ name ]( value );
      		}
      
      		// Fallback to prop when attributes are not supported
      		if ( !("getAttribute" in elem) ) {
      			return jQuery.prop( elem, name, value );
      		}
      
      		var ret, hooks,
      			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
      
      		// Normalize the name if needed
      		name = notxml && jQuery.attrFix[ name ] || name;
      
      		hooks = jQuery.attrHooks[ name ];
      
      		if ( !hooks ) {
      			// Use boolHook for boolean attributes
      			if ( rboolean.test( name ) &&
      				(typeof value === "boolean" || value === undefined || value.toLowerCase() === name.toLowerCase()) ) {
      
      				hooks = boolHook;
      
      			// Use formHook for forms and if the name contains certain characters
      			} else if ( formHook && (jQuery.nodeName( elem, "form" ) || rinvalidChar.test( name )) ) {
      				hooks = formHook;
      			}
      		}
      
      		if ( value !== undefined ) {
      
      			if ( value === null ) {
      				jQuery.removeAttr( elem, name );
      				return undefined;
      
      			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
      				return ret;
      
      			} else {
      				elem.setAttribute( name, "" + value );
      				return value;
      			}
      
      		} else if ( hooks && "get" in hooks && notxml ) {
      			return hooks.get( elem, name );
      
      		} else {
      
      			ret = elem.getAttribute( name );
      
      			// Non-existent attributes return null, we normalize to undefined
      			return ret === null ?
      				undefined :
      				ret;
      		}
      	},
      
      	removeAttr: function( elem, name ) {
      		var propName;
      		if ( elem.nodeType === 1 ) {
      			name = jQuery.attrFix[ name ] || name;
      		
      			if ( jQuery.support.getSetAttribute ) {
      				// Use removeAttribute in browsers that support it
      				elem.removeAttribute( name );
      			} else {
      				jQuery.attr( elem, name, "" );
      				elem.removeAttributeNode( elem.getAttributeNode( name ) );
      			}
      
      			// Set corresponding property to false for boolean attributes
      			if ( rboolean.test( name ) && (propName = jQuery.propFix[ name ] || name) in elem ) {
      				elem[ propName ] = false;
      			}
      		}
      	},
      
      	attrHooks: {
      		type: {
      			set: function( elem, value ) {
      				// We can't allow the type property to be changed (since it causes problems in IE)
      				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
      					jQuery.error( "type property can't be changed" );
      				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
      					// Setting the type on a radio button after the value resets the value in IE6-9
      					// Reset value to it's default in case type is set after value
      					// This is for element creation
      					var val = elem.value;
      					elem.setAttribute( "type", value );
      					if ( val ) {
      						elem.value = val;
      					}
      					return value;
      				}
      			}
      		},
      		tabIndex: {
      			get: function( elem ) {
      				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
      				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
      				var attributeNode = elem.getAttributeNode("tabIndex");
      
      				return attributeNode && attributeNode.specified ?
      					parseInt( attributeNode.value, 10 ) :
      					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
      						0 :
      						undefined;
      			}
      		}
      	},
      
      	propFix: {
      		tabindex: "tabIndex",
      		readonly: "readOnly",
      		"for": "htmlFor",
      		"class": "className",
      		maxlength: "maxLength",
      		cellspacing: "cellSpacing",
      		cellpadding: "cellPadding",
      		rowspan: "rowSpan",
      		colspan: "colSpan",
      		usemap: "useMap",
      		frameborder: "frameBorder",
      		contenteditable: "contentEditable"
      	},
      	
      	prop: function( elem, name, value ) {
      		var nType = elem.nodeType;
      
      		// don't get/set properties on text, comment and attribute nodes
      		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
      			return undefined;
      		}
      
      		var ret, hooks,
      			notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
      
      		// Try to normalize/fix the name
      		name = notxml && jQuery.propFix[ name ] || name;
      		
      		hooks = jQuery.propHooks[ name ];
      
      		if ( value !== undefined ) {
      			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
      				return ret;
      
      			} else {
      				return (elem[ name ] = value);
      			}
      
      		} else {
      			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== undefined ) {
      				return ret;
      
      			} else {
      				return elem[ name ];
      			}
      		}
      	},
      	
      	propHooks: {}
      });
      
      // Hook for boolean attributes
      boolHook = {
      	get: function( elem, name ) {
      		// Align boolean attributes with corresponding properties
      		return elem[ jQuery.propFix[ name ] || name ] ?
      			name.toLowerCase() :
      			undefined;
      	},
      	set: function( elem, value, name ) {
      		var propName;
      		if ( value === false ) {
      			// Remove boolean attributes when set to false
      			jQuery.removeAttr( elem, name );
      		} else {
      			// value is true since we know at this point it's type boolean and not false
      			// Set boolean attributes to the same name and set the DOM property
      			propName = jQuery.propFix[ name ] || name;
      			if ( propName in elem ) {
      				// Only set the IDL specifically if it already exists on the element
      				elem[ propName ] = value;
      			}
      
      			elem.setAttribute( name, name.toLowerCase() );
      		}
      		return name;
      	}
      };
      
      // Use the value property for back compat
      // Use the formHook for button elements in IE6/7 (#1954)
      jQuery.attrHooks.value = {
      	get: function( elem, name ) {
      		if ( formHook && jQuery.nodeName( elem, "button" ) ) {
      			return formHook.get( elem, name );
      		}
      		return elem.value;
      	},
      	set: function( elem, value, name ) {
      		if ( formHook && jQuery.nodeName( elem, "button" ) ) {
      			return formHook.set( elem, value, name );
      		}
      		// Does not return so that setAttribute is also used
      		elem.value = value;
      	}
      };
      
      // IE6/7 do not support getting/setting some attributes with get/setAttribute
      if ( !jQuery.support.getSetAttribute ) {
      
      	// propFix is more comprehensive and contains all fixes
      	jQuery.attrFix = jQuery.propFix;
      	
      	// Use this for any attribute on a form in IE6/7
      	formHook = jQuery.attrHooks.name = jQuery.valHooks.button = {
      		get: function( elem, name ) {
      			var ret;
      			ret = elem.getAttributeNode( name );
      			// Return undefined if nodeValue is empty string
      			return ret && ret.nodeValue !== "" ?
      				ret.nodeValue :
      				undefined;
      		},
      		set: function( elem, value, name ) {
      			// Check form objects in IE (multiple bugs related)
      			// Only use nodeValue if the attribute node exists on the form
      			var ret = elem.getAttributeNode( name );
      			if ( ret ) {
      				ret.nodeValue = value;
      				return value;
      			}
      		}
      	};
      
      	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
      	// This is for removals
      	jQuery.each([ "width", "height" ], function( i, name ) {
      		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      			set: function( elem, value ) {
      				if ( value === "" ) {
      					elem.setAttribute( name, "auto" );
      					return value;
      				}
      			}
      		});
      	});
      }
      
      
      // Some attributes require a special call on IE
      if ( !jQuery.support.hrefNormalized ) {
      	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
      		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
      			get: function( elem ) {
      				var ret = elem.getAttribute( name, 2 );
      				return ret === null ? undefined : ret;
      			}
      		});
      	});
      }
      
      if ( !jQuery.support.style ) {
      	jQuery.attrHooks.style = {
      		get: function( elem ) {
      			// Return undefined in the case of empty string
      			// Normalize to lowercase since IE uppercases css property names
      			return elem.style.cssText.toLowerCase() || undefined;
      		},
      		set: function( elem, value ) {
      			return (elem.style.cssText = "" + value);
      		}
      	};
      }
      
      // Safari mis-reports the default selected property of an option
      // Accessing the parent's selectedIndex property fixes it
      if ( !jQuery.support.optSelected ) {
      	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
      		get: function( elem ) {
      			var parent = elem.parentNode;
      
      			if ( parent ) {
      				parent.selectedIndex;
      
      				// Make sure that it also works with optgroups, see #5701
      				if ( parent.parentNode ) {
      					parent.parentNode.selectedIndex;
      				}
      			}
      		}
      	});
      }
      
      // Radios and checkboxes getter/setter
      if ( !jQuery.support.checkOn ) {
      	jQuery.each([ "radio", "checkbox" ], function() {
      		jQuery.valHooks[ this ] = {
      			get: function( elem ) {
      				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
      				return elem.getAttribute("value") === null ? "on" : elem.value;
      			}
      		};
      	});
      }
      jQuery.each([ "radio", "checkbox" ], function() {
      	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
      		set: function( elem, value ) {
      			if ( jQuery.isArray( value ) ) {
      				return (elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0);
      			}
      		}
      	});
      });
      
      
      
      
      var hasOwn = Object.prototype.hasOwnProperty,
      	rnamespaces = /\.(.*)$/,
      	rformElems = /^(?:textarea|input|select)$/i,
      	rperiod = /\./g,
      	rspaces = / /g,
      	rescape = /[^\w\s.|`]/g,
      	fcleanup = function( nm ) {
      		return nm.replace(rescape, "\\$&");
      	};
      
      /*
       * A number of helper functions used for managing events.
       * Many of the ideas behind this code originated from
       * Dean Edwards' addEvent library.
       */
      jQuery.event = {
      
      	// Bind an event to an element
      	// Original by Dean Edwards
      	add: function( elem, types, handler, data ) {
      		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
      			return;
      		}
      
      		if ( handler === false ) {
      			handler = returnFalse;
      		} else if ( !handler ) {
      			// Fixes bug #7229. Fix recommended by jdalton
      			return;
      		}
      
      		var handleObjIn, handleObj;
      
      		if ( handler.handler ) {
      			handleObjIn = handler;
      			handler = handleObjIn.handler;
      		}
      
      		// Make sure that the function being executed has a unique ID
      		if ( !handler.guid ) {
      			handler.guid = jQuery.guid++;
      		}
      
      		// Init the element's event structure
      		var elemData = jQuery._data( elem );
      
      		// If no elemData is found then we must be trying to bind to one of the
      		// banned noData elements
      		if ( !elemData ) {
      			return;
      		}
      
      		var events = elemData.events,
      			eventHandle = elemData.handle;
      
      		if ( !events ) {
      			elemData.events = events = {};
      		}
      
      		if ( !eventHandle ) {
      			elemData.handle = eventHandle = function( e ) {
      				// Discard the second event of a jQuery.event.trigger() and
      				// when an event is called after a page has unloaded
      				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
      					jQuery.event.handle.apply( eventHandle.elem, arguments ) :
      					undefined;
      			};
      		}
      
      		// Add elem as a property of the handle function
      		// This is to prevent a memory leak with non-native events in IE.
      		eventHandle.elem = elem;
      
      		// Handle multiple events separated by a space
      		// jQuery(...).bind("mouseover mouseout", fn);
      		types = types.split(" ");
      
      		var type, i = 0, namespaces;
      
      		while ( (type = types[ i++ ]) ) {
      			handleObj = handleObjIn ?
      				jQuery.extend({}, handleObjIn) :
      				{ handler: handler, data: data };
      
      			// Namespaced event handlers
      			if ( type.indexOf(".") > -1 ) {
      				namespaces = type.split(".");
      				type = namespaces.shift();
      				handleObj.namespace = namespaces.slice(0).sort().join(".");
      
      			} else {
      				namespaces = [];
      				handleObj.namespace = "";
      			}
      
      			handleObj.type = type;
      			if ( !handleObj.guid ) {
      				handleObj.guid = handler.guid;
      			}
      
      			// Get the current list of functions bound to this event
      			var handlers = events[ type ],
      				special = jQuery.event.special[ type ] || {};
      
      			// Init the event handler queue
      			if ( !handlers ) {
      				handlers = events[ type ] = [];
      
      				// Check for a special event handler
      				// Only use addEventListener/attachEvent if the special
      				// events handler returns false
      				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
      					// Bind the global event handler to the element
      					if ( elem.addEventListener ) {
      						elem.addEventListener( type, eventHandle, false );
      
      					} else if ( elem.attachEvent ) {
      						elem.attachEvent( "on" + type, eventHandle );
      					}
      				}
      			}
      
      			if ( special.add ) {
      				special.add.call( elem, handleObj );
      
      				if ( !handleObj.handler.guid ) {
      					handleObj.handler.guid = handler.guid;
      				}
      			}
      
      			// Add the function to the element's handler list
      			handlers.push( handleObj );
      
      			// Keep track of which events have been used, for event optimization
      			jQuery.event.global[ type ] = true;
      		}
      
      		// Nullify elem to prevent memory leaks in IE
      		elem = null;
      	},
      
      	global: {},
      
      	// Detach an event or set of events from an element
      	remove: function( elem, types, handler, pos ) {
      		// don't do events on text and comment nodes
      		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
      			return;
      		}
      
      		if ( handler === false ) {
      			handler = returnFalse;
      		}
      
      		var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
      			elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
      			events = elemData && elemData.events;
      
      		if ( !elemData || !events ) {
      			return;
      		}
      
      		// types is actually an event object here
      		if ( types && types.type ) {
      			handler = types.handler;
      			types = types.type;
      		}
      
      		// Unbind all events for the element
      		if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
      			types = types || "";
      
      			for ( type in events ) {
      				jQuery.event.remove( elem, type + types );
      			}
      
      			return;
      		}
      
      		// Handle multiple events separated by a space
      		// jQuery(...).unbind("mouseover mouseout", fn);
      		types = types.split(" ");
      
      		while ( (type = types[ i++ ]) ) {
      			origType = type;
      			handleObj = null;
      			all = type.indexOf(".") < 0;
      			namespaces = [];
      
      			if ( !all ) {
      				// Namespaced event handlers
      				namespaces = type.split(".");
      				type = namespaces.shift();
      
      				namespace = new RegExp("(^|\\.)" +
      					jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
      			}
      
      			eventType = events[ type ];
      
      			if ( !eventType ) {
      				continue;
      			}
      
      			if ( !handler ) {
      				for ( j = 0; j < eventType.length; j++ ) {
      					handleObj = eventType[ j ];
      
      					if ( all || namespace.test( handleObj.namespace ) ) {
      						jQuery.event.remove( elem, origType, handleObj.handler, j );
      						eventType.splice( j--, 1 );
      					}
      				}
      
      				continue;
      			}
      
      			special = jQuery.event.special[ type ] || {};
      
      			for ( j = pos || 0; j < eventType.length; j++ ) {
      				handleObj = eventType[ j ];
      
      				if ( handler.guid === handleObj.guid ) {
      					// remove the given handler for the given type
      					if ( all || namespace.test( handleObj.namespace ) ) {
      						if ( pos == null ) {
      							eventType.splice( j--, 1 );
      						}
      
      						if ( special.remove ) {
      							special.remove.call( elem, handleObj );
      						}
      					}
      
      					if ( pos != null ) {
      						break;
      					}
      				}
      			}
      
      			// remove generic event handler if no more handlers exist
      			if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
      				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
      					jQuery.removeEvent( elem, type, elemData.handle );
      				}
      
      				ret = null;
      				delete events[ type ];
      			}
      		}
      
      		// Remove the expando if it's no longer used
      		if ( jQuery.isEmptyObject( events ) ) {
      			var handle = elemData.handle;
      			if ( handle ) {
      				handle.elem = null;
      			}
      
      			delete elemData.events;
      			delete elemData.handle;
      
      			if ( jQuery.isEmptyObject( elemData ) ) {
      				jQuery.removeData( elem, undefined, true );
      			}
      		}
      	},
      	
      	// Events that are safe to short-circuit if no handlers are attached.
      	// Native DOM events should not be added, they may have inline handlers.
      	customEvent: {
      		"getData": true,
      		"setData": true,
      		"changeData": true
      	},
      
      	trigger: function( event, data, elem, onlyHandlers ) {
      		// Event object or event type
      		var type = event.type || event,
      			namespaces = [],
      			exclusive;
      
      		if ( type.indexOf("!") >= 0 ) {
      			// Exclusive events trigger only for the exact event (no namespaces)
      			type = type.slice(0, -1);
      			exclusive = true;
      		}
      
      		if ( type.indexOf(".") >= 0 ) {
      			// Namespaced trigger; create a regexp to match event type in handle()
      			namespaces = type.split(".");
      			type = namespaces.shift();
      			namespaces.sort();
      		}
      
      		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
      			// No jQuery handlers for this event type, and it can't have inline handlers
      			return;
      		}
      
      		// Caller can pass in an Event, Object, or just an event type string
      		event = typeof event === "object" ?
      			// jQuery.Event object
      			event[ jQuery.expando ] ? event :
      			// Object literal
      			new jQuery.Event( type, event ) :
      			// Just the event type (string)
      			new jQuery.Event( type );
      
      		event.type = type;
      		event.exclusive = exclusive;
      		event.namespace = namespaces.join(".");
      		event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");
      		
      		// triggerHandler() and global events don't bubble or run the default action
      		if ( onlyHandlers || !elem ) {
      			event.preventDefault();
      			event.stopPropagation();
      		}
      
      		// Handle a global trigger
      		if ( !elem ) {
      			// TODO: Stop taunting the data cache; remove global events and always attach to document
      			jQuery.each( jQuery.cache, function() {
      				// internalKey variable is just used to make it easier to find
      				// and potentially change this stuff later; currently it just
      				// points to jQuery.expando
      				var internalKey = jQuery.expando,
      					internalCache = this[ internalKey ];
      				if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
      					jQuery.event.trigger( event, data, internalCache.handle.elem );
      				}
      			});
      			return;
      		}
      
      		// Don't do events on text and comment nodes
      		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
      			return;
      		}
      
      		// Clean up the event in case it is being reused
      		event.result = undefined;
      		event.target = elem;
      
      		// Clone any incoming data and prepend the event, creating the handler arg list
      		data = data ? jQuery.makeArray( data ) : [];
      		data.unshift( event );
      
      		var cur = elem,
      			// IE doesn't like method names with a colon (#3533, #8272)
      			ontype = type.indexOf(":") < 0 ? "on" + type : "";
      
      		// Fire event on the current element, then bubble up the DOM tree
      		do {
      			var handle = jQuery._data( cur, "handle" );
      
      			event.currentTarget = cur;
      			if ( handle ) {
      				handle.apply( cur, data );
      			}
      
      			// Trigger an inline bound script
      			if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ ontype ].apply( cur, data ) === false ) {
      				event.result = false;
      				event.preventDefault();
      			}
      
      			// Bubble up to document, then to window
      			cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
      		} while ( cur && !event.isPropagationStopped() );
      
      		// If nobody prevented the default action, do it now
      		if ( !event.isDefaultPrevented() ) {
      			var old,
      				special = jQuery.event.special[ type ] || {};
      
      			if ( (!special._default || special._default.call( elem.ownerDocument, event ) === false) &&
      				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {
      
      				// Call a native DOM method on the target with the same name name as the event.
      				// Can't use an .isFunction)() check here because IE6/7 fails that test.
      				// IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
      				try {
      					if ( ontype && elem[ type ] ) {
      						// Don't re-trigger an onFOO event when we call its FOO() method
      						old = elem[ ontype ];
      
      						if ( old ) {
      							elem[ ontype ] = null;
      						}
      
      						jQuery.event.triggered = type;
      						elem[ type ]();
      					}
      				} catch ( ieError ) {}
      
      				if ( old ) {
      					elem[ ontype ] = old;
      				}
      
      				jQuery.event.triggered = undefined;
      			}
      		}
      		
      		return event.result;
      	},
      
      	handle: function( event ) {
      		event = jQuery.event.fix( event || window.event );
      		// Snapshot the handlers list since a called handler may add/remove events.
      		var handlers = ((jQuery._data( this, "events" ) || {})[ event.type ] || []).slice(0),
      			run_all = !event.exclusive && !event.namespace,
      			args = Array.prototype.slice.call( arguments, 0 );
      
      		// Use the fix-ed Event rather than the (read-only) native event
      		args[0] = event;
      		event.currentTarget = this;
      
      		for ( var j = 0, l = handlers.length; j < l; j++ ) {
      			var handleObj = handlers[ j ];
      
      			// Triggered event must 1) be non-exclusive and have no namespace, or
      			// 2) have namespace(s) a subset or equal to those in the bound event.
      			if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {
      				// Pass in a reference to the handler function itself
      				// So that we can later remove it
      				event.handler = handleObj.handler;
      				event.data = handleObj.data;
      				event.handleObj = handleObj;
      
      				var ret = handleObj.handler.apply( this, args );
      
      				if ( ret !== undefined ) {
      					event.result = ret;
      					if ( ret === false ) {
      						event.preventDefault();
      						event.stopPropagation();
      					}
      				}
      
      				if ( event.isImmediatePropagationStopped() ) {
      					break;
      				}
      			}
      		}
      		return event.result;
      	},
      
      	props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
      
      	fix: function( event ) {
      		if ( event[ jQuery.expando ] ) {
      			return event;
      		}
      
      		// store a copy of the original event object
      		// and "clone" to set read-only properties
      		var originalEvent = event;
      		event = jQuery.Event( originalEvent );
      
      		for ( var i = this.props.length, prop; i; ) {
      			prop = this.props[ --i ];
      			event[ prop ] = originalEvent[ prop ];
      		}
      
      		// Fix target property, if necessary
      		if ( !event.target ) {
      			// Fixes #1925 where srcElement might not be defined either
      			event.target = event.srcElement || document;
      		}
      
      		// check if target is a textnode (safari)
      		if ( event.target.nodeType === 3 ) {
      			event.target = event.target.parentNode;
      		}
      
      		// Add relatedTarget, if necessary
      		if ( !event.relatedTarget && event.fromElement ) {
      			event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
      		}
      
      		// Calculate pageX/Y if missing and clientX/Y available
      		if ( event.pageX == null && event.clientX != null ) {
      			var eventDocument = event.target.ownerDocument || document,
      				doc = eventDocument.documentElement,
      				body = eventDocument.body;
      
      			event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      			event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
      		}
      
      		// Add which for key events
      		if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
      			event.which = event.charCode != null ? event.charCode : event.keyCode;
      		}
      
      		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
      		if ( !event.metaKey && event.ctrlKey ) {
      			event.metaKey = event.ctrlKey;
      		}
      
      		// Add which for click: 1 === left; 2 === middle; 3 === right
      		// Note: button is not normalized, so don't use it
      		if ( !event.which && event.button !== undefined ) {
      			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
      		}
      
      		return event;
      	},
      
      	// Deprecated, use jQuery.guid instead
      	guid: 1E8,
      
      	// Deprecated, use jQuery.proxy instead
      	proxy: jQuery.proxy,
      
      	special: {
      		ready: {
      			// Make sure the ready event is setup
      			setup: jQuery.bindReady,
      			teardown: jQuery.noop
      		},
      
      		live: {
      			add: function( handleObj ) {
      				jQuery.event.add( this,
      					liveConvert( handleObj.origType, handleObj.selector ),
      					jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
      			},
      
      			remove: function( handleObj ) {
      				jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
      			}
      		},
      
      		beforeunload: {
      			setup: function( data, namespaces, eventHandle ) {
      				// We only want to do this special case on windows
      				if ( jQuery.isWindow( this ) ) {
      					this.onbeforeunload = eventHandle;
      				}
      			},
      
      			teardown: function( namespaces, eventHandle ) {
      				if ( this.onbeforeunload === eventHandle ) {
      					this.onbeforeunload = null;
      				}
      			}
      		}
      	}
      };
      
      jQuery.removeEvent = document.removeEventListener ?
      	function( elem, type, handle ) {
      		if ( elem.removeEventListener ) {
      			elem.removeEventListener( type, handle, false );
      		}
      	} :
      	function( elem, type, handle ) {
      		if ( elem.detachEvent ) {
      			elem.detachEvent( "on" + type, handle );
      		}
      	};
      
      jQuery.Event = function( src, props ) {
      	// Allow instantiation without the 'new' keyword
      	if ( !this.preventDefault ) {
      		return new jQuery.Event( src, props );
      	}
      
      	// Event object
      	if ( src && src.type ) {
      		this.originalEvent = src;
      		this.type = src.type;
      
      		// Events bubbling up the document may have been marked as prevented
      		// by a handler lower down the tree; reflect the correct value.
      		this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
      			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;
      
      	// Event type
      	} else {
      		this.type = src;
      	}
      
      	// Put explicitly provided properties onto the event object
      	if ( props ) {
      		jQuery.extend( this, props );
      	}
      
      	// timeStamp is buggy for some events on Firefox(#3843)
      	// So we won't rely on the native value
      	this.timeStamp = jQuery.now();
      
      	// Mark it as fixed
      	this[ jQuery.expando ] = true;
      };
      
      function returnFalse() {
      	return false;
      }
      function returnTrue() {
      	return true;
      }
      
      // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
      // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
      jQuery.Event.prototype = {
      	preventDefault: function() {
      		this.isDefaultPrevented = returnTrue;
      
      		var e = this.originalEvent;
      		if ( !e ) {
      			return;
      		}
      
      		// if preventDefault exists run it on the original event
      		if ( e.preventDefault ) {
      			e.preventDefault();
      
      		// otherwise set the returnValue property of the original event to false (IE)
      		} else {
      			e.returnValue = false;
      		}
      	},
      	stopPropagation: function() {
      		this.isPropagationStopped = returnTrue;
      
      		var e = this.originalEvent;
      		if ( !e ) {
      			return;
      		}
      		// if stopPropagation exists run it on the original event
      		if ( e.stopPropagation ) {
      			e.stopPropagation();
      		}
      		// otherwise set the cancelBubble property of the original event to true (IE)
      		e.cancelBubble = true;
      	},
      	stopImmediatePropagation: function() {
      		this.isImmediatePropagationStopped = returnTrue;
      		this.stopPropagation();
      	},
      	isDefaultPrevented: returnFalse,
      	isPropagationStopped: returnFalse,
      	isImmediatePropagationStopped: returnFalse
      };
      
      // Checks if an event happened on an element within another element
      // Used in jQuery.event.special.mouseenter and mouseleave handlers
      var withinElement = function( event ) {
      	// Check if mouse(over|out) are still within the same parent element
      	var parent = event.relatedTarget;
      
      	// set the correct event type
      	event.type = event.data;
      
      	// Firefox sometimes assigns relatedTarget a XUL element
      	// which we cannot access the parentNode property of
      	try {
      
      		// Chrome does something similar, the parentNode property
      		// can be accessed but is null.
      		if ( parent && parent !== document && !parent.parentNode ) {
      			return;
      		}
      
      		// Traverse up the tree
      		while ( parent && parent !== this ) {
      			parent = parent.parentNode;
      		}
      
      		if ( parent !== this ) {
      			// handle event if we actually just moused on to a non sub-element
      			jQuery.event.handle.apply( this, arguments );
      		}
      
      	// assuming we've left the element since we most likely mousedover a xul element
      	} catch(e) { }
      },
      
      // In case of event delegation, we only need to rename the event.type,
      // liveHandler will take care of the rest.
      delegate = function( event ) {
      	event.type = event.data;
      	jQuery.event.handle.apply( this, arguments );
      };
      
      // Create mouseenter and mouseleave events
      jQuery.each({
      	mouseenter: "mouseover",
      	mouseleave: "mouseout"
      }, function( orig, fix ) {
      	jQuery.event.special[ orig ] = {
      		setup: function( data ) {
      			jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
      		},
      		teardown: function( data ) {
      			jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
      		}
      	};
      });
      
      // submit delegation
      if ( !jQuery.support.submitBubbles ) {
      
      	jQuery.event.special.submit = {
      		setup: function( data, namespaces ) {
      			if ( !jQuery.nodeName( this, "form" ) ) {
      				jQuery.event.add(this, "click.specialSubmit", function( e ) {
      					var elem = e.target,
      						type = elem.type;
      
      					if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
      						trigger( "submit", this, arguments );
      					}
      				});
      
      				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
      					var elem = e.target,
      						type = elem.type;
      
      					if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
      						trigger( "submit", this, arguments );
      					}
      				});
      
      			} else {
      				return false;
      			}
      		},
      
      		teardown: function( namespaces ) {
      			jQuery.event.remove( this, ".specialSubmit" );
      		}
      	};
      
      }
      
      // change delegation, happens here so we have bind.
      if ( !jQuery.support.changeBubbles ) {
      
      	var changeFilters,
      
      	getVal = function( elem ) {
      		var type = elem.type, val = elem.value;
      
      		if ( type === "radio" || type === "checkbox" ) {
      			val = elem.checked;
      
      		} else if ( type === "select-multiple" ) {
      			val = elem.selectedIndex > -1 ?
      				jQuery.map( elem.options, function( elem ) {
      					return elem.selected;
      				}).join("-") :
      				"";
      
      		} else if ( jQuery.nodeName( elem, "select" ) ) {
      			val = elem.selectedIndex;
      		}
      
      		return val;
      	},
      
      	testChange = function testChange( e ) {
      		var elem = e.target, data, val;
      
      		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
      			return;
      		}
      
      		data = jQuery._data( elem, "_change_data" );
      		val = getVal(elem);
      
      		// the current data will be also retrieved by beforeactivate
      		if ( e.type !== "focusout" || elem.type !== "radio" ) {
      			jQuery._data( elem, "_change_data", val );
      		}
      
      		if ( data === undefined || val === data ) {
      			return;
      		}
      
      		if ( data != null || val ) {
      			e.type = "change";
      			e.liveFired = undefined;
      			jQuery.event.trigger( e, arguments[1], elem );
      		}
      	};
      
      	jQuery.event.special.change = {
      		filters: {
      			focusout: testChange,
      
      			beforedeactivate: testChange,
      
      			click: function( e ) {
      				var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";
      
      				if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
      					testChange.call( this, e );
      				}
      			},
      
      			// Change has to be called before submit
      			// Keydown will be called before keypress, which is used in submit-event delegation
      			keydown: function( e ) {
      				var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";
      
      				if ( (e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
      					(e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
      					type === "select-multiple" ) {
      					testChange.call( this, e );
      				}
      			},
      
      			// Beforeactivate happens also before the previous element is blurred
      			// with this event you can't trigger a change event, but you can store
      			// information
      			beforeactivate: function( e ) {
      				var elem = e.target;
      				jQuery._data( elem, "_change_data", getVal(elem) );
      			}
      		},
      
      		setup: function( data, namespaces ) {
      			if ( this.type === "file" ) {
      				return false;
      			}
      
      			for ( var type in changeFilters ) {
      				jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
      			}
      
      			return rformElems.test( this.nodeName );
      		},
      
      		teardown: function( namespaces ) {
      			jQuery.event.remove( this, ".specialChange" );
      
      			return rformElems.test( this.nodeName );
      		}
      	};
      
      	changeFilters = jQuery.event.special.change.filters;
      
      	// Handle when the input is .focus()'d
      	changeFilters.focus = changeFilters.beforeactivate;
      }
      
      function trigger( type, elem, args ) {
      	// Piggyback on a donor event to simulate a different one.
      	// Fake originalEvent to avoid donor's stopPropagation, but if the
      	// simulated event prevents default then we do the same on the donor.
      	// Don't pass args or remember liveFired; they apply to the donor event.
      	var event = jQuery.extend( {}, args[ 0 ] );
      	event.type = type;
      	event.originalEvent = {};
      	event.liveFired = undefined;
      	jQuery.event.handle.call( elem, event );
      	if ( event.isDefaultPrevented() ) {
      		args[ 0 ].preventDefault();
      	}
      }
      
      // Create "bubbling" focus and blur events
      if ( !jQuery.support.focusinBubbles ) {
      	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
      
      		// Attach a single capturing handler while someone wants focusin/focusout
      		var attaches = 0;
      
      		jQuery.event.special[ fix ] = {
      			setup: function() {
      				if ( attaches++ === 0 ) {
      					document.addEventListener( orig, handler, true );
      				}
      			},
      			teardown: function() {
      				if ( --attaches === 0 ) {
      					document.removeEventListener( orig, handler, true );
      				}
      			}
      		};
      
      		function handler( donor ) {
      			// Donor event is always a native one; fix it and switch its type.
      			// Let focusin/out handler cancel the donor focus/blur event.
      			var e = jQuery.event.fix( donor );
      			e.type = fix;
      			e.originalEvent = {};
      			jQuery.event.trigger( e, null, e.target );
      			if ( e.isDefaultPrevented() ) {
      				donor.preventDefault();
      			}
      		}
      	});
      }
      
      jQuery.each(["bind", "one"], function( i, name ) {
      	jQuery.fn[ name ] = function( type, data, fn ) {
      		var handler;
      
      		// Handle object literals
      		if ( typeof type === "object" ) {
      			for ( var key in type ) {
      				this[ name ](key, data, type[key], fn);
      			}
      			return this;
      		}
      
      		if ( arguments.length === 2 || data === false ) {
      			fn = data;
      			data = undefined;
      		}
      
      		if ( name === "one" ) {
      			handler = function( event ) {
      				jQuery( this ).unbind( event, handler );
      				return fn.apply( this, arguments );
      			};
      			handler.guid = fn.guid || jQuery.guid++;
      		} else {
      			handler = fn;
      		}
      
      		if ( type === "unload" && name !== "one" ) {
      			this.one( type, data, fn );
      
      		} else {
      			for ( var i = 0, l = this.length; i < l; i++ ) {
      				jQuery.event.add( this[i], type, handler, data );
      			}
      		}
      
      		return this;
      	};
      });
      
      jQuery.fn.extend({
      	unbind: function( type, fn ) {
      		// Handle object literals
      		if ( typeof type === "object" && !type.preventDefault ) {
      			for ( var key in type ) {
      				this.unbind(key, type[key]);
      			}
      
      		} else {
      			for ( var i = 0, l = this.length; i < l; i++ ) {
      				jQuery.event.remove( this[i], type, fn );
      			}
      		}
      
      		return this;
      	},
      
      	delegate: function( selector, types, data, fn ) {
      		return this.live( types, data, fn, selector );
      	},
      
      	undelegate: function( selector, types, fn ) {
      		if ( arguments.length === 0 ) {
      			return this.unbind( "live" );
      
      		} else {
      			return this.die( types, null, fn, selector );
      		}
      	},
      
      	trigger: function( type, data ) {
      		return this.each(function() {
      			jQuery.event.trigger( type, data, this );
      		});
      	},
      
      	triggerHandler: function( type, data ) {
      		if ( this[0] ) {
      			return jQuery.event.trigger( type, data, this[0], true );
      		}
      	},
      
      	toggle: function( fn ) {
      		// Save reference to arguments for access in closure
      		var args = arguments,
      			guid = fn.guid || jQuery.guid++,
      			i = 0,
      			toggler = function( event ) {
      				// Figure out which function to execute
      				var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
      				jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );
      
      				// Make sure that clicks stop
      				event.preventDefault();
      
      				// and execute the function
      				return args[ lastToggle ].apply( this, arguments ) || false;
      			};
      
      		// link all the functions, so any of them can unbind this click handler
      		toggler.guid = guid;
      		while ( i < args.length ) {
      			args[ i++ ].guid = guid;
      		}
      
      		return this.click( toggler );
      	},
      
      	hover: function( fnOver, fnOut ) {
      		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
      	}
      });
      
      var liveMap = {
      	focus: "focusin",
      	blur: "focusout",
      	mouseenter: "mouseover",
      	mouseleave: "mouseout"
      };
      
      jQuery.each(["live", "die"], function( i, name ) {
      	jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
      		var type, i = 0, match, namespaces, preType,
      			selector = origSelector || this.selector,
      			context = origSelector ? this : jQuery( this.context );
      
      		if ( typeof types === "object" && !types.preventDefault ) {
      			for ( var key in types ) {
      				context[ name ]( key, data, types[key], selector );
      			}
      
      			return this;
      		}
      
      		if ( name === "die" && !types &&
      					origSelector && origSelector.charAt(0) === "." ) {
      
      			context.unbind( origSelector );
      
      			return this;
      		}
      
      		if ( data === false || jQuery.isFunction( data ) ) {
      			fn = data || returnFalse;
      			data = undefined;
      		}
      
      		types = (types || "").split(" ");
      
      		while ( (type = types[ i++ ]) != null ) {
      			match = rnamespaces.exec( type );
      			namespaces = "";
      
      			if ( match )  {
      				namespaces = match[0];
      				type = type.replace( rnamespaces, "" );
      			}
      
      			if ( type === "hover" ) {
      				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
      				continue;
      			}
      
      			preType = type;
      
      			if ( liveMap[ type ] ) {
      				types.push( liveMap[ type ] + namespaces );
      				type = type + namespaces;
      
      			} else {
      				type = (liveMap[ type ] || type) + namespaces;
      			}
      
      			if ( name === "live" ) {
      				// bind live handler
      				for ( var j = 0, l = context.length; j < l; j++ ) {
      					jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
      						{ data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
      				}
      
      			} else {
      				// unbind live handler
      				context.unbind( "live." + liveConvert( type, selector ), fn );
      			}
      		}
      
      		return this;
      	};
      });
      
      function liveHandler( event ) {
      	var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
      		elems = [],
      		selectors = [],
      		events = jQuery._data( this, "events" );
      
      	// Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
      	if ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click" ) {
      		return;
      	}
      
      	if ( event.namespace ) {
      		namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
      	}
      
      	event.liveFired = this;
      
      	var live = events.live.slice(0);
      
      	for ( j = 0; j < live.length; j++ ) {
      		handleObj = live[j];
      
      		if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
      			selectors.push( handleObj.selector );
      
      		} else {
      			live.splice( j--, 1 );
      		}
      	}
      
      	match = jQuery( event.target ).closest( selectors, event.currentTarget );
      
      	for ( i = 0, l = match.length; i < l; i++ ) {
      		close = match[i];
      
      		for ( j = 0; j < live.length; j++ ) {
      			handleObj = live[j];
      
      			if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {
      				elem = close.elem;
      				related = null;
      
      				// Those two events require additional checking
      				if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
      					event.type = handleObj.preType;
      					related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];
      
      					// Make sure not to accidentally match a child element with the same selector
      					if ( related && jQuery.contains( elem, related ) ) {
      						related = elem;
      					}
      				}
      
      				if ( !related || related !== elem ) {
      					elems.push({ elem: elem, handleObj: handleObj, level: close.level });
      				}
      			}
      		}
      	}
      
      	for ( i = 0, l = elems.length; i < l; i++ ) {
      		match = elems[i];
      
      		if ( maxLevel && match.level > maxLevel ) {
      			break;
      		}
      
      		event.currentTarget = match.elem;
      		event.data = match.handleObj.data;
      		event.handleObj = match.handleObj;
      
      		ret = match.handleObj.origHandler.apply( match.elem, arguments );
      
      		if ( ret === false || event.isPropagationStopped() ) {
      			maxLevel = match.level;
      
      			if ( ret === false ) {
      				stop = false;
      			}
      			if ( event.isImmediatePropagationStopped() ) {
      				break;
      			}
      		}
      	}
      
      	return stop;
      }
      
      function liveConvert( type, selector ) {
      	return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
      }
      
      jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
      	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
      	"change select submit keydown keypress keyup error").split(" "), function( i, name ) {
      
      	// Handle event binding
      	jQuery.fn[ name ] = function( data, fn ) {
      		if ( fn == null ) {
      			fn = data;
      			data = null;
      		}
      
      		return arguments.length > 0 ?
      			this.bind( name, data, fn ) :
      			this.trigger( name );
      	};
      
      	if ( jQuery.attrFn ) {
      		jQuery.attrFn[ name ] = true;
      	}
      });
      
      
      
      /*!
       * Sizzle CSS Selector Engine
       *  Copyright 2011, The Dojo Foundation
       *  Released under the MIT, BSD, and GPL Licenses.
       *  More information: http://sizzlejs.com/
       */
      (function(){
      
      var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
      	done = 0,
      	toString = Object.prototype.toString,
      	hasDuplicate = false,
      	baseHasDuplicate = true,
      	rBackslash = /\\/g,
      	rNonWord = /\W/;
      
      // Here we check if the JavaScript engine is using some sort of
      // optimization where it does not always call our comparision
      // function. If that is the case, discard the hasDuplicate value.
      //   Thus far that includes Google Chrome.
      [0, 0].sort(function() {
      	baseHasDuplicate = false;
      	return 0;
      });
      
      var Sizzle = function( selector, context, results, seed ) {
      	results = results || [];
      	context = context || document;
      
      	var origContext = context;
      
      	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
      		return [];
      	}
      	
      	if ( !selector || typeof selector !== "string" ) {
      		return results;
      	}
      
      	var m, set, checkSet, extra, ret, cur, pop, i,
      		prune = true,
      		contextXML = Sizzle.isXML( context ),
      		parts = [],
      		soFar = selector;
      	
      	// Reset the position of the chunker regexp (start from head)
      	do {
      		chunker.exec( "" );
      		m = chunker.exec( soFar );
      
      		if ( m ) {
      			soFar = m[3];
      		
      			parts.push( m[1] );
      		
      			if ( m[2] ) {
      				extra = m[3];
      				break;
      			}
      		}
      	} while ( m );
      
      	if ( parts.length > 1 && origPOS.exec( selector ) ) {
      
      		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
      			set = posProcess( parts[0] + parts[1], context );
      
      		} else {
      			set = Expr.relative[ parts[0] ] ?
      				[ context ] :
      				Sizzle( parts.shift(), context );
      
      			while ( parts.length ) {
      				selector = parts.shift();
      
      				if ( Expr.relative[ selector ] ) {
      					selector += parts.shift();
      				}
      				
      				set = posProcess( selector, set );
      			}
      		}
      
      	} else {
      		// Take a shortcut and set the context if the root selector is an ID
      		// (but not if it'll be faster if the inner selector is an ID)
      		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
      				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {
      
      			ret = Sizzle.find( parts.shift(), context, contextXML );
      			context = ret.expr ?
      				Sizzle.filter( ret.expr, ret.set )[0] :
      				ret.set[0];
      		}
      
      		if ( context ) {
      			ret = seed ?
      				{ expr: parts.pop(), set: makeArray(seed) } :
      				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );
      
      			set = ret.expr ?
      				Sizzle.filter( ret.expr, ret.set ) :
      				ret.set;
      
      			if ( parts.length > 0 ) {
      				checkSet = makeArray( set );
      
      			} else {
      				prune = false;
      			}
      
      			while ( parts.length ) {
      				cur = parts.pop();
      				pop = cur;
      
      				if ( !Expr.relative[ cur ] ) {
      					cur = "";
      				} else {
      					pop = parts.pop();
      				}
      
      				if ( pop == null ) {
      					pop = context;
      				}
      
      				Expr.relative[ cur ]( checkSet, pop, contextXML );
      			}
      
      		} else {
      			checkSet = parts = [];
      		}
      	}
      
      	if ( !checkSet ) {
      		checkSet = set;
      	}
      
      	if ( !checkSet ) {
      		Sizzle.error( cur || selector );
      	}
      
      	if ( toString.call(checkSet) === "[object Array]" ) {
      		if ( !prune ) {
      			results.push.apply( results, checkSet );
      
      		} else if ( context && context.nodeType === 1 ) {
      			for ( i = 0; checkSet[i] != null; i++ ) {
      				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
      					results.push( set[i] );
      				}
      			}
      
      		} else {
      			for ( i = 0; checkSet[i] != null; i++ ) {
      				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
      					results.push( set[i] );
      				}
      			}
      		}
      
      	} else {
      		makeArray( checkSet, results );
      	}
      
      	if ( extra ) {
      		Sizzle( extra, origContext, results, seed );
      		Sizzle.uniqueSort( results );
      	}
      
      	return results;
      };
      
      Sizzle.uniqueSort = function( results ) {
      	if ( sortOrder ) {
      		hasDuplicate = baseHasDuplicate;
      		results.sort( sortOrder );
      
      		if ( hasDuplicate ) {
      			for ( var i = 1; i < results.length; i++ ) {
      				if ( results[i] === results[ i - 1 ] ) {
      					results.splice( i--, 1 );
      				}
      			}
      		}
      	}
      
      	return results;
      };
      
      Sizzle.matches = function( expr, set ) {
      	return Sizzle( expr, null, null, set );
      };
      
      Sizzle.matchesSelector = function( node, expr ) {
      	return Sizzle( expr, null, null, [node] ).length > 0;
      };
      
      Sizzle.find = function( expr, context, isXML ) {
      	var set;
      
      	if ( !expr ) {
      		return [];
      	}
      
      	for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
      		var match,
      			type = Expr.order[i];
      		
      		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
      			var left = match[1];
      			match.splice( 1, 1 );
      
      			if ( left.substr( left.length - 1 ) !== "\\" ) {
      				match[1] = (match[1] || "").replace( rBackslash, "" );
      				set = Expr.find[ type ]( match, context, isXML );
      
      				if ( set != null ) {
      					expr = expr.replace( Expr.match[ type ], "" );
      					break;
      				}
      			}
      		}
      	}
      
      	if ( !set ) {
      		set = typeof context.getElementsByTagName !== "undefined" ?
      			context.getElementsByTagName( "*" ) :
      			[];
      	}
      
      	return { set: set, expr: expr };
      };
      
      Sizzle.filter = function( expr, set, inplace, not ) {
      	var match, anyFound,
      		old = expr,
      		result = [],
      		curLoop = set,
      		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );
      
      	while ( expr && set.length ) {
      		for ( var type in Expr.filter ) {
      			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
      				var found, item,
      					filter = Expr.filter[ type ],
      					left = match[1];
      
      				anyFound = false;
      
      				match.splice(1,1);
      
      				if ( left.substr( left.length - 1 ) === "\\" ) {
      					continue;
      				}
      
      				if ( curLoop === result ) {
      					result = [];
      				}
      
      				if ( Expr.preFilter[ type ] ) {
      					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
      
      					if ( !match ) {
      						anyFound = found = true;
      
      					} else if ( match === true ) {
      						continue;
      					}
      				}
      
      				if ( match ) {
      					for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
      						if ( item ) {
      							found = filter( item, match, i, curLoop );
      							var pass = not ^ !!found;
      
      							if ( inplace && found != null ) {
      								if ( pass ) {
      									anyFound = true;
      
      								} else {
      									curLoop[i] = false;
      								}
      
      							} else if ( pass ) {
      								result.push( item );
      								anyFound = true;
      							}
      						}
      					}
      				}
      
      				if ( found !== undefined ) {
      					if ( !inplace ) {
      						curLoop = result;
      					}
      
      					expr = expr.replace( Expr.match[ type ], "" );
      
      					if ( !anyFound ) {
      						return [];
      					}
      
      					break;
      				}
      			}
      		}
      
      		// Improper expression
      		if ( expr === old ) {
      			if ( anyFound == null ) {
      				Sizzle.error( expr );
      
      			} else {
      				break;
      			}
      		}
      
      		old = expr;
      	}
      
      	return curLoop;
      };
      
      Sizzle.error = function( msg ) {
      	throw "Syntax error, unrecognized expression: " + msg;
      };
      
      var Expr = Sizzle.selectors = {
      	order: [ "ID", "NAME", "TAG" ],
      
      	match: {
      		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
      		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
      		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
      		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
      		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
      		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
      		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
      		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
      	},
      
      	leftMatch: {},
      
      	attrMap: {
      		"class": "className",
      		"for": "htmlFor"
      	},
      
      	attrHandle: {
      		href: function( elem ) {
      			return elem.getAttribute( "href" );
      		},
      		type: function( elem ) {
      			return elem.getAttribute( "type" );
      		}
      	},
      
      	relative: {
      		"+": function(checkSet, part){
      			var isPartStr = typeof part === "string",
      				isTag = isPartStr && !rNonWord.test( part ),
      				isPartStrNotTag = isPartStr && !isTag;
      
      			if ( isTag ) {
      				part = part.toLowerCase();
      			}
      
      			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
      				if ( (elem = checkSet[i]) ) {
      					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}
      
      					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
      						elem || false :
      						elem === part;
      				}
      			}
      
      			if ( isPartStrNotTag ) {
      				Sizzle.filter( part, checkSet, true );
      			}
      		},
      
      		">": function( checkSet, part ) {
      			var elem,
      				isPartStr = typeof part === "string",
      				i = 0,
      				l = checkSet.length;
      
      			if ( isPartStr && !rNonWord.test( part ) ) {
      				part = part.toLowerCase();
      
      				for ( ; i < l; i++ ) {
      					elem = checkSet[i];
      
      					if ( elem ) {
      						var parent = elem.parentNode;
      						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
      					}
      				}
      
      			} else {
      				for ( ; i < l; i++ ) {
      					elem = checkSet[i];
      
      					if ( elem ) {
      						checkSet[i] = isPartStr ?
      							elem.parentNode :
      							elem.parentNode === part;
      					}
      				}
      
      				if ( isPartStr ) {
      					Sizzle.filter( part, checkSet, true );
      				}
      			}
      		},
      
      		"": function(checkSet, part, isXML){
      			var nodeCheck,
      				doneName = done++,
      				checkFn = dirCheck;
      
      			if ( typeof part === "string" && !rNonWord.test( part ) ) {
      				part = part.toLowerCase();
      				nodeCheck = part;
      				checkFn = dirNodeCheck;
      			}
      
      			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
      		},
      
      		"~": function( checkSet, part, isXML ) {
      			var nodeCheck,
      				doneName = done++,
      				checkFn = dirCheck;
      
      			if ( typeof part === "string" && !rNonWord.test( part ) ) {
      				part = part.toLowerCase();
      				nodeCheck = part;
      				checkFn = dirNodeCheck;
      			}
      
      			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
      		}
      	},
      
      	find: {
      		ID: function( match, context, isXML ) {
      			if ( typeof context.getElementById !== "undefined" && !isXML ) {
      				var m = context.getElementById(match[1]);
      				// Check parentNode to catch when Blackberry 4.6 returns
      				// nodes that are no longer in the document #6963
      				return m && m.parentNode ? [m] : [];
      			}
      		},
      
      		NAME: function( match, context ) {
      			if ( typeof context.getElementsByName !== "undefined" ) {
      				var ret = [],
      					results = context.getElementsByName( match[1] );
      
      				for ( var i = 0, l = results.length; i < l; i++ ) {
      					if ( results[i].getAttribute("name") === match[1] ) {
      						ret.push( results[i] );
      					}
      				}
      
      				return ret.length === 0 ? null : ret;
      			}
      		},
      
      		TAG: function( match, context ) {
      			if ( typeof context.getElementsByTagName !== "undefined" ) {
      				return context.getElementsByTagName( match[1] );
      			}
      		}
      	},
      	preFilter: {
      		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
      			match = " " + match[1].replace( rBackslash, "" ) + " ";
      
      			if ( isXML ) {
      				return match;
      			}
      
      			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
      				if ( elem ) {
      					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
      						if ( !inplace ) {
      							result.push( elem );
      						}
      
      					} else if ( inplace ) {
      						curLoop[i] = false;
      					}
      				}
      			}
      
      			return false;
      		},
      
      		ID: function( match ) {
      			return match[1].replace( rBackslash, "" );
      		},
      
      		TAG: function( match, curLoop ) {
      			return match[1].replace( rBackslash, "" ).toLowerCase();
      		},
      
      		CHILD: function( match ) {
      			if ( match[1] === "nth" ) {
      				if ( !match[2] ) {
      					Sizzle.error( match[0] );
      				}
      
      				match[2] = match[2].replace(/^\+|\s*/g, '');
      
      				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
      				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
      					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
      					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);
      
      				// calculate the numbers (first)n+(last) including if they are negative
      				match[2] = (test[1] + (test[2] || 1)) - 0;
      				match[3] = test[3] - 0;
      			}
      			else if ( match[2] ) {
      				Sizzle.error( match[0] );
      			}
      
      			// TODO: Move to normal caching system
      			match[0] = done++;
      
      			return match;
      		},
      
      		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
      			var name = match[1] = match[1].replace( rBackslash, "" );
      			
      			if ( !isXML && Expr.attrMap[name] ) {
      				match[1] = Expr.attrMap[name];
      			}
      
      			// Handle if an un-quoted value was used
      			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );
      
      			if ( match[2] === "~=" ) {
      				match[4] = " " + match[4] + " ";
      			}
      
      			return match;
      		},
      
      		PSEUDO: function( match, curLoop, inplace, result, not ) {
      			if ( match[1] === "not" ) {
      				// If we're dealing with a complex expression, or a simple one
      				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
      					match[3] = Sizzle(match[3], null, null, curLoop);
      
      				} else {
      					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
      
      					if ( !inplace ) {
      						result.push.apply( result, ret );
      					}
      
      					return false;
      				}
      
      			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
      				return true;
      			}
      			
      			return match;
      		},
      
      		POS: function( match ) {
      			match.unshift( true );
      
      			return match;
      		}
      	},
      	
      	filters: {
      		enabled: function( elem ) {
      			return elem.disabled === false && elem.type !== "hidden";
      		},
      
      		disabled: function( elem ) {
      			return elem.disabled === true;
      		},
      
      		checked: function( elem ) {
      			return elem.checked === true;
      		},
      		
      		selected: function( elem ) {
      			// Accessing this property makes selected-by-default
      			// options in Safari work properly
      			if ( elem.parentNode ) {
      				elem.parentNode.selectedIndex;
      			}
      			
      			return elem.selected === true;
      		},
      
      		parent: function( elem ) {
      			return !!elem.firstChild;
      		},
      
      		empty: function( elem ) {
      			return !elem.firstChild;
      		},
      
      		has: function( elem, i, match ) {
      			return !!Sizzle( match[3], elem ).length;
      		},
      
      		header: function( elem ) {
      			return (/h\d/i).test( elem.nodeName );
      		},
      
      		text: function( elem ) {
      			var attr = elem.getAttribute( "type" ), type = elem.type;
      			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
      			// use getAttribute instead to test this case
      			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
      		},
      
      		radio: function( elem ) {
      			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
      		},
      
      		checkbox: function( elem ) {
      			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
      		},
      
      		file: function( elem ) {
      			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
      		},
      
      		password: function( elem ) {
      			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
      		},
      
      		submit: function( elem ) {
      			var name = elem.nodeName.toLowerCase();
      			return (name === "input" || name === "button") && "submit" === elem.type;
      		},
      
      		image: function( elem ) {
      			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
      		},
      
      		reset: function( elem ) {
      			var name = elem.nodeName.toLowerCase();
      			return (name === "input" || name === "button") && "reset" === elem.type;
      		},
      
      		button: function( elem ) {
      			var name = elem.nodeName.toLowerCase();
      			return name === "input" && "button" === elem.type || name === "button";
      		},
      
      		input: function( elem ) {
      			return (/input|select|textarea|button/i).test( elem.nodeName );
      		},
      
      		focus: function( elem ) {
      			return elem === elem.ownerDocument.activeElement;
      		}
      	},
      	setFilters: {
      		first: function( elem, i ) {
      			return i === 0;
      		},
      
      		last: function( elem, i, match, array ) {
      			return i === array.length - 1;
      		},
      
      		even: function( elem, i ) {
      			return i % 2 === 0;
      		},
      
      		odd: function( elem, i ) {
      			return i % 2 === 1;
      		},
      
      		lt: function( elem, i, match ) {
      			return i < match[3] - 0;
      		},
      
      		gt: function( elem, i, match ) {
      			return i > match[3] - 0;
      		},
      
      		nth: function( elem, i, match ) {
      			return match[3] - 0 === i;
      		},
      
      		eq: function( elem, i, match ) {
      			return match[3] - 0 === i;
      		}
      	},
      	filter: {
      		PSEUDO: function( elem, match, i, array ) {
      			var name = match[1],
      				filter = Expr.filters[ name ];
      
      			if ( filter ) {
      				return filter( elem, i, match, array );
      
      			} else if ( name === "contains" ) {
      				return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;
      
      			} else if ( name === "not" ) {
      				var not = match[3];
      
      				for ( var j = 0, l = not.length; j < l; j++ ) {
      					if ( not[j] === elem ) {
      						return false;
      					}
      				}
      
      				return true;
      
      			} else {
      				Sizzle.error( name );
      			}
      		},
      
      		CHILD: function( elem, match ) {
      			var type = match[1],
      				node = elem;
      
      			switch ( type ) {
      				case "only":
      				case "first":
      					while ( (node = node.previousSibling) )	 {
      						if ( node.nodeType === 1 ) { 
      							return false; 
      						}
      					}
      
      					if ( type === "first" ) { 
      						return true; 
      					}
      
      					node = elem;
      
      				case "last":
      					while ( (node = node.nextSibling) )	 {
      						if ( node.nodeType === 1 ) { 
      							return false; 
      						}
      					}
      
      					return true;
      
      				case "nth":
      					var first = match[2],
      						last = match[3];
      
      					if ( first === 1 && last === 0 ) {
      						return true;
      					}
      					
      					var doneName = match[0],
      						parent = elem.parentNode;
      	
      					if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
      						var count = 0;
      						
      						for ( node = parent.firstChild; node; node = node.nextSibling ) {
      							if ( node.nodeType === 1 ) {
      								node.nodeIndex = ++count;
      							}
      						} 
      
      						parent.sizcache = doneName;
      					}
      					
      					var diff = elem.nodeIndex - last;
      
      					if ( first === 0 ) {
      						return diff === 0;
      
      					} else {
      						return ( diff % first === 0 && diff / first >= 0 );
      					}
      			}
      		},
      
      		ID: function( elem, match ) {
      			return elem.nodeType === 1 && elem.getAttribute("id") === match;
      		},
      
      		TAG: function( elem, match ) {
      			return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
      		},
      		
      		CLASS: function( elem, match ) {
      			return (" " + (elem.className || elem.getAttribute("class")) + " ")
      				.indexOf( match ) > -1;
      		},
      
      		ATTR: function( elem, match ) {
      			var name = match[1],
      				result = Expr.attrHandle[ name ] ?
      					Expr.attrHandle[ name ]( elem ) :
      					elem[ name ] != null ?
      						elem[ name ] :
      						elem.getAttribute( name ),
      				value = result + "",
      				type = match[2],
      				check = match[4];
      
      			return result == null ?
      				type === "!=" :
      				type === "=" ?
      				value === check :
      				type === "*=" ?
      				value.indexOf(check) >= 0 :
      				type === "~=" ?
      				(" " + value + " ").indexOf(check) >= 0 :
      				!check ?
      				value && result !== false :
      				type === "!=" ?
      				value !== check :
      				type === "^=" ?
      				value.indexOf(check) === 0 :
      				type === "$=" ?
      				value.substr(value.length - check.length) === check :
      				type === "|=" ?
      				value === check || value.substr(0, check.length + 1) === check + "-" :
      				false;
      		},
      
      		POS: function( elem, match, i, array ) {
      			var name = match[2],
      				filter = Expr.setFilters[ name ];
      
      			if ( filter ) {
      				return filter( elem, i, match, array );
      			}
      		}
      	}
      };
      
      var origPOS = Expr.match.POS,
      	fescape = function(all, num){
      		return "\\" + (num - 0 + 1);
      	};
      
      for ( var type in Expr.match ) {
      	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
      	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
      }
      
      var makeArray = function( array, results ) {
      	array = Array.prototype.slice.call( array, 0 );
      
      	if ( results ) {
      		results.push.apply( results, array );
      		return results;
      	}
      	
      	return array;
      };
      
      // Perform a simple check to determine if the browser is capable of
      // converting a NodeList to an array using builtin methods.
      // Also verifies that the returned array holds DOM nodes
      // (which is not the case in the Blackberry browser)
      try {
      	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
      
      // Provide a fallback method if it does not work
      } catch( e ) {
      	makeArray = function( array, results ) {
      		var i = 0,
      			ret = results || [];
      
      		if ( toString.call(array) === "[object Array]" ) {
      			Array.prototype.push.apply( ret, array );
      
      		} else {
      			if ( typeof array.length === "number" ) {
      				for ( var l = array.length; i < l; i++ ) {
      					ret.push( array[i] );
      				}
      
      			} else {
      				for ( ; array[i]; i++ ) {
      					ret.push( array[i] );
      				}
      			}
      		}
      
      		return ret;
      	};
      }
      
      var sortOrder, siblingCheck;
      
      if ( document.documentElement.compareDocumentPosition ) {
      	sortOrder = function( a, b ) {
      		if ( a === b ) {
      			hasDuplicate = true;
      			return 0;
      		}
      
      		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
      			return a.compareDocumentPosition ? -1 : 1;
      		}
      
      		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
      	};
      
      } else {
      	sortOrder = function( a, b ) {
      		// The nodes are identical, we can exit early
      		if ( a === b ) {
      			hasDuplicate = true;
      			return 0;
      
      		// Fallback to using sourceIndex (in IE) if it's available on both nodes
      		} else if ( a.sourceIndex && b.sourceIndex ) {
      			return a.sourceIndex - b.sourceIndex;
      		}
      
      		var al, bl,
      			ap = [],
      			bp = [],
      			aup = a.parentNode,
      			bup = b.parentNode,
      			cur = aup;
      
      		// If the nodes are siblings (or identical) we can do a quick check
      		if ( aup === bup ) {
      			return siblingCheck( a, b );
      
      		// If no parents were found then the nodes are disconnected
      		} else if ( !aup ) {
      			return -1;
      
      		} else if ( !bup ) {
      			return 1;
      		}
      
      		// Otherwise they're somewhere else in the tree so we need
      		// to build up a full list of the parentNodes for comparison
      		while ( cur ) {
      			ap.unshift( cur );
      			cur = cur.parentNode;
      		}
      
      		cur = bup;
      
      		while ( cur ) {
      			bp.unshift( cur );
      			cur = cur.parentNode;
      		}
      
      		al = ap.length;
      		bl = bp.length;
      
      		// Start walking down the tree looking for a discrepancy
      		for ( var i = 0; i < al && i < bl; i++ ) {
      			if ( ap[i] !== bp[i] ) {
      				return siblingCheck( ap[i], bp[i] );
      			}
      		}
      
      		// We ended someplace up the tree so do a sibling check
      		return i === al ?
      			siblingCheck( a, bp[i], -1 ) :
      			siblingCheck( ap[i], b, 1 );
      	};
      
      	siblingCheck = function( a, b, ret ) {
      		if ( a === b ) {
      			return ret;
      		}
      
      		var cur = a.nextSibling;
      
      		while ( cur ) {
      			if ( cur === b ) {
      				return -1;
      			}
      
      			cur = cur.nextSibling;
      		}
      
      		return 1;
      	};
      }
      
      // Utility function for retreiving the text value of an array of DOM nodes
      Sizzle.getText = function( elems ) {
      	var ret = "", elem;
      
      	for ( var i = 0; elems[i]; i++ ) {
      		elem = elems[i];
      
      		// Get the text from text nodes and CDATA nodes
      		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
      			ret += elem.nodeValue;
      
      		// Traverse everything else, except comment nodes
      		} else if ( elem.nodeType !== 8 ) {
      			ret += Sizzle.getText( elem.childNodes );
      		}
      	}
      
      	return ret;
      };
      
      // Check to see if the browser returns elements by name when
      // querying by getElementById (and provide a workaround)
      (function(){
      	// We're going to inject a fake input element with a specified name
      	var form = document.createElement("div"),
      		id = "script" + (new Date()).getTime(),
      		root = document.documentElement;
      
      	form.innerHTML = "<a name='" + id + "'/>";
      
      	// Inject it into the root element, check its status, and remove it quickly
      	root.insertBefore( form, root.firstChild );
      
      	// The workaround has to do additional checks after a getElementById
      	// Which slows things down for other browsers (hence the branching)
      	if ( document.getElementById( id ) ) {
      		Expr.find.ID = function( match, context, isXML ) {
      			if ( typeof context.getElementById !== "undefined" && !isXML ) {
      				var m = context.getElementById(match[1]);
      
      				return m ?
      					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
      						[m] :
      						undefined :
      					[];
      			}
      		};
      
      		Expr.filter.ID = function( elem, match ) {
      			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
      
      			return elem.nodeType === 1 && node && node.nodeValue === match;
      		};
      	}
      
      	root.removeChild( form );
      
      	// release memory in IE
      	root = form = null;
      })();
      
      (function(){
      	// Check to see if the browser returns only elements
      	// when doing getElementsByTagName("*")
      
      	// Create a fake element
      	var div = document.createElement("div");
      	div.appendChild( document.createComment("") );
      
      	// Make sure no comments are found
      	if ( div.getElementsByTagName("*").length > 0 ) {
      		Expr.find.TAG = function( match, context ) {
      			var results = context.getElementsByTagName( match[1] );
      
      			// Filter out possible comments
      			if ( match[1] === "*" ) {
      				var tmp = [];
      
      				for ( var i = 0; results[i]; i++ ) {
      					if ( results[i].nodeType === 1 ) {
      						tmp.push( results[i] );
      					}
      				}
      
      				results = tmp;
      			}
      
      			return results;
      		};
      	}
      
      	// Check to see if an attribute returns normalized href attributes
      	div.innerHTML = "<a href='#'></a>";
      
      	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
      			div.firstChild.getAttribute("href") !== "#" ) {
      
      		Expr.attrHandle.href = function( elem ) {
      			return elem.getAttribute( "href", 2 );
      		};
      	}
      
      	// release memory in IE
      	div = null;
      })();
      
      if ( document.querySelectorAll ) {
      	(function(){
      		var oldSizzle = Sizzle,
      			div = document.createElement("div"),
      			id = "__sizzle__";
      
      		div.innerHTML = "<p class='TEST'></p>";
      
      		// Safari can't handle uppercase or unicode characters when
      		// in quirks mode.
      		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
      			return;
      		}
      	
      		Sizzle = function( query, context, extra, seed ) {
      			context = context || document;
      
      			// Only use querySelectorAll on non-XML documents
      			// (ID selectors don't work in non-HTML documents)
      			if ( !seed && !Sizzle.isXML(context) ) {
      				// See if we find a selector to speed up
      				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
      				
      				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
      					// Speed-up: Sizzle("TAG")
      					if ( match[1] ) {
      						return makeArray( context.getElementsByTagName( query ), extra );
      					
      					// Speed-up: Sizzle(".CLASS")
      					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
      						return makeArray( context.getElementsByClassName( match[2] ), extra );
      					}
      				}
      				
      				if ( context.nodeType === 9 ) {
      					// Speed-up: Sizzle("body")
      					// The body element only exists once, optimize finding it
      					if ( query === "body" && context.body ) {
      						return makeArray( [ context.body ], extra );
      						
      					// Speed-up: Sizzle("#ID")
      					} else if ( match && match[3] ) {
      						var elem = context.getElementById( match[3] );
      
      						// Check parentNode to catch when Blackberry 4.6 returns
      						// nodes that are no longer in the document #6963
      						if ( elem && elem.parentNode ) {
      							// Handle the case where IE and Opera return items
      							// by name instead of ID
      							if ( elem.id === match[3] ) {
      								return makeArray( [ elem ], extra );
      							}
      							
      						} else {
      							return makeArray( [], extra );
      						}
      					}
      					
      					try {
      						return makeArray( context.querySelectorAll(query), extra );
      					} catch(qsaError) {}
      
      				// qSA works strangely on Element-rooted queries
      				// We can work around this by specifying an extra ID on the root
      				// and working up from there (Thanks to Andrew Dupont for the technique)
      				// IE 8 doesn't work on object elements
      				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
      					var oldContext = context,
      						old = context.getAttribute( "id" ),
      						nid = old || id,
      						hasParent = context.parentNode,
      						relativeHierarchySelector = /^\s*[+~]/.test( query );
      
      					if ( !old ) {
      						context.setAttribute( "id", nid );
      					} else {
      						nid = nid.replace( /'/g, "\\$&" );
      					}
      					if ( relativeHierarchySelector && hasParent ) {
      						context = context.parentNode;
      					}
      
      					try {
      						if ( !relativeHierarchySelector || hasParent ) {
      							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
      						}
      
      					} catch(pseudoError) {
      					} finally {
      						if ( !old ) {
      							oldContext.removeAttribute( "id" );
      						}
      					}
      				}
      			}
      		
      			return oldSizzle(query, context, extra, seed);
      		};
      
      		for ( var prop in oldSizzle ) {
      			Sizzle[ prop ] = oldSizzle[ prop ];
      		}
      
      		// release memory in IE
      		div = null;
      	})();
      }
      
      (function(){
      	var html = document.documentElement,
      		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
      
      	if ( matches ) {
      		// Check to see if it's possible to do matchesSelector
      		// on a disconnected node (IE 9 fails this)
      		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
      			pseudoWorks = false;
      
      		try {
      			// This should fail with an exception
      			// Gecko does not error, returns false instead
      			matches.call( document.documentElement, "[test!='']:sizzle" );
      	
      		} catch( pseudoError ) {
      			pseudoWorks = true;
      		}
      
      		Sizzle.matchesSelector = function( node, expr ) {
      			// Make sure that attribute selectors are quoted
      			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
      
      			if ( !Sizzle.isXML( node ) ) {
      				try { 
      					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
      						var ret = matches.call( node, expr );
      
      						// IE 9's matchesSelector returns false on disconnected nodes
      						if ( ret || !disconnectedMatch ||
      								// As well, disconnected nodes are said to be in a document
      								// fragment in IE 9, so check for that
      								node.document && node.document.nodeType !== 11 ) {
      							return ret;
      						}
      					}
      				} catch(e) {}
      			}
      
      			return Sizzle(expr, null, null, [node]).length > 0;
      		};
      	}
      })();
      
      (function(){
      	var div = document.createElement("div");
      
      	div.innerHTML = "<div class='test e'></div><div class='test'></div>";
      
      	// Opera can't find a second classname (in 9.6)
      	// Also, make sure that getElementsByClassName actually exists
      	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
      		return;
      	}
      
      	// Safari caches class attributes, doesn't catch changes (in 3.2)
      	div.lastChild.className = "e";
      
      	if ( div.getElementsByClassName("e").length === 1 ) {
      		return;
      	}
      	
      	Expr.order.splice(1, 0, "CLASS");
      	Expr.find.CLASS = function( match, context, isXML ) {
      		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
      			return context.getElementsByClassName(match[1]);
      		}
      	};
      
      	// release memory in IE
      	div = null;
      })();
      
      function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
      	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
      		var elem = checkSet[i];
      
      		if ( elem ) {
      			var match = false;
      
      			elem = elem[dir];
      
      			while ( elem ) {
      				if ( elem.sizcache === doneName ) {
      					match = checkSet[elem.sizset];
      					break;
      				}
      
      				if ( elem.nodeType === 1 && !isXML ){
      					elem.sizcache = doneName;
      					elem.sizset = i;
      				}
      
      				if ( elem.nodeName.toLowerCase() === cur ) {
      					match = elem;
      					break;
      				}
      
      				elem = elem[dir];
      			}
      
      			checkSet[i] = match;
      		}
      	}
      }
      
      function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
      	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
      		var elem = checkSet[i];
      
      		if ( elem ) {
      			var match = false;
      			
      			elem = elem[dir];
      
      			while ( elem ) {
      				if ( elem.sizcache === doneName ) {
      					match = checkSet[elem.sizset];
      					break;
      				}
      
      				if ( elem.nodeType === 1 ) {
      					if ( !isXML ) {
      						elem.sizcache = doneName;
      						elem.sizset = i;
      					}
      
      					if ( typeof cur !== "string" ) {
      						if ( elem === cur ) {
      							match = true;
      							break;
      						}
      
      					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
      						match = elem;
      						break;
      					}
      				}
      
      				elem = elem[dir];
      			}
      
      			checkSet[i] = match;
      		}
      	}
      }
      
      if ( document.documentElement.contains ) {
      	Sizzle.contains = function( a, b ) {
      		return a !== b && (a.contains ? a.contains(b) : true);
      	};
      
      } else if ( document.documentElement.compareDocumentPosition ) {
      	Sizzle.contains = function( a, b ) {
      		return !!(a.compareDocumentPosition(b) & 16);
      	};
      
      } else {
      	Sizzle.contains = function() {
      		return false;
      	};
      }
      
      Sizzle.isXML = function( elem ) {
      	// documentElement is verified for cases where it doesn't yet exist
      	// (such as loading iframes in IE - #4833) 
      	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
      
      	return documentElement ? documentElement.nodeName !== "HTML" : false;
      };
      
      var posProcess = function( selector, context ) {
      	var match,
      		tmpSet = [],
      		later = "",
      		root = context.nodeType ? [context] : context;
      
      	// Position selectors must be done after the filter
      	// And so must :not(positional) so we move all PSEUDOs to the end
      	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
      		later += match[0];
      		selector = selector.replace( Expr.match.PSEUDO, "" );
      	}
      
      	selector = Expr.relative[selector] ? selector + "*" : selector;
      
      	for ( var i = 0, l = root.length; i < l; i++ ) {
      		Sizzle( selector, root[i], tmpSet );
      	}
      
      	return Sizzle.filter( later, tmpSet );
      };
      
      // EXPOSE
      jQuery.find = Sizzle;
      jQuery.expr = Sizzle.selectors;
      jQuery.expr[":"] = jQuery.expr.filters;
      jQuery.unique = Sizzle.uniqueSort;
      jQuery.text = Sizzle.getText;
      jQuery.isXMLDoc = Sizzle.isXML;
      jQuery.contains = Sizzle.contains;
      
      
      })();
      
      
      var runtil = /Until$/,
      	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
      	// Note: This RegExp should be improved, or likely pulled from Sizzle
      	rmultiselector = /,/,
      	isSimple = /^.[^:#\[\.,]*$/,
      	slice = Array.prototype.slice,
      	POS = jQuery.expr.match.POS,
      	// methods guaranteed to produce a unique set when starting from a unique set
      	guaranteedUnique = {
      		children: true,
      		contents: true,
      		next: true,
      		prev: true
      	};
      
      jQuery.fn.extend({
      	find: function( selector ) {
      		var self = this,
      			i, l;
      
      		if ( typeof selector !== "string" ) {
      			return jQuery( selector ).filter(function() {
      				for ( i = 0, l = self.length; i < l; i++ ) {
      					if ( jQuery.contains( self[ i ], this ) ) {
      						return true;
      					}
      				}
      			});
      		}
      
      		var ret = this.pushStack( "", "find", selector ),
      			length, n, r;
      
      		for ( i = 0, l = this.length; i < l; i++ ) {
      			length = ret.length;
      			jQuery.find( selector, this[i], ret );
      
      			if ( i > 0 ) {
      				// Make sure that the results are unique
      				for ( n = length; n < ret.length; n++ ) {
      					for ( r = 0; r < length; r++ ) {
      						if ( ret[r] === ret[n] ) {
      							ret.splice(n--, 1);
      							break;
      						}
      					}
      				}
      			}
      		}
      
      		return ret;
      	},
      
      	has: function( target ) {
      		var targets = jQuery( target );
      		return this.filter(function() {
      			for ( var i = 0, l = targets.length; i < l; i++ ) {
      				if ( jQuery.contains( this, targets[i] ) ) {
      					return true;
      				}
      			}
      		});
      	},
      
      	not: function( selector ) {
      		return this.pushStack( winnow(this, selector, false), "not", selector);
      	},
      
      	filter: function( selector ) {
      		return this.pushStack( winnow(this, selector, true), "filter", selector );
      	},
      
      	is: function( selector ) {
      		return !!selector && ( typeof selector === "string" ?
      			jQuery.filter( selector, this ).length > 0 :
      			this.filter( selector ).length > 0 );
      	},
      
      	closest: function( selectors, context ) {
      		var ret = [], i, l, cur = this[0];
      		
      		// Array
      		if ( jQuery.isArray( selectors ) ) {
      			var match, selector,
      				matches = {},
      				level = 1;
      
      			if ( cur && selectors.length ) {
      				for ( i = 0, l = selectors.length; i < l; i++ ) {
      					selector = selectors[i];
      
      					if ( !matches[ selector ] ) {
      						matches[ selector ] = POS.test( selector ) ?
      							jQuery( selector, context || this.context ) :
      							selector;
      					}
      				}
      
      				while ( cur && cur.ownerDocument && cur !== context ) {
      					for ( selector in matches ) {
      						match = matches[ selector ];
      
      						if ( match.jquery ? match.index( cur ) > -1 : jQuery( cur ).is( match ) ) {
      							ret.push({ selector: selector, elem: cur, level: level });
      						}
      					}
      
      					cur = cur.parentNode;
      					level++;
      				}
      			}
      
      			return ret;
      		}
      
      		// String
      		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
      				jQuery( selectors, context || this.context ) :
      				0;
      
      		for ( i = 0, l = this.length; i < l; i++ ) {
      			cur = this[i];
      
      			while ( cur ) {
      				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
      					ret.push( cur );
      					break;
      
      				} else {
      					cur = cur.parentNode;
      					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
      						break;
      					}
      				}
      			}
      		}
      
      		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;
      
      		return this.pushStack( ret, "closest", selectors );
      	},
      
      	// Determine the position of an element within
      	// the matched set of elements
      	index: function( elem ) {
      		if ( !elem || typeof elem === "string" ) {
      			return jQuery.inArray( this[0],
      				// If it receives a string, the selector is used
      				// If it receives nothing, the siblings are used
      				elem ? jQuery( elem ) : this.parent().children() );
      		}
      		// Locate the position of the desired element
      		return jQuery.inArray(
      			// If it receives a jQuery object, the first element is used
      			elem.jquery ? elem[0] : elem, this );
      	},
      
      	add: function( selector, context ) {
      		var set = typeof selector === "string" ?
      				jQuery( selector, context ) :
      				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
      			all = jQuery.merge( this.get(), set );
      
      		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
      			all :
      			jQuery.unique( all ) );
      	},
      
      	andSelf: function() {
      		return this.add( this.prevObject );
      	}
      });
      
      // A painfully simple check to see if an element is disconnected
      // from a document (should be improved, where feasible).
      function isDisconnected( node ) {
      	return !node || !node.parentNode || node.parentNode.nodeType === 11;
      }
      
      jQuery.each({
      	parent: function( elem ) {
      		var parent = elem.parentNode;
      		return parent && parent.nodeType !== 11 ? parent : null;
      	},
      	parents: function( elem ) {
      		return jQuery.dir( elem, "parentNode" );
      	},
      	parentsUntil: function( elem, i, until ) {
      		return jQuery.dir( elem, "parentNode", until );
      	},
      	next: function( elem ) {
      		return jQuery.nth( elem, 2, "nextSibling" );
      	},
      	prev: function( elem ) {
      		return jQuery.nth( elem, 2, "previousSibling" );
      	},
      	nextAll: function( elem ) {
      		return jQuery.dir( elem, "nextSibling" );
      	},
      	prevAll: function( elem ) {
      		return jQuery.dir( elem, "previousSibling" );
      	},
      	nextUntil: function( elem, i, until ) {
      		return jQuery.dir( elem, "nextSibling", until );
      	},
      	prevUntil: function( elem, i, until ) {
      		return jQuery.dir( elem, "previousSibling", until );
      	},
      	siblings: function( elem ) {
      		return jQuery.sibling( elem.parentNode.firstChild, elem );
      	},
      	children: function( elem ) {
      		return jQuery.sibling( elem.firstChild );
      	},
      	contents: function( elem ) {
      		return jQuery.nodeName( elem, "iframe" ) ?
      			elem.contentDocument || elem.contentWindow.document :
      			jQuery.makeArray( elem.childNodes );
      	}
      }, function( name, fn ) {
      	jQuery.fn[ name ] = function( until, selector ) {
      		var ret = jQuery.map( this, fn, until ),
      			// The variable 'args' was introduced in
      			// https://github.com/jquery/jquery/commit/52a0238
      			// to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
      			// http://code.google.com/p/v8/issues/detail?id=1050
      			args = slice.call(arguments);
      
      		if ( !runtil.test( name ) ) {
      			selector = until;
      		}
      
      		if ( selector && typeof selector === "string" ) {
      			ret = jQuery.filter( selector, ret );
      		}
      
      		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
      
      		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
      			ret = ret.reverse();
      		}
      
      		return this.pushStack( ret, name, args.join(",") );
      	};
      });
      
      jQuery.extend({
      	filter: function( expr, elems, not ) {
      		if ( not ) {
      			expr = ":not(" + expr + ")";
      		}
      
      		return elems.length === 1 ?
      			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
      			jQuery.find.matches(expr, elems);
      	},
      
      	dir: function( elem, dir, until ) {
      		var matched = [],
      			cur = elem[ dir ];
      
      		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
      			if ( cur.nodeType === 1 ) {
      				matched.push( cur );
      			}
      			cur = cur[dir];
      		}
      		return matched;
      	},
      
      	nth: function( cur, result, dir, elem ) {
      		result = result || 1;
      		var num = 0;
      
      		for ( ; cur; cur = cur[dir] ) {
      			if ( cur.nodeType === 1 && ++num === result ) {
      				break;
      			}
      		}
      
      		return cur;
      	},
      
      	sibling: function( n, elem ) {
      		var r = [];
      
      		for ( ; n; n = n.nextSibling ) {
      			if ( n.nodeType === 1 && n !== elem ) {
      				r.push( n );
      			}
      		}
      
      		return r;
      	}
      });
      
      // Implement the identical functionality for filter and not
      function winnow( elements, qualifier, keep ) {
      
      	// Can't pass null or undefined to indexOf in Firefox 4
      	// Set to 0 to skip string check
      	qualifier = qualifier || 0;
      
      	if ( jQuery.isFunction( qualifier ) ) {
      		return jQuery.grep(elements, function( elem, i ) {
      			var retVal = !!qualifier.call( elem, i, elem );
      			return retVal === keep;
      		});
      
      	} else if ( qualifier.nodeType ) {
      		return jQuery.grep(elements, function( elem, i ) {
      			return (elem === qualifier) === keep;
      		});
      
      	} else if ( typeof qualifier === "string" ) {
      		var filtered = jQuery.grep(elements, function( elem ) {
      			return elem.nodeType === 1;
      		});
      
      		if ( isSimple.test( qualifier ) ) {
      			return jQuery.filter(qualifier, filtered, !keep);
      		} else {
      			qualifier = jQuery.filter( qualifier, filtered );
      		}
      	}
      
      	return jQuery.grep(elements, function( elem, i ) {
      		return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
      	});
      }
      
      
      
      
      var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
      	rleadingWhitespace = /^\s+/,
      	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
      	rtagName = /<([\w:]+)/,
      	rtbody = /<tbody/i,
      	rhtml = /<|&#?\w+;/,
      	rnocache = /<(?:script|object|embed|option|style)/i,
      	// checked="checked" or checked
      	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      	rscriptType = /\/(java|ecma)script/i,
      	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
      	wrapMap = {
      		option: [ 1, "<select multiple='multiple'>", "</select>" ],
      		legend: [ 1, "<fieldset>", "</fieldset>" ],
      		thead: [ 1, "<table>", "</table>" ],
      		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
      		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
      		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
      		area: [ 1, "<map>", "</map>" ],
      		_default: [ 0, "", "" ]
      	};
      
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      
      // IE can't serialize <link> and <script> tags normally
      if ( !jQuery.support.htmlSerialize ) {
      	wrapMap._default = [ 1, "div<div>", "</div>" ];
      }
      
      jQuery.fn.extend({
      	text: function( text ) {
      		if ( jQuery.isFunction(text) ) {
      			return this.each(function(i) {
      				var self = jQuery( this );
      
      				self.text( text.call(this, i, self.text()) );
      			});
      		}
      
      		if ( typeof text !== "object" && text !== undefined ) {
      			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
      		}
      
      		return jQuery.text( this );
      	},
      
      	wrapAll: function( html ) {
      		if ( jQuery.isFunction( html ) ) {
      			return this.each(function(i) {
      				jQuery(this).wrapAll( html.call(this, i) );
      			});
      		}
      
      		if ( this[0] ) {
      			// The elements to wrap the target around
      			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
      
      			if ( this[0].parentNode ) {
      				wrap.insertBefore( this[0] );
      			}
      
      			wrap.map(function() {
      				var elem = this;
      
      				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
      					elem = elem.firstChild;
      				}
      
      				return elem;
      			}).append( this );
      		}
      
      		return this;
      	},
      
      	wrapInner: function( html ) {
      		if ( jQuery.isFunction( html ) ) {
      			return this.each(function(i) {
      				jQuery(this).wrapInner( html.call(this, i) );
      			});
      		}
      
      		return this.each(function() {
      			var self = jQuery( this ),
      				contents = self.contents();
      
      			if ( contents.length ) {
      				contents.wrapAll( html );
      
      			} else {
      				self.append( html );
      			}
      		});
      	},
      
      	wrap: function( html ) {
      		return this.each(function() {
      			jQuery( this ).wrapAll( html );
      		});
      	},
      
      	unwrap: function() {
      		return this.parent().each(function() {
      			if ( !jQuery.nodeName( this, "body" ) ) {
      				jQuery( this ).replaceWith( this.childNodes );
      			}
      		}).end();
      	},
      
      	append: function() {
      		return this.domManip(arguments, true, function( elem ) {
      			if ( this.nodeType === 1 ) {
      				this.appendChild( elem );
      			}
      		});
      	},
      
      	prepend: function() {
      		return this.domManip(arguments, true, function( elem ) {
      			if ( this.nodeType === 1 ) {
      				this.insertBefore( elem, this.firstChild );
      			}
      		});
      	},
      
      	before: function() {
      		if ( this[0] && this[0].parentNode ) {
      			return this.domManip(arguments, false, function( elem ) {
      				this.parentNode.insertBefore( elem, this );
      			});
      		} else if ( arguments.length ) {
      			var set = jQuery(arguments[0]);
      			set.push.apply( set, this.toArray() );
      			return this.pushStack( set, "before", arguments );
      		}
      	},
      
      	after: function() {
      		if ( this[0] && this[0].parentNode ) {
      			return this.domManip(arguments, false, function( elem ) {
      				this.parentNode.insertBefore( elem, this.nextSibling );
      			});
      		} else if ( arguments.length ) {
      			var set = this.pushStack( this, "after", arguments );
      			set.push.apply( set, jQuery(arguments[0]).toArray() );
      			return set;
      		}
      	},
      
      	// keepData is for internal use only--do not document
      	remove: function( selector, keepData ) {
      		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
      			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
      				if ( !keepData && elem.nodeType === 1 ) {
      					jQuery.cleanData( elem.getElementsByTagName("*") );
      					jQuery.cleanData( [ elem ] );
      				}
      
      				if ( elem.parentNode ) {
      					elem.parentNode.removeChild( elem );
      				}
      			}
      		}
      
      		return this;
      	},
      
      	empty: function() {
      		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
      			// Remove element nodes and prevent memory leaks
      			if ( elem.nodeType === 1 ) {
      				jQuery.cleanData( elem.getElementsByTagName("*") );
      			}
      
      			// Remove any remaining nodes
      			while ( elem.firstChild ) {
      				elem.removeChild( elem.firstChild );
      			}
      		}
      
      		return this;
      	},
      
      	clone: function( dataAndEvents, deepDataAndEvents ) {
      		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      
      		return this.map( function () {
      			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
      		});
      	},
      
      	html: function( value ) {
      		if ( value === undefined ) {
      			return this[0] && this[0].nodeType === 1 ?
      				this[0].innerHTML.replace(rinlinejQuery, "") :
      				null;
      
      		// See if we can take a shortcut and just use innerHTML
      		} else if ( typeof value === "string" && !rnocache.test( value ) &&
      			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
      			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {
      
      			value = value.replace(rxhtmlTag, "<$1></$2>");
      
      			try {
      				for ( var i = 0, l = this.length; i < l; i++ ) {
      					// Remove element nodes and prevent memory leaks
      					if ( this[i].nodeType === 1 ) {
      						jQuery.cleanData( this[i].getElementsByTagName("*") );
      						this[i].innerHTML = value;
      					}
      				}
      
      			// If using innerHTML throws an exception, use the fallback method
      			} catch(e) {
      				this.empty().append( value );
      			}
      
      		} else if ( jQuery.isFunction( value ) ) {
      			this.each(function(i){
      				var self = jQuery( this );
      
      				self.html( value.call(this, i, self.html()) );
      			});
      
      		} else {
      			this.empty().append( value );
      		}
      
      		return this;
      	},
      
      	replaceWith: function( value ) {
      		if ( this[0] && this[0].parentNode ) {
      			// Make sure that the elements are removed from the DOM before they are inserted
      			// this can help fix replacing a parent with child elements
      			if ( jQuery.isFunction( value ) ) {
      				return this.each(function(i) {
      					var self = jQuery(this), old = self.html();
      					self.replaceWith( value.call( this, i, old ) );
      				});
      			}
      
      			if ( typeof value !== "string" ) {
      				value = jQuery( value ).detach();
      			}
      
      			return this.each(function() {
      				var next = this.nextSibling,
      					parent = this.parentNode;
      
      				jQuery( this ).remove();
      
      				if ( next ) {
      					jQuery(next).before( value );
      				} else {
      					jQuery(parent).append( value );
      				}
      			});
      		} else {
      			return this.length ?
      				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
      				this;
      		}
      	},
      
      	detach: function( selector ) {
      		return this.remove( selector, true );
      	},
      
      	domManip: function( args, table, callback ) {
      		var results, first, fragment, parent,
      			value = args[0],
      			scripts = [];
      
      		// We can't cloneNode fragments that contain checked, in WebKit
      		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
      			return this.each(function() {
      				jQuery(this).domManip( args, table, callback, true );
      			});
      		}
      
      		if ( jQuery.isFunction(value) ) {
      			return this.each(function(i) {
      				var self = jQuery(this);
      				args[0] = value.call(this, i, table ? self.html() : undefined);
      				self.domManip( args, table, callback );
      			});
      		}
      
      		if ( this[0] ) {
      			parent = value && value.parentNode;
      
      			// If we're in a fragment, just use that instead of building a new one
      			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
      				results = { fragment: parent };
      
      			} else {
      				results = jQuery.buildFragment( args, this, scripts );
      			}
      
      			fragment = results.fragment;
      
      			if ( fragment.childNodes.length === 1 ) {
      				first = fragment = fragment.firstChild;
      			} else {
      				first = fragment.firstChild;
      			}
      
      			if ( first ) {
      				table = table && jQuery.nodeName( first, "tr" );
      
      				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
      					callback.call(
      						table ?
      							root(this[i], first) :
      							this[i],
      						// Make sure that we do not leak memory by inadvertently discarding
      						// the original fragment (which might have attached data) instead of
      						// using it; in addition, use the original fragment object for the last
      						// item instead of first because it can end up being emptied incorrectly
      						// in certain situations (Bug #8070).
      						// Fragments from the fragment cache must always be cloned and never used
      						// in place.
      						results.cacheable || (l > 1 && i < lastIndex) ?
      							jQuery.clone( fragment, true, true ) :
      							fragment
      					);
      				}
      			}
      
      			if ( scripts.length ) {
      				jQuery.each( scripts, evalScript );
      			}
      		}
      
      		return this;
      	}
      });
      
      function root( elem, cur ) {
      	return jQuery.nodeName(elem, "table") ?
      		(elem.getElementsByTagName("tbody")[0] ||
      		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
      		elem;
      }
      
      function cloneCopyEvent( src, dest ) {
      
      	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
      		return;
      	}
      
      	var internalKey = jQuery.expando,
      		oldData = jQuery.data( src ),
      		curData = jQuery.data( dest, oldData );
      
      	// Switch to use the internal data object, if it exists, for the next
      	// stage of data copying
      	if ( (oldData = oldData[ internalKey ]) ) {
      		var events = oldData.events;
      				curData = curData[ internalKey ] = jQuery.extend({}, oldData);
      
      		if ( events ) {
      			delete curData.handle;
      			curData.events = {};
      
      			for ( var type in events ) {
      				for ( var i = 0, l = events[ type ].length; i < l; i++ ) {
      					jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
      				}
      			}
      		}
      	}
      }
      
      function cloneFixAttributes( src, dest ) {
      	var nodeName;
      
      	// We do not need to do anything for non-Elements
      	if ( dest.nodeType !== 1 ) {
      		return;
      	}
      
      	// clearAttributes removes the attributes, which we don't want,
      	// but also removes the attachEvent events, which we *do* want
      	if ( dest.clearAttributes ) {
      		dest.clearAttributes();
      	}
      
      	// mergeAttributes, in contrast, only merges back on the
      	// original attributes, not the events
      	if ( dest.mergeAttributes ) {
      		dest.mergeAttributes( src );
      	}
      
      	nodeName = dest.nodeName.toLowerCase();
      
      	// IE6-8 fail to clone children inside object elements that use
      	// the proprietary classid attribute value (rather than the type
      	// attribute) to identify the type of content to display
      	if ( nodeName === "object" ) {
      		dest.outerHTML = src.outerHTML;
      
      	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
      		// IE6-8 fails to persist the checked state of a cloned checkbox
      		// or radio button. Worse, IE6-7 fail to give the cloned element
      		// a checked appearance if the defaultChecked value isn't also set
      		if ( src.checked ) {
      			dest.defaultChecked = dest.checked = src.checked;
      		}
      
      		// IE6-7 get confused and end up setting the value of a cloned
      		// checkbox/radio button to an empty string instead of "on"
      		if ( dest.value !== src.value ) {
      			dest.value = src.value;
      		}
      
      	// IE6-8 fails to return the selected option to the default selected
      	// state when cloning options
      	} else if ( nodeName === "option" ) {
      		dest.selected = src.defaultSelected;
      
      	// IE6-8 fails to set the defaultValue to the correct value when
      	// cloning other types of input fields
      	} else if ( nodeName === "input" || nodeName === "textarea" ) {
      		dest.defaultValue = src.defaultValue;
      	}
      
      	// Event data gets referenced instead of copied if the expando
      	// gets copied too
      	dest.removeAttribute( jQuery.expando );
      }
      
      jQuery.buildFragment = function( args, nodes, scripts ) {
      	var fragment, cacheable, cacheresults,
      		doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);
      
      	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
      	// Cloning options loses the selected state, so don't cache them
      	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
      	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
      	if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
      		args[0].charAt(0) === "<" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {
      
      		cacheable = true;
      
      		cacheresults = jQuery.fragments[ args[0] ];
      		if ( cacheresults && cacheresults !== 1 ) {
      			fragment = cacheresults;
      		}
      	}
      
      	if ( !fragment ) {
      		fragment = doc.createDocumentFragment();
      		jQuery.clean( args, doc, fragment, scripts );
      	}
      
      	if ( cacheable ) {
      		jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
      	}
      
      	return { fragment: fragment, cacheable: cacheable };
      };
      
      jQuery.fragments = {};
      
      jQuery.each({
      	appendTo: "append",
      	prependTo: "prepend",
      	insertBefore: "before",
      	insertAfter: "after",
      	replaceAll: "replaceWith"
      }, function( name, original ) {
      	jQuery.fn[ name ] = function( selector ) {
      		var ret = [],
      			insert = jQuery( selector ),
      			parent = this.length === 1 && this[0].parentNode;
      
      		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
      			insert[ original ]( this[0] );
      			return this;
      
      		} else {
      			for ( var i = 0, l = insert.length; i < l; i++ ) {
      				var elems = (i > 0 ? this.clone(true) : this).get();
      				jQuery( insert[i] )[ original ]( elems );
      				ret = ret.concat( elems );
      			}
      
      			return this.pushStack( ret, name, insert.selector );
      		}
      	};
      });
      
      function getAll( elem ) {
      	if ( "getElementsByTagName" in elem ) {
      		return elem.getElementsByTagName( "*" );
      
      	} else if ( "querySelectorAll" in elem ) {
      		return elem.querySelectorAll( "*" );
      
      	} else {
      		return [];
      	}
      }
      
      // Used in clean, fixes the defaultChecked property
      function fixDefaultChecked( elem ) {
      	if ( elem.type === "checkbox" || elem.type === "radio" ) {
      		elem.defaultChecked = elem.checked;
      	}
      }
      // Finds all inputs and passes them to fixDefaultChecked
      function findInputs( elem ) {
      	if ( jQuery.nodeName( elem, "input" ) ) {
      		fixDefaultChecked( elem );
      	} else if ( elem.getElementsByTagName ) {
      		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
      	}
      }
      
      jQuery.extend({
      	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
      		var clone = elem.cloneNode(true),
      				srcElements,
      				destElements,
      				i;
      
      		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
      				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
      			// IE copies events bound via attachEvent when using cloneNode.
      			// Calling detachEvent on the clone will also remove the events
      			// from the original. In order to get around this, we use some
      			// proprietary methods to clear the events. Thanks to MooTools
      			// guys for this hotness.
      
      			cloneFixAttributes( elem, clone );
      
      			// Using Sizzle here is crazy slow, so we use getElementsByTagName
      			// instead
      			srcElements = getAll( elem );
      			destElements = getAll( clone );
      
      			// Weird iteration because IE will replace the length property
      			// with an element if you are cloning the body and one of the
      			// elements on the page has a name or id of "length"
      			for ( i = 0; srcElements[i]; ++i ) {
      				cloneFixAttributes( srcElements[i], destElements[i] );
      			}
      		}
      
      		// Copy the events from the original to the clone
      		if ( dataAndEvents ) {
      			cloneCopyEvent( elem, clone );
      
      			if ( deepDataAndEvents ) {
      				srcElements = getAll( elem );
      				destElements = getAll( clone );
      
      				for ( i = 0; srcElements[i]; ++i ) {
      					cloneCopyEvent( srcElements[i], destElements[i] );
      				}
      			}
      		}
      
      		// Return the cloned set
      		return clone;
      	},
      
      	clean: function( elems, context, fragment, scripts ) {
      		var checkScriptType;
      
      		context = context || document;
      
      		// !context.createElement fails in IE with an error but returns typeof 'object'
      		if ( typeof context.createElement === "undefined" ) {
      			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
      		}
      
      		var ret = [], j;
      
      		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      			if ( typeof elem === "number" ) {
      				elem += "";
      			}
      
      			if ( !elem ) {
      				continue;
      			}
      
      			// Convert html string into DOM nodes
      			if ( typeof elem === "string" ) {
      				if ( !rhtml.test( elem ) ) {
      					elem = context.createTextNode( elem );
      				} else {
      					// Fix "XHTML"-style tags in all browsers
      					elem = elem.replace(rxhtmlTag, "<$1></$2>");
      
      					// Trim whitespace, otherwise indexOf won't work as expected
      					var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
      						wrap = wrapMap[ tag ] || wrapMap._default,
      						depth = wrap[0],
      						div = context.createElement("div");
      
      					// Go to html and back, then peel off extra wrappers
      					div.innerHTML = wrap[1] + elem + wrap[2];
      
      					// Move to the right depth
      					while ( depth-- ) {
      						div = div.lastChild;
      					}
      
      					// Remove IE's autoinserted <tbody> from table fragments
      					if ( !jQuery.support.tbody ) {
      
      						// String was a <table>, *may* have spurious <tbody>
      						var hasBody = rtbody.test(elem),
      							tbody = tag === "table" && !hasBody ?
      								div.firstChild && div.firstChild.childNodes :
      
      								// String was a bare <thead> or <tfoot>
      								wrap[1] === "<table>" && !hasBody ?
      									div.childNodes :
      									[];
      
      						for ( j = tbody.length - 1; j >= 0 ; --j ) {
      							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
      								tbody[ j ].parentNode.removeChild( tbody[ j ] );
      							}
      						}
      					}
      
      					// IE completely kills leading whitespace when innerHTML is used
      					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
      						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
      					}
      
      					elem = div.childNodes;
      				}
      			}
      
      			// Resets defaultChecked for any radios and checkboxes
      			// about to be appended to the DOM in IE 6/7 (#8060)
      			var len;
      			if ( !jQuery.support.appendChecked ) {
      				if ( elem[0] && typeof (len = elem.length) === "number" ) {
      					for ( j = 0; j < len; j++ ) {
      						findInputs( elem[j] );
      					}
      				} else {
      					findInputs( elem );
      				}
      			}
      
      			if ( elem.nodeType ) {
      				ret.push( elem );
      			} else {
      				ret = jQuery.merge( ret, elem );
      			}
      		}
      
      		if ( fragment ) {
      			checkScriptType = function( elem ) {
      				return !elem.type || rscriptType.test( elem.type );
      			};
      			for ( i = 0; ret[i]; i++ ) {
      				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
      					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );
      
      				} else {
      					if ( ret[i].nodeType === 1 ) {
      						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );
      
      						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
      					}
      					fragment.appendChild( ret[i] );
      				}
      			}
      		}
      
      		return ret;
      	},
      
      	cleanData: function( elems ) {
      		var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
      			deleteExpando = jQuery.support.deleteExpando;
      
      		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
      			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
      				continue;
      			}
      
      			id = elem[ jQuery.expando ];
      
      			if ( id ) {
      				data = cache[ id ] && cache[ id ][ internalKey ];
      
      				if ( data && data.events ) {
      					for ( var type in data.events ) {
      						if ( special[ type ] ) {
      							jQuery.event.remove( elem, type );
      
      						// This is a shortcut to avoid jQuery.event.remove's overhead
      						} else {
      							jQuery.removeEvent( elem, type, data.handle );
      						}
      					}
      
      					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
      					if ( data.handle ) {
      						data.handle.elem = null;
      					}
      				}
      
      				if ( deleteExpando ) {
      					delete elem[ jQuery.expando ];
      
      				} else if ( elem.removeAttribute ) {
      					elem.removeAttribute( jQuery.expando );
      				}
      
      				delete cache[ id ];
      			}
      		}
      	}
      });
      
      function evalScript( i, elem ) {
      	if ( elem.src ) {
      		jQuery.ajax({
      			url: elem.src,
      			async: false,
      			dataType: "script"
      		});
      	} else {
      		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
      	}
      
      	if ( elem.parentNode ) {
      		elem.parentNode.removeChild( elem );
      	}
      }
      
      
      
      
      var ralpha = /alpha\([^)]*\)/i,
      	ropacity = /opacity=([^)]*)/,
      	rdashAlpha = /-([a-z])/ig,
      	// fixed for IE9, see #8346
      	rupper = /([A-Z]|^ms)/g,
      	rnumpx = /^-?\d+(?:px)?$/i,
      	rnum = /^-?\d/,
      	rrelNum = /^[+\-]=/,
      	rrelNumFilter = /[^+\-\.\de]+/g,
      
      	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
      	cssWidth = [ "Left", "Right" ],
      	cssHeight = [ "Top", "Bottom" ],
      	curCSS,
      
      	getComputedStyle,
      	currentStyle,
      
      	fcamelCase = function( all, letter ) {
      		return letter.toUpperCase();
      	};
      
      jQuery.fn.css = function( name, value ) {
      	// Setting 'undefined' is a no-op
      	if ( arguments.length === 2 && value === undefined ) {
      		return this;
      	}
      
      	return jQuery.access( this, name, value, true, function( elem, name, value ) {
      		return value !== undefined ?
      			jQuery.style( elem, name, value ) :
      			jQuery.css( elem, name );
      	});
      };
      
      jQuery.extend({
      	// Add in style property hooks for overriding the default
      	// behavior of getting and setting a style property
      	cssHooks: {
      		opacity: {
      			get: function( elem, computed ) {
      				if ( computed ) {
      					// We should always get a number back from opacity
      					var ret = curCSS( elem, "opacity", "opacity" );
      					return ret === "" ? "1" : ret;
      
      				} else {
      					return elem.style.opacity;
      				}
      			}
      		}
      	},
      
      	// Exclude the following css properties to add px
      	cssNumber: {
      		"zIndex": true,
      		"fontWeight": true,
      		"opacity": true,
      		"zoom": true,
      		"lineHeight": true,
      		"widows": true,
      		"orphans": true
      	},
      
      	// Add in properties whose names you wish to fix before
      	// setting or getting the value
      	cssProps: {
      		// normalize float css property
      		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
      	},
      
      	// Get and set the style property on a DOM Node
      	style: function( elem, name, value, extra ) {
      		// Don't set styles on text and comment nodes
      		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      			return;
      		}
      
      		// Make sure that we're working with the right name
      		var ret, type, origName = jQuery.camelCase( name ),
      			style = elem.style, hooks = jQuery.cssHooks[ origName ];
      
      		name = jQuery.cssProps[ origName ] || origName;
      
      		// Check if we're setting a value
      		if ( value !== undefined ) {
      			type = typeof value;
      
      			// Make sure that NaN and null values aren't set. See: #7116
      			if ( type === "number" && isNaN( value ) || value == null ) {
      				return;
      			}
      
      			// convert relative number strings (+= or -=) to relative numbers. #7345
      			if ( type === "string" && rrelNum.test( value ) ) {
      				value = +value.replace( rrelNumFilter, "" ) + parseFloat( jQuery.css( elem, name ) );
      			}
      
      			// If a number was passed in, add 'px' to the (except for certain CSS properties)
      			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
      				value += "px";
      			}
      
      			// If a hook was provided, use that value, otherwise just set the specified value
      			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
      				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
      				// Fixes bug #5509
      				try {
      					style[ name ] = value;
      				} catch(e) {}
      			}
      
      		} else {
      			// If a hook was provided get the non-computed value from there
      			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
      				return ret;
      			}
      
      			// Otherwise just get the value from the style object
      			return style[ name ];
      		}
      	},
      
      	css: function( elem, name, extra ) {
      		var ret, hooks;
      
      		// Make sure that we're working with the right name
      		name = jQuery.camelCase( name );
      		hooks = jQuery.cssHooks[ name ];
      		name = jQuery.cssProps[ name ] || name;
      
      		// cssFloat needs a special treatment
      		if ( name === "cssFloat" ) {
      			name = "float";
      		}
      
      		// If a hook was provided get the computed value from there
      		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
      			return ret;
      
      		// Otherwise, if a way to get the computed value exists, use that
      		} else if ( curCSS ) {
      			return curCSS( elem, name );
      		}
      	},
      
      	// A method for quickly swapping in/out CSS properties to get correct calculations
      	swap: function( elem, options, callback ) {
      		var old = {};
      
      		// Remember the old values, and insert the new ones
      		for ( var name in options ) {
      			old[ name ] = elem.style[ name ];
      			elem.style[ name ] = options[ name ];
      		}
      
      		callback.call( elem );
      
      		// Revert the old values
      		for ( name in options ) {
      			elem.style[ name ] = old[ name ];
      		}
      	},
      
      	camelCase: function( string ) {
      		return string.replace( rdashAlpha, fcamelCase );
      	}
      });
      
      // DEPRECATED, Use jQuery.css() instead
      jQuery.curCSS = jQuery.css;
      
      jQuery.each(["height", "width"], function( i, name ) {
      	jQuery.cssHooks[ name ] = {
      		get: function( elem, computed, extra ) {
      			var val;
      
      			if ( computed ) {
      				if ( elem.offsetWidth !== 0 ) {
      					val = getWH( elem, name, extra );
      
      				} else {
      					jQuery.swap( elem, cssShow, function() {
      						val = getWH( elem, name, extra );
      					});
      				}
      
      				if ( val <= 0 ) {
      					val = curCSS( elem, name, name );
      
      					if ( val === "0px" && currentStyle ) {
      						val = currentStyle( elem, name, name );
      					}
      
      					if ( val != null ) {
      						// Should return "auto" instead of 0, use 0 for
      						// temporary backwards-compat
      						return val === "" || val === "auto" ? "0px" : val;
      					}
      				}
      
      				if ( val < 0 || val == null ) {
      					val = elem.style[ name ];
      
      					// Should return "auto" instead of 0, use 0 for
      					// temporary backwards-compat
      					return val === "" || val === "auto" ? "0px" : val;
      				}
      
      				return typeof val === "string" ? val : val + "px";
      			}
      		},
      
      		set: function( elem, value ) {
      			if ( rnumpx.test( value ) ) {
      				// ignore negative width and height values #1599
      				value = parseFloat(value);
      
      				if ( value >= 0 ) {
      					return value + "px";
      				}
      
      			} else {
      				return value;
      			}
      		}
      	};
      });
      
      if ( !jQuery.support.opacity ) {
      	jQuery.cssHooks.opacity = {
      		get: function( elem, computed ) {
      			// IE uses filters for opacity
      			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
      				( parseFloat( RegExp.$1 ) / 100 ) + "" :
      				computed ? "1" : "";
      		},
      
      		set: function( elem, value ) {
      			var style = elem.style,
      				currentStyle = elem.currentStyle;
      
      			// IE has trouble with opacity if it does not have layout
      			// Force it by setting the zoom level
      			style.zoom = 1;
      
      			// Set the alpha filter to set the opacity
      			var opacity = jQuery.isNaN( value ) ?
      				"" :
      				"alpha(opacity=" + value * 100 + ")",
      				filter = currentStyle && currentStyle.filter || style.filter || "";
      
      			style.filter = ralpha.test( filter ) ?
      				filter.replace( ralpha, opacity ) :
      				filter + " " + opacity;
      		}
      	};
      }
      
      jQuery(function() {
      	// This hook cannot be added until DOM ready because the support test
      	// for it is not run until after DOM ready
      	if ( !jQuery.support.reliableMarginRight ) {
      		jQuery.cssHooks.marginRight = {
      			get: function( elem, computed ) {
      				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
      				// Work around by temporarily setting element display to inline-block
      				var ret;
      				jQuery.swap( elem, { "display": "inline-block" }, function() {
      					if ( computed ) {
      						ret = curCSS( elem, "margin-right", "marginRight" );
      					} else {
      						ret = elem.style.marginRight;
      					}
      				});
      				return ret;
      			}
      		};
      	}
      });
      
      if ( document.defaultView && document.defaultView.getComputedStyle ) {
      	getComputedStyle = function( elem, name ) {
      		var ret, defaultView, computedStyle;
      
      		name = name.replace( rupper, "-$1" ).toLowerCase();
      
      		if ( !(defaultView = elem.ownerDocument.defaultView) ) {
      			return undefined;
      		}
      
      		if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
      			ret = computedStyle.getPropertyValue( name );
      			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
      				ret = jQuery.style( elem, name );
      			}
      		}
      
      		return ret;
      	};
      }
      
      if ( document.documentElement.currentStyle ) {
      	currentStyle = function( elem, name ) {
      		var left,
      			ret = elem.currentStyle && elem.currentStyle[ name ],
      			rsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],
      			style = elem.style;
      
      		// From the awesome hack by Dean Edwards
      		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
      
      		// If we're not dealing with a regular pixel number
      		// but a number that has a weird ending, we need to convert it to pixels
      		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
      			// Remember the original values
      			left = style.left;
      
      			// Put in the new values to get a computed value out
      			if ( rsLeft ) {
      				elem.runtimeStyle.left = elem.currentStyle.left;
      			}
      			style.left = name === "fontSize" ? "1em" : (ret || 0);
      			ret = style.pixelLeft + "px";
      
      			// Revert the changed values
      			style.left = left;
      			if ( rsLeft ) {
      				elem.runtimeStyle.left = rsLeft;
      			}
      		}
      
      		return ret === "" ? "auto" : ret;
      	};
      }
      
      curCSS = getComputedStyle || currentStyle;
      
      function getWH( elem, name, extra ) {
      	var which = name === "width" ? cssWidth : cssHeight,
      		val = name === "width" ? elem.offsetWidth : elem.offsetHeight;
      
      	if ( extra === "border" ) {
      		return val;
      	}
      
      	jQuery.each( which, function() {
      		if ( !extra ) {
      			val -= parseFloat(jQuery.css( elem, "padding" + this )) || 0;
      		}
      
      		if ( extra === "margin" ) {
      			val += parseFloat(jQuery.css( elem, "margin" + this )) || 0;
      
      		} else {
      			val -= parseFloat(jQuery.css( elem, "border" + this + "Width" )) || 0;
      		}
      	});
      
      	return val;
      }
      
      if ( jQuery.expr && jQuery.expr.filters ) {
      	jQuery.expr.filters.hidden = function( elem ) {
      		var width = elem.offsetWidth,
      			height = elem.offsetHeight;
      
      		return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
      	};
      
      	jQuery.expr.filters.visible = function( elem ) {
      		return !jQuery.expr.filters.hidden( elem );
      	};
      }
      
      
      
      
      var r20 = /%20/g,
      	rbracket = /\[\]$/,
      	rCRLF = /\r?\n/g,
      	rhash = /#.*$/,
      	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
      	rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
      	// #7653, #8125, #8152: local protocol detection
      	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/,
      	rnoContent = /^(?:GET|HEAD)$/,
      	rprotocol = /^\/\//,
      	rquery = /\?/,
      	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
      	rselectTextarea = /^(?:select|textarea)/i,
      	rspacesAjax = /\s+/,
      	rts = /([?&])_=[^&]*/,
      	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
      
      	// Keep a copy of the old load method
      	_load = jQuery.fn.load,
      
      	/* Prefilters
      	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
      	 * 2) These are called:
      	 *    - BEFORE asking for a transport
      	 *    - AFTER param serialization (s.data is a string if s.processData is true)
      	 * 3) key is the dataType
      	 * 4) the catchall symbol "*" can be used
      	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
      	 */
      	prefilters = {},
      
      	/* Transports bindings
      	 * 1) key is the dataType
      	 * 2) the catchall symbol "*" can be used
      	 * 3) selection will start with transport dataType and THEN go to "*" if needed
      	 */
      	transports = {},
      
      	// Document location
      	ajaxLocation,
      
      	// Document location segments
      	ajaxLocParts;
      
      // #8138, IE may throw an exception when accessing
      // a field from window.location if document.domain has been set
      try {
      	ajaxLocation = location.href;
      } catch( e ) {
      	// Use the href attribute of an A element
      	// since IE will modify it given document.location
      	ajaxLocation = document.createElement( "a" );
      	ajaxLocation.href = "";
      	ajaxLocation = ajaxLocation.href;
      }
      
      // Segment location into parts
      ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
      
      // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
      function addToPrefiltersOrTransports( structure ) {
      
      	// dataTypeExpression is optional and defaults to "*"
      	return function( dataTypeExpression, func ) {
      
      		if ( typeof dataTypeExpression !== "string" ) {
      			func = dataTypeExpression;
      			dataTypeExpression = "*";
      		}
      
      		if ( jQuery.isFunction( func ) ) {
      			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
      				i = 0,
      				length = dataTypes.length,
      				dataType,
      				list,
      				placeBefore;
      
      			// For each dataType in the dataTypeExpression
      			for(; i < length; i++ ) {
      				dataType = dataTypes[ i ];
      				// We control if we're asked to add before
      				// any existing element
      				placeBefore = /^\+/.test( dataType );
      				if ( placeBefore ) {
      					dataType = dataType.substr( 1 ) || "*";
      				}
      				list = structure[ dataType ] = structure[ dataType ] || [];
      				// then we add to the structure accordingly
      				list[ placeBefore ? "unshift" : "push" ]( func );
      			}
      		}
      	};
      }
      
      // Base inspection function for prefilters and transports
      function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
      		dataType /* internal */, inspected /* internal */ ) {
      
      	dataType = dataType || options.dataTypes[ 0 ];
      	inspected = inspected || {};
      
      	inspected[ dataType ] = true;
      
      	var list = structure[ dataType ],
      		i = 0,
      		length = list ? list.length : 0,
      		executeOnly = ( structure === prefilters ),
      		selection;
      
      	for(; i < length && ( executeOnly || !selection ); i++ ) {
      		selection = list[ i ]( options, originalOptions, jqXHR );
      		// If we got redirected to another dataType
      		// we try there if executing only and not done already
      		if ( typeof selection === "string" ) {
      			if ( !executeOnly || inspected[ selection ] ) {
      				selection = undefined;
      			} else {
      				options.dataTypes.unshift( selection );
      				selection = inspectPrefiltersOrTransports(
      						structure, options, originalOptions, jqXHR, selection, inspected );
      			}
      		}
      	}
      	// If we're only executing or nothing was selected
      	// we try the catchall dataType if not done already
      	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
      		selection = inspectPrefiltersOrTransports(
      				structure, options, originalOptions, jqXHR, "*", inspected );
      	}
      	// unnecessary when only executing (prefilters)
      	// but it'll be ignored by the caller in that case
      	return selection;
      }
      
      jQuery.fn.extend({
      	load: function( url, params, callback ) {
      		if ( typeof url !== "string" && _load ) {
      			return _load.apply( this, arguments );
      
      		// Don't do a request if no elements are being requested
      		} else if ( !this.length ) {
      			return this;
      		}
      
      		var off = url.indexOf( " " );
      		if ( off >= 0 ) {
      			var selector = url.slice( off, url.length );
      			url = url.slice( 0, off );
      		}
      
      		// Default to a GET request
      		var type = "GET";
      
      		// If the second parameter was provided
      		if ( params ) {
      			// If it's a function
      			if ( jQuery.isFunction( params ) ) {
      				// We assume that it's the callback
      				callback = params;
      				params = undefined;
      
      			// Otherwise, build a param string
      			} else if ( typeof params === "object" ) {
      				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
      				type = "POST";
      			}
      		}
      
      		var self = this;
      
      		// Request the remote document
      		jQuery.ajax({
      			url: url,
      			type: type,
      			dataType: "html",
      			data: params,
      			// Complete callback (responseText is used internally)
      			complete: function( jqXHR, status, responseText ) {
      				// Store the response as specified by the jqXHR object
      				responseText = jqXHR.responseText;
      				// If successful, inject the HTML into all the matched elements
      				if ( jqXHR.isResolved() ) {
      					// #4825: Get the actual response in case
      					// a dataFilter is present in ajaxSettings
      					jqXHR.done(function( r ) {
      						responseText = r;
      					});
      					// See if a selector was specified
      					self.html( selector ?
      						// Create a dummy div to hold the results
      						jQuery("<div>")
      							// inject the contents of the document in, removing the scripts
      							// to avoid any 'Permission Denied' errors in IE
      							.append(responseText.replace(rscript, ""))
      
      							// Locate the specified elements
      							.find(selector) :
      
      						// If not, just inject the full result
      						responseText );
      				}
      
      				if ( callback ) {
      					self.each( callback, [ responseText, status, jqXHR ] );
      				}
      			}
      		});
      
      		return this;
      	},
      
      	serialize: function() {
      		return jQuery.param( this.serializeArray() );
      	},
      
      	serializeArray: function() {
      		return this.map(function(){
      			return this.elements ? jQuery.makeArray( this.elements ) : this;
      		})
      		.filter(function(){
      			return this.name && !this.disabled &&
      				( this.checked || rselectTextarea.test( this.nodeName ) ||
      					rinput.test( this.type ) );
      		})
      		.map(function( i, elem ){
      			var val = jQuery( this ).val();
      
      			return val == null ?
      				null :
      				jQuery.isArray( val ) ?
      					jQuery.map( val, function( val, i ){
      						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
      					}) :
      					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
      		}).get();
      	}
      });
      
      // Attach a bunch of functions for handling common AJAX events
      jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
      	jQuery.fn[ o ] = function( f ){
      		return this.bind( o, f );
      	};
      });
      
      jQuery.each( [ "get", "post" ], function( i, method ) {
      	jQuery[ method ] = function( url, data, callback, type ) {
      		// shift arguments if data argument was omitted
      		if ( jQuery.isFunction( data ) ) {
      			type = type || callback;
      			callback = data;
      			data = undefined;
      		}
      
      		return jQuery.ajax({
      			type: method,
      			url: url,
      			data: data,
      			success: callback,
      			dataType: type
      		});
      	};
      });
      
      jQuery.extend({
      
      	getScript: function( url, callback ) {
      		return jQuery.get( url, undefined, callback, "script" );
      	},
      
      	getJSON: function( url, data, callback ) {
      		return jQuery.get( url, data, callback, "json" );
      	},
      
      	// Creates a full fledged settings object into target
      	// with both ajaxSettings and settings fields.
      	// If target is omitted, writes into ajaxSettings.
      	ajaxSetup: function ( target, settings ) {
      		if ( !settings ) {
      			// Only one parameter, we extend ajaxSettings
      			settings = target;
      			target = jQuery.extend( true, jQuery.ajaxSettings, settings );
      		} else {
      			// target was provided, we extend into it
      			jQuery.extend( true, target, jQuery.ajaxSettings, settings );
      		}
      		// Flatten fields we don't want deep extended
      		for( var field in { context: 1, url: 1 } ) {
      			if ( field in settings ) {
      				target[ field ] = settings[ field ];
      			} else if( field in jQuery.ajaxSettings ) {
      				target[ field ] = jQuery.ajaxSettings[ field ];
      			}
      		}
      		return target;
      	},
      
      	ajaxSettings: {
      		url: ajaxLocation,
      		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
      		global: true,
      		type: "GET",
      		contentType: "application/x-www-form-urlencoded",
      		processData: true,
      		async: true,
      		/*
      		timeout: 0,
      		data: null,
      		dataType: null,
      		username: null,
      		password: null,
      		cache: null,
      		traditional: false,
      		headers: {},
      		*/
      
      		accepts: {
      			xml: "application/xml, text/xml",
      			html: "text/html",
      			text: "text/plain",
      			json: "application/json, text/javascript",
      			"*": "*/*"
      		},
      
      		contents: {
      			xml: /xml/,
      			html: /html/,
      			json: /json/
      		},
      
      		responseFields: {
      			xml: "responseXML",
      			text: "responseText"
      		},
      
      		// List of data converters
      		// 1) key format is "source_type destination_type" (a single space in-between)
      		// 2) the catchall symbol "*" can be used for source_type
      		converters: {
      
      			// Convert anything to text
      			"* text": window.String,
      
      			// Text to html (true = no transformation)
      			"text html": true,
      
      			// Evaluate text as a json expression
      			"text json": jQuery.parseJSON,
      
      			// Parse text as xml
      			"text xml": jQuery.parseXML
      		}
      	},
      
      	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
      	ajaxTransport: addToPrefiltersOrTransports( transports ),
      
      	// Main method
      	ajax: function( url, options ) {
      
      		// If url is an object, simulate pre-1.5 signature
      		if ( typeof url === "object" ) {
      			options = url;
      			url = undefined;
      		}
      
      		// Force options to be an object
      		options = options || {};
      
      		var // Create the final options object
      			s = jQuery.ajaxSetup( {}, options ),
      			// Callbacks context
      			callbackContext = s.context || s,
      			// Context for global events
      			// It's the callbackContext if one was provided in the options
      			// and if it's a DOM node or a jQuery collection
      			globalEventContext = callbackContext !== s &&
      				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
      						jQuery( callbackContext ) : jQuery.event,
      			// Deferreds
      			deferred = jQuery.Deferred(),
      			completeDeferred = jQuery._Deferred(),
      			// Status-dependent callbacks
      			statusCode = s.statusCode || {},
      			// ifModified key
      			ifModifiedKey,
      			// Headers (they are sent all at once)
      			requestHeaders = {},
      			requestHeadersNames = {},
      			// Response headers
      			responseHeadersString,
      			responseHeaders,
      			// transport
      			transport,
      			// timeout handle
      			timeoutTimer,
      			// Cross-domain detection vars
      			parts,
      			// The jqXHR state
      			state = 0,
      			// To know if global events are to be dispatched
      			fireGlobals,
      			// Loop variable
      			i,
      			// Fake xhr
      			jqXHR = {
      
      				readyState: 0,
      
      				// Caches the header
      				setRequestHeader: function( name, value ) {
      					if ( !state ) {
      						var lname = name.toLowerCase();
      						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
      						requestHeaders[ name ] = value;
      					}
      					return this;
      				},
      
      				// Raw string
      				getAllResponseHeaders: function() {
      					return state === 2 ? responseHeadersString : null;
      				},
      
      				// Builds headers hashtable if needed
      				getResponseHeader: function( key ) {
      					var match;
      					if ( state === 2 ) {
      						if ( !responseHeaders ) {
      							responseHeaders = {};
      							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
      								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
      							}
      						}
      						match = responseHeaders[ key.toLowerCase() ];
      					}
      					return match === undefined ? null : match;
      				},
      
      				// Overrides response content-type header
      				overrideMimeType: function( type ) {
      					if ( !state ) {
      						s.mimeType = type;
      					}
      					return this;
      				},
      
      				// Cancel the request
      				abort: function( statusText ) {
      					statusText = statusText || "abort";
      					if ( transport ) {
      						transport.abort( statusText );
      					}
      					done( 0, statusText );
      					return this;
      				}
      			};
      
      		// Callback for when everything is done
      		// It is defined here because jslint complains if it is declared
      		// at the end of the function (which would be more logical and readable)
      		function done( status, statusText, responses, headers ) {
      
      			// Called once
      			if ( state === 2 ) {
      				return;
      			}
      
      			// State is "done" now
      			state = 2;
      
      			// Clear timeout if it exists
      			if ( timeoutTimer ) {
      				clearTimeout( timeoutTimer );
      			}
      
      			// Dereference transport for early garbage collection
      			// (no matter how long the jqXHR object will be used)
      			transport = undefined;
      
      			// Cache response headers
      			responseHeadersString = headers || "";
      
      			// Set readyState
      			jqXHR.readyState = status ? 4 : 0;
      
      			var isSuccess,
      				success,
      				error,
      				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
      				lastModified,
      				etag;
      
      			// If successful, handle type chaining
      			if ( status >= 200 && status < 300 || status === 304 ) {
      
      				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      				if ( s.ifModified ) {
      
      					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
      						jQuery.lastModified[ ifModifiedKey ] = lastModified;
      					}
      					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
      						jQuery.etag[ ifModifiedKey ] = etag;
      					}
      				}
      
      				// If not modified
      				if ( status === 304 ) {
      
      					statusText = "notmodified";
      					isSuccess = true;
      
      				// If we have data
      				} else {
      
      					try {
      						success = ajaxConvert( s, response );
      						statusText = "success";
      						isSuccess = true;
      					} catch(e) {
      						// We have a parsererror
      						statusText = "parsererror";
      						error = e;
      					}
      				}
      			} else {
      				// We extract error from statusText
      				// then normalize statusText and status for non-aborts
      				error = statusText;
      				if( !statusText || status ) {
      					statusText = "error";
      					if ( status < 0 ) {
      						status = 0;
      					}
      				}
      			}
      
      			// Set data for the fake xhr object
      			jqXHR.status = status;
      			jqXHR.statusText = statusText;
      
      			// Success/Error
      			if ( isSuccess ) {
      				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      			} else {
      				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      			}
      
      			// Status-dependent callbacks
      			jqXHR.statusCode( statusCode );
      			statusCode = undefined;
      
      			if ( fireGlobals ) {
      				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
      						[ jqXHR, s, isSuccess ? success : error ] );
      			}
      
      			// Complete
      			completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );
      
      			if ( fireGlobals ) {
      				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s] );
      				// Handle the global AJAX counter
      				if ( !( --jQuery.active ) ) {
      					jQuery.event.trigger( "ajaxStop" );
      				}
      			}
      		}
      
      		// Attach deferreds
      		deferred.promise( jqXHR );
      		jqXHR.success = jqXHR.done;
      		jqXHR.error = jqXHR.fail;
      		jqXHR.complete = completeDeferred.done;
      
      		// Status-dependent callbacks
      		jqXHR.statusCode = function( map ) {
      			if ( map ) {
      				var tmp;
      				if ( state < 2 ) {
      					for( tmp in map ) {
      						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
      					}
      				} else {
      					tmp = map[ jqXHR.status ];
      					jqXHR.then( tmp, tmp );
      				}
      			}
      			return this;
      		};
      
      		// Remove hash character (#7531: and string promotion)
      		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
      		// We also use the url parameter if available
      		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
      
      		// Extract dataTypes list
      		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );
      
      		// Determine if a cross-domain request is in order
      		if ( s.crossDomain == null ) {
      			parts = rurl.exec( s.url.toLowerCase() );
      			s.crossDomain = !!( parts &&
      				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
      					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
      						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
      			);
      		}
      
      		// Convert data if not already a string
      		if ( s.data && s.processData && typeof s.data !== "string" ) {
      			s.data = jQuery.param( s.data, s.traditional );
      		}
      
      		// Apply prefilters
      		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
      
      		// If request was aborted inside a prefiler, stop there
      		if ( state === 2 ) {
      			return false;
      		}
      
      		// We can fire global events as of now if asked to
      		fireGlobals = s.global;
      
      		// Uppercase the type
      		s.type = s.type.toUpperCase();
      
      		// Determine if request has content
      		s.hasContent = !rnoContent.test( s.type );
      
      		// Watch for a new set of requests
      		if ( fireGlobals && jQuery.active++ === 0 ) {
      			jQuery.event.trigger( "ajaxStart" );
      		}
      
      		// More options handling for requests with no content
      		if ( !s.hasContent ) {
      
      			// If data is available, append data to url
      			if ( s.data ) {
      				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
      			}
      
      			// Get ifModifiedKey before adding the anti-cache parameter
      			ifModifiedKey = s.url;
      
      			// Add anti-cache in url if needed
      			if ( s.cache === false ) {
      
      				var ts = jQuery.now(),
      					// try replacing _= if it is there
      					ret = s.url.replace( rts, "$1_=" + ts );
      
      				// if nothing was replaced, add timestamp to the end
      				s.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
      			}
      		}
      
      		// Set the correct header, if data is being sent
      		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      			jqXHR.setRequestHeader( "Content-Type", s.contentType );
      		}
      
      		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      		if ( s.ifModified ) {
      			ifModifiedKey = ifModifiedKey || s.url;
      			if ( jQuery.lastModified[ ifModifiedKey ] ) {
      				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
      			}
      			if ( jQuery.etag[ ifModifiedKey ] ) {
      				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
      			}
      		}
      
      		// Set the Accepts header for the server, depending on the dataType
      		jqXHR.setRequestHeader(
      			"Accept",
      			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
      				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", */*; q=0.01" : "" ) :
      				s.accepts[ "*" ]
      		);
      
      		// Check for headers option
      		for ( i in s.headers ) {
      			jqXHR.setRequestHeader( i, s.headers[ i ] );
      		}
      
      		// Allow custom headers/mimetypes and early abort
      		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
      				// Abort if not done already
      				jqXHR.abort();
      				return false;
      
      		}
      
      		// Install callbacks on deferreds
      		for ( i in { success: 1, error: 1, complete: 1 } ) {
      			jqXHR[ i ]( s[ i ] );
      		}
      
      		// Get transport
      		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
      
      		// If no transport, we auto-abort
      		if ( !transport ) {
      			done( -1, "No Transport" );
      		} else {
      			jqXHR.readyState = 1;
      			// Send global event
      			if ( fireGlobals ) {
      				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      			}
      			// Timeout
      			if ( s.async && s.timeout > 0 ) {
      				timeoutTimer = setTimeout( function(){
      					jqXHR.abort( "timeout" );
      				}, s.timeout );
      			}
      
      			try {
      				state = 1;
      				transport.send( requestHeaders, done );
      			} catch (e) {
      				// Propagate exception as error if not done
      				if ( status < 2 ) {
      					done( -1, e );
      				// Simply rethrow otherwise
      				} else {
      					jQuery.error( e );
      				}
      			}
      		}
      
      		return jqXHR;
      	},
      
      	// Serialize an array of form elements or a set of
      	// key/values into a query string
      	param: function( a, traditional ) {
      		var s = [],
      			add = function( key, value ) {
      				// If value is a function, invoke it and return its value
      				value = jQuery.isFunction( value ) ? value() : value;
      				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
      			};
      
      		// Set traditional to true for jQuery <= 1.3.2 behavior.
      		if ( traditional === undefined ) {
      			traditional = jQuery.ajaxSettings.traditional;
      		}
      
      		// If an array was passed in, assume that it is an array of form elements.
      		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
      			// Serialize the form elements
      			jQuery.each( a, function() {
      				add( this.name, this.value );
      			});
      
      		} else {
      			// If traditional, encode the "old" way (the way 1.3.2 or older
      			// did it), otherwise encode params recursively.
      			for ( var prefix in a ) {
      				buildParams( prefix, a[ prefix ], traditional, add );
      			}
      		}
      
      		// Return the resulting serialization
      		return s.join( "&" ).replace( r20, "+" );
      	}
      });
      
      function buildParams( prefix, obj, traditional, add ) {
      	if ( jQuery.isArray( obj ) ) {
      		// Serialize array item.
      		jQuery.each( obj, function( i, v ) {
      			if ( traditional || rbracket.test( prefix ) ) {
      				// Treat each array item as a scalar.
      				add( prefix, v );
      
      			} else {
      				// If array item is non-scalar (array or object), encode its
      				// numeric index to resolve deserialization ambiguity issues.
      				// Note that rack (as of 1.0.0) can't currently deserialize
      				// nested arrays properly, and attempting to do so may cause
      				// a server error. Possible fixes are to modify rack's
      				// deserialization algorithm or to provide an option or flag
      				// to force array serialization to be shallow.
      				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
      			}
      		});
      
      	} else if ( !traditional && obj != null && typeof obj === "object" ) {
      		// Serialize object item.
      		for ( var name in obj ) {
      			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
      		}
      
      	} else {
      		// Serialize scalar item.
      		add( prefix, obj );
      	}
      }
      
      // This is still on the jQuery object... for now
      // Want to move this to jQuery.ajax some day
      jQuery.extend({
      
      	// Counter for holding the number of active queries
      	active: 0,
      
      	// Last-Modified header cache for next request
      	lastModified: {},
      	etag: {}
      
      });
      
      /* Handles responses to an ajax request:
       * - sets all responseXXX fields accordingly
       * - finds the right dataType (mediates between content-type and expected dataType)
       * - returns the corresponding response
       */
      function ajaxHandleResponses( s, jqXHR, responses ) {
      
      	var contents = s.contents,
      		dataTypes = s.dataTypes,
      		responseFields = s.responseFields,
      		ct,
      		type,
      		finalDataType,
      		firstDataType;
      
      	// Fill responseXXX fields
      	for( type in responseFields ) {
      		if ( type in responses ) {
      			jqXHR[ responseFields[type] ] = responses[ type ];
      		}
      	}
      
      	// Remove auto dataType and get content-type in the process
      	while( dataTypes[ 0 ] === "*" ) {
      		dataTypes.shift();
      		if ( ct === undefined ) {
      			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
      		}
      	}
      
      	// Check if we're dealing with a known content-type
      	if ( ct ) {
      		for ( type in contents ) {
      			if ( contents[ type ] && contents[ type ].test( ct ) ) {
      				dataTypes.unshift( type );
      				break;
      			}
      		}
      	}
      
      	// Check to see if we have a response for the expected dataType
      	if ( dataTypes[ 0 ] in responses ) {
      		finalDataType = dataTypes[ 0 ];
      	} else {
      		// Try convertible dataTypes
      		for ( type in responses ) {
      			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
      				finalDataType = type;
      				break;
      			}
      			if ( !firstDataType ) {
      				firstDataType = type;
      			}
      		}
      		// Or just use first one
      		finalDataType = finalDataType || firstDataType;
      	}
      
      	// If we found a dataType
      	// We add the dataType to the list if needed
      	// and return the corresponding response
      	if ( finalDataType ) {
      		if ( finalDataType !== dataTypes[ 0 ] ) {
      			dataTypes.unshift( finalDataType );
      		}
      		return responses[ finalDataType ];
      	}
      }
      
      // Chain conversions given the request and the original response
      function ajaxConvert( s, response ) {
      
      	// Apply the dataFilter if provided
      	if ( s.dataFilter ) {
      		response = s.dataFilter( response, s.dataType );
      	}
      
      	var dataTypes = s.dataTypes,
      		converters = {},
      		i,
      		key,
      		length = dataTypes.length,
      		tmp,
      		// Current and previous dataTypes
      		current = dataTypes[ 0 ],
      		prev,
      		// Conversion expression
      		conversion,
      		// Conversion function
      		conv,
      		// Conversion functions (transitive conversion)
      		conv1,
      		conv2;
      
      	// For each dataType in the chain
      	for( i = 1; i < length; i++ ) {
      
      		// Create converters map
      		// with lowercased keys
      		if ( i === 1 ) {
      			for( key in s.converters ) {
      				if( typeof key === "string" ) {
      					converters[ key.toLowerCase() ] = s.converters[ key ];
      				}
      			}
      		}
      
      		// Get the dataTypes
      		prev = current;
      		current = dataTypes[ i ];
      
      		// If current is auto dataType, update it to prev
      		if( current === "*" ) {
      			current = prev;
      		// If no auto and dataTypes are actually different
      		} else if ( prev !== "*" && prev !== current ) {
      
      			// Get the converter
      			conversion = prev + " " + current;
      			conv = converters[ conversion ] || converters[ "* " + current ];
      
      			// If there is no direct converter, search transitively
      			if ( !conv ) {
      				conv2 = undefined;
      				for( conv1 in converters ) {
      					tmp = conv1.split( " " );
      					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
      						conv2 = converters[ tmp[1] + " " + current ];
      						if ( conv2 ) {
      							conv1 = converters[ conv1 ];
      							if ( conv1 === true ) {
      								conv = conv2;
      							} else if ( conv2 === true ) {
      								conv = conv1;
      							}
      							break;
      						}
      					}
      				}
      			}
      			// If we found no converter, dispatch an error
      			if ( !( conv || conv2 ) ) {
      				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
      			}
      			// If found converter is not an equivalence
      			if ( conv !== true ) {
      				// Convert with 1 or 2 converters accordingly
      				response = conv ? conv( response ) : conv2( conv1(response) );
      			}
      		}
      	}
      	return response;
      }
      
      
      
      
      var jsc = jQuery.now(),
      	jsre = /(\=)\?(&|$)|\?\?/i;
      
      // Default jsonp settings
      jQuery.ajaxSetup({
      	jsonp: "callback",
      	jsonpCallback: function() {
      		return jQuery.expando + "_" + ( jsc++ );
      	}
      });
      
      // Detect, normalize options and install callbacks for jsonp requests
      jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
      
      	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
      		( typeof s.data === "string" );
      
      	if ( s.dataTypes[ 0 ] === "jsonp" ||
      		s.jsonp !== false && ( jsre.test( s.url ) ||
      				inspectData && jsre.test( s.data ) ) ) {
      
      		var responseContainer,
      			jsonpCallback = s.jsonpCallback =
      				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
      			previous = window[ jsonpCallback ],
      			url = s.url,
      			data = s.data,
      			replace = "$1" + jsonpCallback + "$2";
      
      		if ( s.jsonp !== false ) {
      			url = url.replace( jsre, replace );
      			if ( s.url === url ) {
      				if ( inspectData ) {
      					data = data.replace( jsre, replace );
      				}
      				if ( s.data === data ) {
      					// Add callback manually
      					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
      				}
      			}
      		}
      
      		s.url = url;
      		s.data = data;
      
      		// Install callback
      		window[ jsonpCallback ] = function( response ) {
      			responseContainer = [ response ];
      		};
      
      		// Clean-up function
      		jqXHR.always(function() {
      			// Set callback back to previous value
      			window[ jsonpCallback ] = previous;
      			// Call if it was a function and we have a response
      			if ( responseContainer && jQuery.isFunction( previous ) ) {
      				window[ jsonpCallback ]( responseContainer[ 0 ] );
      			}
      		});
      
      		// Use data converter to retrieve json after script execution
      		s.converters["script json"] = function() {
      			if ( !responseContainer ) {
      				jQuery.error( jsonpCallback + " was not called" );
      			}
      			return responseContainer[ 0 ];
      		};
      
      		// force json dataType
      		s.dataTypes[ 0 ] = "json";
      
      		// Delegate to script
      		return "script";
      	}
      });
      
      
      
      
      // Install script dataType
      jQuery.ajaxSetup({
      	accepts: {
      		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      	},
      	contents: {
      		script: /javascript|ecmascript/
      	},
      	converters: {
      		"text script": function( text ) {
      			jQuery.globalEval( text );
      			return text;
      		}
      	}
      });
      
      // Handle cache's special case and global
      jQuery.ajaxPrefilter( "script", function( s ) {
      	if ( s.cache === undefined ) {
      		s.cache = false;
      	}
      	if ( s.crossDomain ) {
      		s.type = "GET";
      		s.global = false;
      	}
      });
      
      // Bind script tag hack transport
      jQuery.ajaxTransport( "script", function(s) {
      
      	// This transport only deals with cross domain requests
      	if ( s.crossDomain ) {
      
      		var script,
      			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;
      
      		return {
      
      			send: function( _, callback ) {
      
      				script = document.createElement( "script" );
      
      				script.async = "async";
      
      				if ( s.scriptCharset ) {
      					script.charset = s.scriptCharset;
      				}
      
      				script.src = s.url;
      
      				// Attach handlers for all browsers
      				script.onload = script.onreadystatechange = function( _, isAbort ) {
      
      					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
      
      						// Handle memory leak in IE
      						script.onload = script.onreadystatechange = null;
      
      						// Remove the script
      						if ( head && script.parentNode ) {
      							head.removeChild( script );
      						}
      
      						// Dereference the script
      						script = undefined;
      
      						// Callback if not abort
      						if ( !isAbort ) {
      							callback( 200, "success" );
      						}
      					}
      				};
      				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
      				// This arises when a base node is used (#2709 and #4378).
      				head.insertBefore( script, head.firstChild );
      			},
      
      			abort: function() {
      				if ( script ) {
      					script.onload( 0, 1 );
      				}
      			}
      		};
      	}
      });
      
      
      
      
      var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
      	xhrOnUnloadAbort = window.ActiveXObject ? function() {
      		// Abort all pending requests
      		for ( var key in xhrCallbacks ) {
      			xhrCallbacks[ key ]( 0, 1 );
      		}
      	} : false,
      	xhrId = 0,
      	xhrCallbacks;
      
      // Functions to create xhrs
      function createStandardXHR() {
      	try {
      		return new window.XMLHttpRequest();
      	} catch( e ) {}
      }
      
      function createActiveXHR() {
      	try {
      		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
      	} catch( e ) {}
      }
      
      // Create the request object
      // (This is still attached to ajaxSettings for backward compatibility)
      jQuery.ajaxSettings.xhr = window.ActiveXObject ?
      	/* Microsoft failed to properly
      	 * implement the XMLHttpRequest in IE7 (can't request local files),
      	 * so we use the ActiveXObject when it is available
      	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
      	 * we need a fallback.
      	 */
      	function() {
      		return !this.isLocal && createStandardXHR() || createActiveXHR();
      	} :
      	// For all other browsers, use the standard XMLHttpRequest object
      	createStandardXHR;
      
      // Determine support properties
      (function( xhr ) {
      	jQuery.extend( jQuery.support, {
      		ajax: !!xhr,
      		cors: !!xhr && ( "withCredentials" in xhr )
      	});
      })( jQuery.ajaxSettings.xhr() );
      
      // Create transport if the browser can provide an xhr
      if ( jQuery.support.ajax ) {
      
      	jQuery.ajaxTransport(function( s ) {
      		// Cross domain only allowed if supported through XMLHttpRequest
      		if ( !s.crossDomain || jQuery.support.cors ) {
      
      			var callback;
      
      			return {
      				send: function( headers, complete ) {
      
      					// Get a new xhr
      					var xhr = s.xhr(),
      						handle,
      						i;
      
      					// Open the socket
      					// Passing null username, generates a login popup on Opera (#2865)
      					if ( s.username ) {
      						xhr.open( s.type, s.url, s.async, s.username, s.password );
      					} else {
      						xhr.open( s.type, s.url, s.async );
      					}
      
      					// Apply custom fields if provided
      					if ( s.xhrFields ) {
      						for ( i in s.xhrFields ) {
      							xhr[ i ] = s.xhrFields[ i ];
      						}
      					}
      
      					// Override mime type if needed
      					if ( s.mimeType && xhr.overrideMimeType ) {
      						xhr.overrideMimeType( s.mimeType );
      					}
      
      					// X-Requested-With header
      					// For cross-domain requests, seeing as conditions for a preflight are
      					// akin to a jigsaw puzzle, we simply never set it to be sure.
      					// (it can always be set on a per-request basis or even using ajaxSetup)
      					// For same-domain requests, won't change header if already provided.
      					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
      						headers[ "X-Requested-With" ] = "XMLHttpRequest";
      					}
      
      					// Need an extra try/catch for cross domain requests in Firefox 3
      					try {
      						for ( i in headers ) {
      							xhr.setRequestHeader( i, headers[ i ] );
      						}
      					} catch( _ ) {}
      
      					// Do send the request
      					// This may raise an exception which is actually
      					// handled in jQuery.ajax (so no try/catch here)
      					xhr.send( ( s.hasContent && s.data ) || null );
      
      					// Listener
      					callback = function( _, isAbort ) {
      
      						var status,
      							statusText,
      							responseHeaders,
      							responses,
      							xml;
      
      						// Firefox throws exceptions when accessing properties
      						// of an xhr when a network error occured
      						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
      						try {
      
      							// Was never called and is aborted or complete
      							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
      
      								// Only called once
      								callback = undefined;
      
      								// Do not keep as active anymore
      								if ( handle ) {
      									xhr.onreadystatechange = jQuery.noop;
      									if ( xhrOnUnloadAbort ) {
      										delete xhrCallbacks[ handle ];
      									}
      								}
      
      								// If it's an abort
      								if ( isAbort ) {
      									// Abort it manually if needed
      									if ( xhr.readyState !== 4 ) {
      										xhr.abort();
      									}
      								} else {
      									status = xhr.status;
      									responseHeaders = xhr.getAllResponseHeaders();
      									responses = {};
      									xml = xhr.responseXML;
      
      									// Construct response list
      									if ( xml && xml.documentElement /* #4958 */ ) {
      										responses.xml = xml;
      									}
      									responses.text = xhr.responseText;
      
      									// Firefox throws an exception when accessing
      									// statusText for faulty cross-domain requests
      									try {
      										statusText = xhr.statusText;
      									} catch( e ) {
      										// We normalize with Webkit giving an empty statusText
      										statusText = "";
      									}
      
      									// Filter status for non standard behaviors
      
      									// If the request is local and we have data: assume a success
      									// (success with no data won't get notified, that's the best we
      									// can do given current implementations)
      									if ( !status && s.isLocal && !s.crossDomain ) {
      										status = responses.text ? 200 : 404;
      									// IE - #1450: sometimes returns 1223 when it should be 204
      									} else if ( status === 1223 ) {
      										status = 204;
      									}
      								}
      							}
      						} catch( firefoxAccessException ) {
      							if ( !isAbort ) {
      								complete( -1, firefoxAccessException );
      							}
      						}
      
      						// Call complete if needed
      						if ( responses ) {
      							complete( status, statusText, responses, responseHeaders );
      						}
      					};
      
      					// if we're in sync mode or it's in cache
      					// and has been retrieved directly (IE6 & IE7)
      					// we need to manually fire the callback
      					if ( !s.async || xhr.readyState === 4 ) {
      						callback();
      					} else {
      						handle = ++xhrId;
      						if ( xhrOnUnloadAbort ) {
      							// Create the active xhrs callbacks list if needed
      							// and attach the unload handler
      							if ( !xhrCallbacks ) {
      								xhrCallbacks = {};
      								jQuery( window ).unload( xhrOnUnloadAbort );
      							}
      							// Add to list of active xhrs callbacks
      							xhrCallbacks[ handle ] = callback;
      						}
      						xhr.onreadystatechange = callback;
      					}
      				},
      
      				abort: function() {
      					if ( callback ) {
      						callback(0,1);
      					}
      				}
      			};
      		}
      	});
      }
      
      
      
      
      var elemdisplay = {},
      	iframe, iframeDoc,
      	rfxtypes = /^(?:toggle|show|hide)$/,
      	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
      	timerId,
      	fxAttrs = [
      		// height animations
      		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
      		// width animations
      		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
      		// opacity animations
      		[ "opacity" ]
      	],
      	fxNow,
      	requestAnimationFrame = window.webkitRequestAnimationFrame ||
      	    window.mozRequestAnimationFrame ||
      	    window.oRequestAnimationFrame;
      
      jQuery.fn.extend({
      	show: function( speed, easing, callback ) {
      		var elem, display;
      
      		if ( speed || speed === 0 ) {
      			return this.animate( genFx("show", 3), speed, easing, callback);
      
      		} else {
      			for ( var i = 0, j = this.length; i < j; i++ ) {
      				elem = this[i];
      
      				if ( elem.style ) {
      					display = elem.style.display;
      
      					// Reset the inline display of this element to learn if it is
      					// being hidden by cascaded rules or not
      					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
      						display = elem.style.display = "";
      					}
      
      					// Set elements which have been overridden with display: none
      					// in a stylesheet to whatever the default browser style is
      					// for such an element
      					if ( display === "" && jQuery.css( elem, "display" ) === "none" ) {
      						jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
      					}
      				}
      			}
      
      			// Set the display of most of the elements in a second loop
      			// to avoid the constant reflow
      			for ( i = 0; i < j; i++ ) {
      				elem = this[i];
      
      				if ( elem.style ) {
      					display = elem.style.display;
      
      					if ( display === "" || display === "none" ) {
      						elem.style.display = jQuery._data(elem, "olddisplay") || "";
      					}
      				}
      			}
      
      			return this;
      		}
      	},
      
      	hide: function( speed, easing, callback ) {
      		if ( speed || speed === 0 ) {
      			return this.animate( genFx("hide", 3), speed, easing, callback);
      
      		} else {
      			for ( var i = 0, j = this.length; i < j; i++ ) {
      				if ( this[i].style ) {
      					var display = jQuery.css( this[i], "display" );
      
      					if ( display !== "none" && !jQuery._data( this[i], "olddisplay" ) ) {
      						jQuery._data( this[i], "olddisplay", display );
      					}
      				}
      			}
      
      			// Set the display of the elements in a second loop
      			// to avoid the constant reflow
      			for ( i = 0; i < j; i++ ) {
      				if ( this[i].style ) {
      					this[i].style.display = "none";
      				}
      			}
      
      			return this;
      		}
      	},
      
      	// Save the old toggle function
      	_toggle: jQuery.fn.toggle,
      
      	toggle: function( fn, fn2, callback ) {
      		var bool = typeof fn === "boolean";
      
      		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
      			this._toggle.apply( this, arguments );
      
      		} else if ( fn == null || bool ) {
      			this.each(function() {
      				var state = bool ? fn : jQuery(this).is(":hidden");
      				jQuery(this)[ state ? "show" : "hide" ]();
      			});
      
      		} else {
      			this.animate(genFx("toggle", 3), fn, fn2, callback);
      		}
      
      		return this;
      	},
      
      	fadeTo: function( speed, to, easing, callback ) {
      		return this.filter(":hidden").css("opacity", 0).show().end()
      					.animate({opacity: to}, speed, easing, callback);
      	},
      
      	animate: function( prop, speed, easing, callback ) {
      		var optall = jQuery.speed(speed, easing, callback);
      
      		if ( jQuery.isEmptyObject( prop ) ) {
      			return this.each( optall.complete, [ false ] );
      		}
      
      		// Do not change referenced properties as per-property easing will be lost
      		prop = jQuery.extend( {}, prop );
      
      		return this[ optall.queue === false ? "each" : "queue" ](function() {
      			// XXX 'this' does not always have a nodeName when running the
      			// test suite
      
      			if ( optall.queue === false ) {
      				jQuery._mark( this );
      			}
      
      			var opt = jQuery.extend( {}, optall ),
      				isElement = this.nodeType === 1,
      				hidden = isElement && jQuery(this).is(":hidden"),
      				name, val, p,
      				display, e,
      				parts, start, end, unit;
      
      			// will store per property easing and be used to determine when an animation is complete
      			opt.animatedProperties = {};
      
      			for ( p in prop ) {
      
      				// property name normalization
      				name = jQuery.camelCase( p );
      				if ( p !== name ) {
      					prop[ name ] = prop[ p ];
      					delete prop[ p ];
      				}
      
      				val = prop[ name ];
      
      				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
      				if ( jQuery.isArray( val ) ) {
      					opt.animatedProperties[ name ] = val[ 1 ];
      					val = prop[ name ] = val[ 0 ];
      				} else {
      					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
      				}
      
      				if ( val === "hide" && hidden || val === "show" && !hidden ) {
      					return opt.complete.call( this );
      				}
      
      				if ( isElement && ( name === "height" || name === "width" ) ) {
      					// Make sure that nothing sneaks out
      					// Record all 3 overflow attributes because IE does not
      					// change the overflow attribute when overflowX and
      					// overflowY are set to the same value
      					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
      
      					// Set display property to inline-block for height/width
      					// animations on inline elements that are having width/height
      					// animated
      					if ( jQuery.css( this, "display" ) === "inline" &&
      							jQuery.css( this, "float" ) === "none" ) {
      						if ( !jQuery.support.inlineBlockNeedsLayout ) {
      							this.style.display = "inline-block";
      
      						} else {
      							display = defaultDisplay( this.nodeName );
      
      							// inline-level elements accept inline-block;
      							// block-level elements need to be inline with layout
      							if ( display === "inline" ) {
      								this.style.display = "inline-block";
      
      							} else {
      								this.style.display = "inline";
      								this.style.zoom = 1;
      							}
      						}
      					}
      				}
      			}
      
      			if ( opt.overflow != null ) {
      				this.style.overflow = "hidden";
      			}
      
      			for ( p in prop ) {
      				e = new jQuery.fx( this, opt, p );
      				val = prop[ p ];
      
      				if ( rfxtypes.test(val) ) {
      					e[ val === "toggle" ? hidden ? "show" : "hide" : val ]();
      
      				} else {
      					parts = rfxnum.exec( val );
      					start = e.cur();
      
      					if ( parts ) {
      						end = parseFloat( parts[2] );
      						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );
      
      						// We need to compute starting value
      						if ( unit !== "px" ) {
      							jQuery.style( this, p, (end || 1) + unit);
      							start = ((end || 1) / e.cur()) * start;
      							jQuery.style( this, p, start + unit);
      						}
      
      						// If a +=/-= token was provided, we're doing a relative animation
      						if ( parts[1] ) {
      							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
      						}
      
      						e.custom( start, end, unit );
      
      					} else {
      						e.custom( start, val, "" );
      					}
      				}
      			}
      
      			// For JS strict compliance
      			return true;
      		});
      	},
      
      	stop: function( clearQueue, gotoEnd ) {
      		if ( clearQueue ) {
      			this.queue([]);
      		}
      
      		this.each(function() {
      			var timers = jQuery.timers,
      				i = timers.length;
      			// clear marker counters if we know they won't be
      			if ( !gotoEnd ) {
      				jQuery._unmark( true, this );
      			}
      			while ( i-- ) {
      				if ( timers[i].elem === this ) {
      					if (gotoEnd) {
      						// force the next step to be the last
      						timers[i](true);
      					}
      
      					timers.splice(i, 1);
      				}
      			}
      		});
      
      		// start the next in the queue if the last step wasn't forced
      		if ( !gotoEnd ) {
      			this.dequeue();
      		}
      
      		return this;
      	}
      
      });
      
      // Animations created synchronously will run synchronously
      function createFxNow() {
      	setTimeout( clearFxNow, 0 );
      	return ( fxNow = jQuery.now() );
      }
      
      function clearFxNow() {
      	fxNow = undefined;
      }
      
      // Generate parameters to create a standard animation
      function genFx( type, num ) {
      	var obj = {};
      
      	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
      		obj[ this ] = type;
      	});
      
      	return obj;
      }
      
      // Generate shortcuts for custom animations
      jQuery.each({
      	slideDown: genFx("show", 1),
      	slideUp: genFx("hide", 1),
      	slideToggle: genFx("toggle", 1),
      	fadeIn: { opacity: "show" },
      	fadeOut: { opacity: "hide" },
      	fadeToggle: { opacity: "toggle" }
      }, function( name, props ) {
      	jQuery.fn[ name ] = function( speed, easing, callback ) {
      		return this.animate( props, speed, easing, callback );
      	};
      });
      
      jQuery.extend({
      	speed: function( speed, easing, fn ) {
      		var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      			complete: fn || !fn && easing ||
      				jQuery.isFunction( speed ) && speed,
      			duration: speed,
      			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      		};
      
      		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
      			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
      
      		// Queueing
      		opt.old = opt.complete;
      		opt.complete = function( noUnmark ) {
      			if ( opt.queue !== false ) {
      				jQuery.dequeue( this );
      			} else if ( noUnmark !== false ) {
      				jQuery._unmark( this );
      			}
      
      			if ( jQuery.isFunction( opt.old ) ) {
      				opt.old.call( this );
      			}
      		};
      
      		return opt;
      	},
      
      	easing: {
      		linear: function( p, n, firstNum, diff ) {
      			return firstNum + diff * p;
      		},
      		swing: function( p, n, firstNum, diff ) {
      			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
      		}
      	},
      
      	timers: [],
      
      	fx: function( elem, options, prop ) {
      		this.options = options;
      		this.elem = elem;
      		this.prop = prop;
      
      		options.orig = options.orig || {};
      	}
      
      });
      
      jQuery.fx.prototype = {
      	// Simple function for setting a style value
      	update: function() {
      		if ( this.options.step ) {
      			this.options.step.call( this.elem, this.now, this );
      		}
      
      		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
      	},
      
      	// Get the current size
      	cur: function() {
      		if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
      			return this.elem[ this.prop ];
      		}
      
      		var parsed,
      			r = jQuery.css( this.elem, this.prop );
      		// Empty strings, null, undefined and "auto" are converted to 0,
      		// complex values such as "rotate(1rad)" are returned as is,
      		// simple values such as "10px" are parsed to Float.
      		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
      	},
      
      	// Start an animation from one number to another
      	custom: function( from, to, unit ) {
      		var self = this,
      			fx = jQuery.fx,
      			raf;
      
      		this.startTime = fxNow || createFxNow();
      		this.start = from;
      		this.end = to;
      		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
      		this.now = this.start;
      		this.pos = this.state = 0;
      
      		function t( gotoEnd ) {
      			return self.step(gotoEnd);
      		}
      
      		t.elem = this.elem;
      
      		if ( t() && jQuery.timers.push(t) && !timerId ) {
      			// Use requestAnimationFrame instead of setInterval if available
      			if ( requestAnimationFrame ) {
      				timerId = 1;
      				raf = function() {
      					// When timerId gets set to null at any point, this stops
      					if ( timerId ) {
      						requestAnimationFrame( raf );
      						fx.tick();
      					}
      				};
      				requestAnimationFrame( raf );
      			} else {
      				timerId = setInterval( fx.tick, fx.interval );
      			}
      		}
      	},
      
      	// Simple 'show' function
      	show: function() {
      		// Remember where we started, so that we can go back to it later
      		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
      		this.options.show = true;
      
      		// Begin the animation
      		// Make sure that we start at a small width/height to avoid any
      		// flash of content
      		this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());
      
      		// Start by showing the element
      		jQuery( this.elem ).show();
      	},
      
      	// Simple 'hide' function
      	hide: function() {
      		// Remember where we started, so that we can go back to it later
      		this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
      		this.options.hide = true;
      
      		// Begin the animation
      		this.custom(this.cur(), 0);
      	},
      
      	// Each step of an animation
      	step: function( gotoEnd ) {
      		var t = fxNow || createFxNow(),
      			done = true,
      			elem = this.elem,
      			options = this.options,
      			i, n;
      
      		if ( gotoEnd || t >= options.duration + this.startTime ) {
      			this.now = this.end;
      			this.pos = this.state = 1;
      			this.update();
      
      			options.animatedProperties[ this.prop ] = true;
      
      			for ( i in options.animatedProperties ) {
      				if ( options.animatedProperties[i] !== true ) {
      					done = false;
      				}
      			}
      
      			if ( done ) {
      				// Reset the overflow
      				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {
      
      					jQuery.each( [ "", "X", "Y" ], function (index, value) {
      						elem.style[ "overflow" + value ] = options.overflow[index];
      					});
      				}
      
      				// Hide the element if the "hide" operation was done
      				if ( options.hide ) {
      					jQuery(elem).hide();
      				}
      
      				// Reset the properties, if the item has been hidden or shown
      				if ( options.hide || options.show ) {
      					for ( var p in options.animatedProperties ) {
      						jQuery.style( elem, p, options.orig[p] );
      					}
      				}
      
      				// Execute the complete function
      				options.complete.call( elem );
      			}
      
      			return false;
      
      		} else {
      			// classical easing cannot be used with an Infinity duration
      			if ( options.duration == Infinity ) {
      				this.now = t;
      			} else {
      				n = t - this.startTime;
      				this.state = n / options.duration;
      
      				// Perform the easing function, defaults to swing
      				this.pos = jQuery.easing[ options.animatedProperties[ this.prop ] ]( this.state, n, 0, 1, options.duration );
      				this.now = this.start + ((this.end - this.start) * this.pos);
      			}
      			// Perform the next step of the animation
      			this.update();
      		}
      
      		return true;
      	}
      };
      
      jQuery.extend( jQuery.fx, {
      	tick: function() {
      		for ( var timers = jQuery.timers, i = 0 ; i < timers.length ; ++i ) {
      			if ( !timers[i]() ) {
      				timers.splice(i--, 1);
      			}
      		}
      
      		if ( !timers.length ) {
      			jQuery.fx.stop();
      		}
      	},
      
      	interval: 13,
      
      	stop: function() {
      		clearInterval( timerId );
      		timerId = null;
      	},
      
      	speeds: {
      		slow: 600,
      		fast: 200,
      		// Default speed
      		_default: 400
      	},
      
      	step: {
      		opacity: function( fx ) {
      			jQuery.style( fx.elem, "opacity", fx.now );
      		},
      
      		_default: function( fx ) {
      			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
      				fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
      			} else {
      				fx.elem[ fx.prop ] = fx.now;
      			}
      		}
      	}
      });
      
      if ( jQuery.expr && jQuery.expr.filters ) {
      	jQuery.expr.filters.animated = function( elem ) {
      		return jQuery.grep(jQuery.timers, function( fn ) {
      			return elem === fn.elem;
      		}).length;
      	};
      }
      
      // Try to restore the default display value of an element
      function defaultDisplay( nodeName ) {
      
      	if ( !elemdisplay[ nodeName ] ) {
      
      		var elem = jQuery( "<" + nodeName + ">" ).appendTo( "body" ),
      			display = elem.css( "display" );
      
      		elem.remove();
      
      		// If the simple way fails,
      		// get element's real default display by attaching it to a temp iframe
      		if ( display === "none" || display === "" ) {
      			// No iframe to use yet, so create it
      			if ( !iframe ) {
      				iframe = document.createElement( "iframe" );
      				iframe.frameBorder = iframe.width = iframe.height = 0;
      			}
      
      			document.body.appendChild( iframe );
      
      			// Create a cacheable copy of the iframe document on first call.
      			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake html
      			// document to it, Webkit & Firefox won't allow reusing the iframe document
      			if ( !iframeDoc || !iframe.createElement ) {
      				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
      				iframeDoc.write( "<!doctype><html><body></body></html>" );
      			}
      
      			elem = iframeDoc.createElement( nodeName );
      
      			iframeDoc.body.appendChild( elem );
      
      			display = jQuery.css( elem, "display" );
      
      			document.body.removeChild( iframe );
      		}
      
      		// Store the correct default display
      		elemdisplay[ nodeName ] = display;
      	}
      
      	return elemdisplay[ nodeName ];
      }
      
      
      
      
      var rtable = /^t(?:able|d|h)$/i,
      	rroot = /^(?:body|html)$/i;
      
      if ( "getBoundingClientRect" in document.documentElement ) {
      	jQuery.fn.offset = function( options ) {
      		var elem = this[0], box;
      
      		if ( options ) {
      			return this.each(function( i ) {
      				jQuery.offset.setOffset( this, options, i );
      			});
      		}
      
      		if ( !elem || !elem.ownerDocument ) {
      			return null;
      		}
      
      		if ( elem === elem.ownerDocument.body ) {
      			return jQuery.offset.bodyOffset( elem );
      		}
      
      		try {
      			box = elem.getBoundingClientRect();
      		} catch(e) {}
      
      		var doc = elem.ownerDocument,
      			docElem = doc.documentElement;
      
      		// Make sure we're not dealing with a disconnected DOM node
      		if ( !box || !jQuery.contains( docElem, elem ) ) {
      			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
      		}
      
      		var body = doc.body,
      			win = getWindow(doc),
      			clientTop  = docElem.clientTop  || body.clientTop  || 0,
      			clientLeft = docElem.clientLeft || body.clientLeft || 0,
      			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
      			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
      			top  = box.top  + scrollTop  - clientTop,
      			left = box.left + scrollLeft - clientLeft;
      
      		return { top: top, left: left };
      	};
      
      } else {
      	jQuery.fn.offset = function( options ) {
      		var elem = this[0];
      
      		if ( options ) {
      			return this.each(function( i ) {
      				jQuery.offset.setOffset( this, options, i );
      			});
      		}
      
      		if ( !elem || !elem.ownerDocument ) {
      			return null;
      		}
      
      		if ( elem === elem.ownerDocument.body ) {
      			return jQuery.offset.bodyOffset( elem );
      		}
      
      		jQuery.offset.initialize();
      
      		var computedStyle,
      			offsetParent = elem.offsetParent,
      			prevOffsetParent = elem,
      			doc = elem.ownerDocument,
      			docElem = doc.documentElement,
      			body = doc.body,
      			defaultView = doc.defaultView,
      			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
      			top = elem.offsetTop,
      			left = elem.offsetLeft;
      
      		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
      			if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
      				break;
      			}
      
      			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
      			top  -= elem.scrollTop;
      			left -= elem.scrollLeft;
      
      			if ( elem === offsetParent ) {
      				top  += elem.offsetTop;
      				left += elem.offsetLeft;
      
      				if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
      					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
      					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
      				}
      
      				prevOffsetParent = offsetParent;
      				offsetParent = elem.offsetParent;
      			}
      
      			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
      				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
      				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
      			}
      
      			prevComputedStyle = computedStyle;
      		}
      
      		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
      			top  += body.offsetTop;
      			left += body.offsetLeft;
      		}
      
      		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
      			top  += Math.max( docElem.scrollTop, body.scrollTop );
      			left += Math.max( docElem.scrollLeft, body.scrollLeft );
      		}
      
      		return { top: top, left: left };
      	};
      }
      
      jQuery.offset = {
      	initialize: function() {
      		var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
      			html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
      
      		jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );
      
      		container.innerHTML = html;
      		body.insertBefore( container, body.firstChild );
      		innerDiv = container.firstChild;
      		checkDiv = innerDiv.firstChild;
      		td = innerDiv.nextSibling.firstChild.firstChild;
      
      		this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
      		this.doesAddBorderForTableAndCells = (td.offsetTop === 5);
      
      		checkDiv.style.position = "fixed";
      		checkDiv.style.top = "20px";
      
      		// safari subtracts parent border width here which is 5px
      		this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
      		checkDiv.style.position = checkDiv.style.top = "";
      
      		innerDiv.style.overflow = "hidden";
      		innerDiv.style.position = "relative";
      
      		this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);
      
      		this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);
      
      		body.removeChild( container );
      		jQuery.offset.initialize = jQuery.noop;
      	},
      
      	bodyOffset: function( body ) {
      		var top = body.offsetTop,
      			left = body.offsetLeft;
      
      		jQuery.offset.initialize();
      
      		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
      			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
      			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
      		}
      
      		return { top: top, left: left };
      	},
      
      	setOffset: function( elem, options, i ) {
      		var position = jQuery.css( elem, "position" );
      
      		// set position first, in-case top/left are set even on static elem
      		if ( position === "static" ) {
      			elem.style.position = "relative";
      		}
      
      		var curElem = jQuery( elem ),
      			curOffset = curElem.offset(),
      			curCSSTop = jQuery.css( elem, "top" ),
      			curCSSLeft = jQuery.css( elem, "left" ),
      			calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
      			props = {}, curPosition = {}, curTop, curLeft;
      
      		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
      		if ( calculatePosition ) {
      			curPosition = curElem.position();
      			curTop = curPosition.top;
      			curLeft = curPosition.left;
      		} else {
      			curTop = parseFloat( curCSSTop ) || 0;
      			curLeft = parseFloat( curCSSLeft ) || 0;
      		}
      
      		if ( jQuery.isFunction( options ) ) {
      			options = options.call( elem, i, curOffset );
      		}
      
      		if (options.top != null) {
      			props.top = (options.top - curOffset.top) + curTop;
      		}
      		if (options.left != null) {
      			props.left = (options.left - curOffset.left) + curLeft;
      		}
      
      		if ( "using" in options ) {
      			options.using.call( elem, props );
      		} else {
      			curElem.css( props );
      		}
      	}
      };
      
      
      jQuery.fn.extend({
      	position: function() {
      		if ( !this[0] ) {
      			return null;
      		}
      
      		var elem = this[0],
      
      		// Get *real* offsetParent
      		offsetParent = this.offsetParent(),
      
      		// Get correct offsets
      		offset       = this.offset(),
      		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
      
      		// Subtract element margins
      		// note: when an element has margin: auto the offsetLeft and marginLeft
      		// are the same in Safari causing offset.left to incorrectly be 0
      		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
      		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;
      
      		// Add offsetParent borders
      		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
      		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;
      
      		// Subtract the two offsets
      		return {
      			top:  offset.top  - parentOffset.top,
      			left: offset.left - parentOffset.left
      		};
      	},
      
      	offsetParent: function() {
      		return this.map(function() {
      			var offsetParent = this.offsetParent || document.body;
      			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
      				offsetParent = offsetParent.offsetParent;
      			}
      			return offsetParent;
      		});
      	}
      });
      
      
      // Create scrollLeft and scrollTop methods
      jQuery.each( ["Left", "Top"], function( i, name ) {
      	var method = "scroll" + name;
      
      	jQuery.fn[ method ] = function( val ) {
      		var elem, win;
      
      		if ( val === undefined ) {
      			elem = this[ 0 ];
      
      			if ( !elem ) {
      				return null;
      			}
      
      			win = getWindow( elem );
      
      			// Return the scroll offset
      			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
      				jQuery.support.boxModel && win.document.documentElement[ method ] ||
      					win.document.body[ method ] :
      				elem[ method ];
      		}
      
      		// Set the scroll offset
      		return this.each(function() {
      			win = getWindow( this );
      
      			if ( win ) {
      				win.scrollTo(
      					!i ? val : jQuery( win ).scrollLeft(),
      					 i ? val : jQuery( win ).scrollTop()
      				);
      
      			} else {
      				this[ method ] = val;
      			}
      		});
      	};
      });
      
      function getWindow( elem ) {
      	return jQuery.isWindow( elem ) ?
      		elem :
      		elem.nodeType === 9 ?
      			elem.defaultView || elem.parentWindow :
      			false;
      }
      
      
      
      
      // Create innerHeight, innerWidth, outerHeight and outerWidth methods
      jQuery.each([ "Height", "Width" ], function( i, name ) {
      
      	var type = name.toLowerCase();
      
      	// innerHeight and innerWidth
      	jQuery.fn["inner" + name] = function() {
      		return this[0] ?
      			parseFloat( jQuery.css( this[0], type, "padding" ) ) :
      			null;
      	};
      
      	// outerHeight and outerWidth
      	jQuery.fn["outer" + name] = function( margin ) {
      		return this[0] ?
      			parseFloat( jQuery.css( this[0], type, margin ? "margin" : "border" ) ) :
      			null;
      	};
      
      	jQuery.fn[ type ] = function( size ) {
      		// Get window width or height
      		var elem = this[0];
      		if ( !elem ) {
      			return size == null ? null : this;
      		}
      
      		if ( jQuery.isFunction( size ) ) {
      			return this.each(function( i ) {
      				var self = jQuery( this );
      				self[ type ]( size.call( this, i, self[ type ]() ) );
      			});
      		}
      
      		if ( jQuery.isWindow( elem ) ) {
      			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
      			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
      			var docElemProp = elem.document.documentElement[ "client" + name ];
      			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
      				elem.document.body[ "client" + name ] || docElemProp;
      
      		// Get document width or height
      		} else if ( elem.nodeType === 9 ) {
      			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
      			return Math.max(
      				elem.documentElement["client" + name],
      				elem.body["scroll" + name], elem.documentElement["scroll" + name],
      				elem.body["offset" + name], elem.documentElement["offset" + name]
      			);
      
      		// Get or set width or height on the element
      		} else if ( size === undefined ) {
      			var orig = jQuery.css( elem, type ),
      				ret = parseFloat( orig );
      
      			return jQuery.isNaN( ret ) ? orig : ret;
      
      		// Set the width or height on the element (default to pixels if value is unitless)
      		} else {
      			return this.css( type, typeof size === "string" ? size : size + "px" );
      		}
      	};
      
      });
      
      
      window.jQuery = window.$ = jQuery;
      })(window);
      // ==ClosureCompiler==
      // @compilation_level SIMPLE_OPTIMIZATIONS
      
      /**
       * @license Highcharts JS v2.1.6 (2011-07-08)
       * 
       * (c) 2009-2011 Torstein Hnsi
       * 
       * License: www.highcharts.com/license
       */
      
      // JSLint options:
      /*jslint forin: true */
      /*global document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $ */
      	
      (function() {
      // encapsulated variables
      var doc = document,
      	win = window,
      	math = Math,
      	mathRound = math.round,
      	mathFloor = math.floor,
      	mathCeil = math.ceil,
      	mathMax = math.max,
      	mathMin = math.min,
      	mathAbs = math.abs,
      	mathCos = math.cos,
      	mathSin = math.sin,
      	mathPI = math.PI,
      	deg2rad = mathPI * 2 / 360,
      	
      	
      	// some variables
      	userAgent = navigator.userAgent,
      	isIE = /msie/i.test(userAgent) && !win.opera,
      	docMode8 = doc.documentMode === 8,
      	isWebKit = /AppleWebKit/.test(userAgent),
      	isFirefox = /Firefox/.test(userAgent),
      	//hasSVG = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
      	hasSVG = !!doc.createElementNS && !!doc.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
      	SVG_NS = 'http://www.w3.org/2000/svg',
      	Renderer,
      	hasTouch = doc.documentElement.ontouchstart !== undefined,
      	symbolSizes = {},
      	idCounter = 0,
      	timeFactor = 1, // 1 = JavaScript time, 1000 = Unix time
      	garbageBin,
      	defaultOptions,
      	dateFormat, // function
      	globalAnimation,
      	pathAnim,
      	
      	
      	// some constants for frequently used strings
      	UNDEFINED,
      	DIV = 'div',
      	ABSOLUTE = 'absolute',
      	RELATIVE = 'relative',
      	HIDDEN = 'hidden',
      	PREFIX = 'highcharts-',
      	VISIBLE = 'visible',
      	PX = 'px',
      	NONE = 'none',
      	M = 'M',
      	L = 'L',
      	/*
      	 * Empirical lowest possible opacities for TRACKER_FILL
      	 * IE6: 0.002
      	 * IE7: 0.002
      	 * IE8: 0.002
      	 * IE9: 0.00000000001 (unlimited)
      	 * FF: 0.00000000001 (unlimited)
      	 * Chrome: 0.000001
      	 * Safari: 0.000001
      	 * Opera: 0.00000000001 (unlimited)
      	 */
      	TRACKER_FILL = 'rgba(192,192,192,'+ (hasSVG ? 0.000001 : 0.002) +')', // invisible but clickable
      	NORMAL_STATE = '',
      	HOVER_STATE = 'hover',
      	SELECT_STATE = 'select',
      	
      	// time methods, changed based on whether or not UTC is used
      	makeTime,
      	getMinutes,
      	getHours,
      	getDay,
      	getDate,
      	getMonth,
      	getFullYear,
      	setMinutes,
      	setHours,
      	setDate,
      	setMonth,
      	setFullYear,
      	
      	// check for a custom HighchartsAdapter defined prior to this file
      	globalAdapter = win.HighchartsAdapter,
      	adapter = globalAdapter || {}, 
      	
      	// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
      	// and all the utility functions will be null. In that case they are populated by the 
      	// default adapters below.
      	each = adapter.each,
      	grep = adapter.grep,
      	map = adapter.map,
      	merge = adapter.merge,
      	addEvent = adapter.addEvent,
      	removeEvent = adapter.removeEvent,
      	fireEvent = adapter.fireEvent,
      	animate = adapter.animate,
      	stop = adapter.stop,
      	
      	// lookup over the types and the associated classes
      	seriesTypes = {},
      	hoverChart;
      	
      /**
       * Extend an object with the members of another
       * @param {Object} a The object to be extended
       * @param {Object} b The object to add to the first one
       */
      function extend(a, b) {
      	var n;
      	if (!a) {
      		a = {};
      	}
      	for (n in b) {
      		a[n] = b[n];
      	}
      	return a;
      }
      
      /**
       * Shortcut for parseInt
       * @param {Object} s
       */
      function pInt(s, mag) {
      	return parseInt(s, mag || 10);
      }
      
      /**
       * Check for string
       * @param {Object} s
       */
      function isString(s) {
      	return typeof s === 'string';
      }
      
      /**
       * Check for object
       * @param {Object} obj
       */
      function isObject(obj) {
      	return typeof obj === 'object';
      }
      
      /**
       * Check for number
       * @param {Object} n
       */
      function isNumber(n) {
      	return typeof n === 'number';
      }
      
      function log2lin(num) {
      	return math.log(num) / math.LN10;
      }
      function lin2log(num) {
      	return math.pow(10, num);
      }
      
      /**
       * Remove last occurence of an item from an array
       * @param {Array} arr
       * @param {Mixed} item
       */
      function erase(arr, item) {
      	var i = arr.length;
      	while (i--) {
      		if (arr[i] === item) {
      			arr.splice(i, 1);
      			break;
      		}
      	}
      	//return arr;
      }
      
      /**
       * Returns true if the object is not null or undefined. Like MooTools' $.defined.
       * @param {Object} obj
       */
      function defined (obj) {
      	return obj !== UNDEFINED && obj !== null;
      }
      
      /**
       * Set or get an attribute or an object of attributes. Can't use jQuery attr because
       * it attempts to set expando properties on the SVG element, which is not allowed.
       * 
       * @param {Object} elem The DOM element to receive the attribute(s)
       * @param {String|Object} prop The property or an abject of key-value pairs
       * @param {String} value The value if a single property is set
       */
      function attr(elem, prop, value) {
      	var key,
      		setAttribute = 'setAttribute',
      		ret;
      	
      	// if the prop is a string
      	if (isString(prop)) {
      		// set the value
      		if (defined(value)) {
      
      			elem[setAttribute](prop, value);
      		
      		// get the value
      		} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
      			ret = elem.getAttribute(prop);
      		}
      	
      	// else if prop is defined, it is a hash of key/value pairs
      	} else if (defined(prop) && isObject(prop)) {
      		for (key in prop) {
      			elem[setAttribute](key, prop[key]);
      		}
      	}
      	return ret;
      }
      /**
       * Check if an element is an array, and if not, make it into an array. Like
       * MooTools' $.splat.
       */
      function splat(obj) {
      	if (!obj || obj.constructor !== Array) {
      		obj = [obj];
      	}
      	return obj; 
      }
      
      
      
      /**
       * Return the first value that is defined. Like MooTools' $.pick.
       */
      function pick() {
      	var args = arguments,
      		i,
      		arg,
      		length = args.length;
      	for (i = 0; i < length; i++) {
      		arg = args[i];
      		if (typeof arg !== 'undefined' && arg !== null) {
      			return arg;
      		}
      	}
      }
      
      /**
       * Set CSS on a given element
       * @param {Object} el
       * @param {Object} styles Style object with camel case property names
       */
      function css (el, styles) {
      	if (isIE) {
      		if (styles && styles.opacity !== UNDEFINED) {
      			styles.filter = 'alpha(opacity='+ (styles.opacity * 100) +')';
      		}
      	}
      	extend(el.style, styles);
      }
      
      /* *
       * Get CSS value on a given element
       * @param {Object} el DOM object
       * @param {String} styleProp Camel cased CSS propery
       * /
      function getStyle (el, styleProp) {
      	var ret,
      		CURRENT_STYLE = 'currentStyle',
      		GET_COMPUTED_STYLE = 'getComputedStyle';
      	if (el[CURRENT_STYLE]) {
      		ret = el[CURRENT_STYLE][styleProp];
      	} else if (win[GET_COMPUTED_STYLE]) {
      		ret = win[GET_COMPUTED_STYLE](el, null).getPropertyValue(hyphenate(styleProp));
      	}
      	return ret;
      }*/
      
      /**
       * Utility function to create element with attributes and styles
       * @param {Object} tag
       * @param {Object} attribs
       * @param {Object} styles
       * @param {Object} parent
       * @param {Object} nopad
       */
      function createElement (tag, attribs, styles, parent, nopad) {
      	var el = doc.createElement(tag);
      	if (attribs) {
      		extend(el, attribs);
      	}
      	if (nopad) {
      		css(el, {padding: 0, border: NONE, margin: 0});
      	}
      	if (styles) {
      		css(el, styles);
      	}
      	if (parent) {
      		parent.appendChild(el);
      	}	
      	return el;
      }
      
      /**
       * Extend a prototyped class by new members
       * @param {Object} parent
       * @param {Object} members
       */
      function extendClass(parent, members) {
      	var object = function(){};
      	object.prototype = new parent();
      	extend(object.prototype, members);
      	return object;
      }
      
      /**
       * Format a number and return a string based on input settings
       * @param {Number} number The input number to format
       * @param {Number} decimals The amount of decimals
       * @param {String} decPoint The decimal point, defaults to the one given in the lang options
       * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
       */
      function numberFormat (number, decimals, decPoint, thousandsSep) {
      	var lang = defaultOptions.lang,
      		// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
      		n = number, c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
      		d = decPoint === undefined ? lang.decimalPoint : decPoint,
      		t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "",
      		i = String(pInt(n = mathAbs(+n || 0).toFixed(c))),
      		j = i.length > 3 ? i.length % 3 : 0;
          
      	return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
      		(c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
      }
      
      /**
       * Based on http://www.php.net/manual/en/function.strftime.php 
       * @param {String} format
       * @param {Number} timestamp
       * @param {Boolean} capitalize
       */
      dateFormat = function (format, timestamp, capitalize) {
      	function pad (number) {
      		return number.toString().replace(/^([0-9])$/, '0$1');
      	}
      	
      	if (!defined(timestamp) || isNaN(timestamp)) {
      		return 'Invalid date';
      	}
      	format = pick(format, '%Y-%m-%d %H:%M:%S');
      	
      	var date = new Date(timestamp * timeFactor),
      		key, // used in for constuct below
      		// get the basic time values
      		hours = date[getHours](),
      		day = date[getDay](),
      		dayOfMonth = date[getDate](),
      		month = date[getMonth](),
      		fullYear = date[getFullYear](),
      		lang = defaultOptions.lang,
      		langWeekdays = lang.weekdays,
      		langMonths = lang.months,
      		/* // uncomment this and the 'W' format key below to enable week numbers
      		weekNumber = function() { 
      			var clone = new Date(date.valueOf()),
      				day = clone[getDay]() == 0 ? 7 : clone[getDay](),
      				dayNumber;
      			clone.setDate(clone[getDate]() + 4 - day);
      			dayNumber = mathFloor((clone.getTime() - new Date(clone[getFullYear](), 0, 1, -6)) / 86400000);
      			return 1 + mathFloor(dayNumber / 7);
      		},
      		*/
      		
      		// list all format keys
      		replacements = {
      
      			// Day
      			'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
      			'A': langWeekdays[day], // Long weekday, like 'Monday'
      			'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31 
      			'e': dayOfMonth, // Day of the month, 1 through 31 
      			
      			// Week (none implemented)
      			//'W': weekNumber(),
      			
      			// Month
      			'b': langMonths[month].substr(0, 3), // Short month, like 'Jan'
      			'B': langMonths[month], // Long month, like 'January'
      			'm': pad(month + 1), // Two digit month number, 01 through 12
      			
      			// Year
      			'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
      			'Y': fullYear, // Four digits year, like 2009
      			
      			// Time
      			'H': pad(hours), // Two digits hours in 24h format, 00 through 23
      			'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
      			'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
      			'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
      			'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
      			'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
      			'S': pad(date.getSeconds()) // Two digits seconds, 00 through  59
      			
      		};
      
      
      	// do the replaces
      	for (key in replacements) {
      		format = format.replace('%'+ key, replacements[key]);
      	}
      		
      	// Optionally capitalize the string and return
      	return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
      };
      
      /**
       * Loop up the node tree and add offsetWidth and offsetHeight to get the
       * total page offset for a given element. Used by Opera and iOS on hover and
       * all browsers on point click.
       * 
       * @param {Object} el
       * 
       */
      function getPosition (el) {
      	var p = { left: el.offsetLeft, top: el.offsetTop };
      	el = el.offsetParent;
      	while (el) {
      		p.left += el.offsetLeft;
      		p.top += el.offsetTop;
      		if (el !== doc.body && el !== doc.documentElement) {
      			p.left -= el.scrollLeft;
      			p.top -= el.scrollTop;
      		}
      		el = el.offsetParent;
      	}
      	return p;
      }
      
      /**
       * Helper class that contains variuos counters that are local to the chart.
       */
      function ChartCounters() {
      	this.color = 0;
      	this.symbol = 0;
      }
      
      ChartCounters.prototype =  {
      	/**
      	 * Wraps the color counter if it reaches the specified length.
      	 */
      	wrapColor: function(length) {
      		if (this.color >= length) {
      			this.color = 0;
      		}
      	},
      
      	/**
      	 * Wraps the symbol counter if it reaches the specified length.
      	 */
      	wrapSymbol: function(length) {
      		if (this.symbol >= length) {
      			this.symbol = 0;
      		}
      	}
      };
      
      /**
       * Set the global animation to either a given value, or fall back to the 
       * given chart's animation option
       * @param {Object} animation
       * @param {Object} chart
       */
      function setAnimation(animation, chart) {
      	globalAnimation = pick(animation, chart.animation);
      }
      
      /* 
       * Define the adapter for frameworks. If an external adapter is not defined, 
       * Highcharts reverts to the built-in jQuery adapter.
       */
      if (globalAdapter && globalAdapter.init) {
      	globalAdapter.init();
      } 
      if (!globalAdapter && win.jQuery) {
      	var jQ = jQuery;
      	
      	/**
      	 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
      	 * @param {Array} arr
      	 * @param {Function} fn
      	 */
      	each = function(arr, fn) {
      		var i = 0, 
      			len = arr.length;
      		for (; i < len; i++) {
      			if (fn.call(arr[i], arr[i], i, arr) === false) {
      				return i;
      			}
      		}
      	};
      	
      	/**
      	 * Filter an array
      	 */
      	grep = jQ.grep;
      	
      	/**
      	 * Map an array
      	 * @param {Array} arr
      	 * @param {Function} fn
      	 */
      	map = function(arr, fn){
      		//return jQuery.map(arr, fn);
      		var results = [],
      			i = 0, len = arr.length;
      		for (; i < len; i++) {
      			results[i] = fn.call(arr[i], arr[i], i, arr);
      		}
      		return results;
      		
      	};
      	
      	/**
      	 * Deep merge two objects and return a third object
      	 */
      	merge = function(){
      		var args = arguments;
      		return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
      	};
      	
      	/**
      	 * Add an event listener
      	 * @param {Object} el A HTML element or custom object
      	 * @param {String} event The event type
      	 * @param {Function} fn The event handler
      	 */
      	addEvent = function (el, event, fn){
      		jQ(el).bind(event, fn);
      	};
      	
      	/**
      	 * Remove event added with addEvent
      	 * @param {Object} el The object
      	 * @param {String} eventType The event type. Leave blank to remove all events.
      	 * @param {Function} handler The function to remove
      	 */
      	removeEvent = function(el, eventType, handler) {
      		// workaround for jQuery issue with unbinding custom events:
      		// http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
      		var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
      		if (doc[func] && !el[func]) {
      			el[func] = function() {};
      		}
      		
      		jQ(el).unbind(eventType, handler);
      	};
      	
      	/**
      	 * Fire an event on a custom object
      	 * @param {Object} el
      	 * @param {String} type
      	 * @param {Object} eventArguments
      	 * @param {Function} defaultFunction
      	 */
      	fireEvent = function(el, type, eventArguments, defaultFunction) {
      		var event = jQ.Event(type),
      			detachedType = 'detached'+ type;
      		extend(event, eventArguments);
      		
      		// Prevent jQuery from triggering the object method that is named the
      		// same as the event. For example, if the event is 'select', jQuery
      		// attempts calling el.select and it goes into a loop.
      		if (el[type]) {
      			el[detachedType] = el[type];
      			el[type] = null;	
      		}
      		
      		// trigger it
      		jQ(el).trigger(event);
      		
      		// attach the method
      		if (el[detachedType]) {
      			el[type] = el[detachedType];
      			el[detachedType] = null;
      		}
      		
      		if (defaultFunction && !event.isDefaultPrevented()) {
      			defaultFunction(event);
      		}	
      	};
      
      	/**
      	 * Animate a HTML element or SVG element wrapper
      	 * @param {Object} el
      	 * @param {Object} params
      	 * @param {Object} options jQuery-like animation options: duration, easing, callback
      	 */
      	animate = function (el, params, options) {
      		var $el = jQ(el);
      		if (params.d) {
      			el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
      			params.d = 1; // because in jQuery, animating to an array has a different meaning
      		}
      		
      		$el.stop();
      		$el.animate(params, options);
      		
      	};
      	/**
      	 * Stop running animation
      	 */
      	stop = function (el) {
      		jQ(el).stop();
      	};
      	
      	
      	// extend jQuery
      	jQ.extend( jQ.easing, {
      		easeOutQuad: function (x, t, b, c, d) {
      			return -c *(t/=d)*(t-2) + b;
      		}
      	});
      					
      	// extend the animate function to allow SVG animations
      	var oldStepDefault = jQuery.fx.step._default, 
      		oldCur = jQuery.fx.prototype.cur;
      	
      	// do the step
      	jQ.fx.step._default = function(fx){
      		var elem = fx.elem;
      		if (elem.attr) { // is SVG element wrapper
      			elem.attr(fx.prop, fx.now);
      		} else {
      			oldStepDefault.apply(this, arguments);
      		}
      	};
      	// animate paths
      	jQ.fx.step.d = function(fx) {
      		var elem = fx.elem;
      			
      		
      		// Normally start and end should be set in state == 0, but sometimes,
      		// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
      		// in these cases
      		if (!fx.started) {
      			var ends = pathAnim.init(elem, elem.d, elem.toD);
      			fx.start = ends[0];
      			fx.end = ends[1];
      			fx.started = true;
      		}
      		
      		
      		// interpolate each value of the path
      		elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
      	
      	};
      	// get the current value
      	jQ.fx.prototype.cur = function() {
      		var elem = this.elem,
      			r;
      		if (elem.attr) { // is SVG element wrapper
      			r = elem.attr(this.prop);
      		} else {
      			r = oldCur.apply(this, arguments);
      		}
      		return r;
      	};
      }
      
      
      /**
       * Add a global listener for mousemove events
       */
      /*addEvent(doc, 'mousemove', function(e) {
      	if (globalMouseMove) {
      		globalMouseMove(e);
      	}
      });*/
      
      /**
       * Path interpolation algorithm used across adapters
       */
      pathAnim = {
      	/**
      	 * Prepare start and end values so that the path can be animated one to one
      	 */
      	init: function(elem, fromD, toD) {
      		fromD = fromD || '';
      		var shift = elem.shift,
      			bezier = fromD.indexOf('C') > -1,
      			numParams = bezier ? 7 : 3,
      			endLength,
      			slice,
      			i,
      			start = fromD.split(' '),
      			end = [].concat(toD), // copy
      			startBaseLine,
      			endBaseLine,
      			sixify = function(arr) { // in splines make move points have six parameters like bezier curves
      				i = arr.length;
      				while (i--) {
      					if (arr[i] === M) {
      						arr.splice(i + 1, 0, arr[i+1], arr[i+2], arr[i+1], arr[i+2]);
      					}
      				}
      			};
      		
      		if (bezier) {
      			sixify(start);
      			sixify(end);
      		}
      		
      		// pull out the base lines before padding
      		if (elem.isArea) { 
      			startBaseLine = start.splice(start.length - 6, 6);
      			endBaseLine = end.splice(end.length - 6, 6);
      		}
      		
      		// if shifting points, prepend a dummy point to the end path
      		if (shift) {
      
      			end = [].concat(end).splice(0, numParams).concat(end);
      			elem.shift = false; // reset for following animations
      		}
      		
      		// copy and append last point until the length matches the end length
      		if (start.length) {
      			endLength = end.length;
      			while (start.length < endLength) {		
      				
      				//bezier && sixify(start); 
      				slice = [].concat(start).splice(start.length - numParams, numParams);
      				if (bezier) { // disable first control point
      					slice[numParams - 6] = slice[numParams - 2];
      					slice[numParams - 5] = slice[numParams - 1];
      				}
      				start = start.concat(slice);
      			}
      		}
      		
      		if (startBaseLine) { // append the base lines for areas
      			start = start.concat(startBaseLine);
      			end = end.concat(endBaseLine);
      		}
      		return [start, end];
      	},
      	
      	/**
      	 * Interpolate each value of the path and return the array
      	 */
      	step: function(start, end, pos, complete) {
      		var ret = [],
      			i = start.length,
      			startVal;
      			
      		if (pos === 1) { // land on the final path without adjustment points appended in the ends
      			ret = complete;
      			
      		} else if (i === end.length && pos < 1) {
      			while (i--) {
      				startVal = parseFloat(start[i]);
      				ret[i] = 
      					isNaN(startVal) ? // a letter instruction like M or L
      						start[i] :
      						pos * (parseFloat(end[i] - startVal)) + startVal;
      				
      			}
      		} else { // if animation is finished or length not matching, land on right value
      			ret = end;
      		}
      		return ret;
      	}
      };
      
      /**
       * Set the time methods globally based on the useUTC option. Time method can be either 
       * local time or UTC (default).
       */
      function setTimeMethods() {
      	var useUTC = defaultOptions.global.useUTC;
      	
      	makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
      		return new Date(
      			year, 
      			month, 
      			pick(date, 1), 
      			pick(hours, 0), 
      			pick(minutes, 0), 
      			pick(seconds, 0)
      		).getTime();
      	};
      	getMinutes = useUTC ? 'getUTCMinutes' : 'getMinutes';
      	getHours = useUTC ? 'getUTCHours' : 'getHours';
      	getDay = useUTC ? 'getUTCDay' : 'getDay';
      	getDate = useUTC ? 'getUTCDate' : 'getDate';
      	getMonth = useUTC ? 'getUTCMonth' : 'getMonth';
      	getFullYear = useUTC ? 'getUTCFullYear' : 'getFullYear';
      	setMinutes = useUTC ? 'setUTCMinutes' : 'setMinutes';
      	setHours = useUTC ? 'setUTCHours' : 'setHours';
      	setDate = useUTC ? 'setUTCDate' : 'setDate';
      	setMonth = useUTC ? 'setUTCMonth' : 'setMonth';
      	setFullYear = useUTC ? 'setUTCFullYear' : 'setFullYear';
      		
      }
      
      /**
       * Merge the default options with custom options and return the new options structure
       * @param {Object} options The new custom options
       */
      function setOptions(options) {
      	defaultOptions = merge(defaultOptions, options);
      	
      	// apply UTC
      	setTimeMethods();
      	
      	return defaultOptions;
      }
      
      /**
       * Get the updated default options. Merely exposing defaultOptions for outside modules
       * isn't enough because the setOptions method creates a new object.
       */
      function getOptions() {
      	return defaultOptions;
      }
      
      /**
       * Discard an element by moving it to the bin and delete
       * @param {Object} The HTML node to discard
       */
      function discardElement(element) {
      	// create a garbage bin element, not part of the DOM
      	if (!garbageBin) {
      		garbageBin = createElement(DIV);
      	}
      	
      	// move the node and empty bin
      	if (element) {
      		garbageBin.appendChild(element);
      	}
      	garbageBin.innerHTML = '';
      }
      
      /* ****************************************************************************
       * Handle the options                                                         *
       *****************************************************************************/
      var 
      
      defaultLabelOptions = {
      	enabled: true,
      	// rotation: 0,
      	align: 'center',
      	x: 0,
      	y: 15,
      	/*formatter: function() {
      		return this.value;
      	},*/
      	style: {
      		color: '#666',
      		fontSize: '11px',
      		lineHeight: '14px'
      	}
      };
      
      defaultOptions = {
      	colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE', 
      		'#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
      	symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
      	lang: {
      		loading: 'Loading...',
      		months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 
      				'August', 'September', 'October', 'November', 'December'],
      		weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      		decimalPoint: '.',
      		resetZoom: 'Reset zoom',
      		resetZoomTitle: 'Reset zoom level 1:1',
      		thousandsSep: ','
      	},
      	global: {
      		useUTC: true
      	},
      	chart: {
      		//animation: true,
      		//alignTicks: false,
      		//reflow: true,
      		//className: null,
      		//events: { load, selection },
      		//margin: [null],
      		//marginTop: null,
      		//marginRight: null,
      		//marginBottom: null,
      		//marginLeft: null,
      		borderColor: '#4572A7',
      		//borderWidth: 0,
      		borderRadius: 5,		
      		defaultSeriesType: 'line',
      		ignoreHiddenSeries: true,
      		//inverted: false,
      		//shadow: false,
      		spacingTop: 10,
      		spacingRight: 10,
      		spacingBottom: 15,
      		spacingLeft: 10,
      		style: {
      			fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
      			fontSize: '12px'
      		},
      		backgroundColor: '#FFFFFF',
      		//plotBackgroundColor: null,
      		plotBorderColor: '#C0C0C0'
      		//plotBorderWidth: 0,
      		//plotShadow: false,
      		//zoomType: ''
      	},
      	title: {
      		text: 'Chart title',
      		align: 'center',
      		// floating: false,
      		// margin: 15,
      		// x: 0,
      		// verticalAlign: 'top',
      		y: 15, // docs
      		style: {
      			color: '#3E576F',
      			fontSize: '16px'
      		}
      
      	},
      	subtitle: {
      		text: '',
      		align: 'center',
      		// floating: false
      		// x: 0,
      		// verticalAlign: 'top',
      		y: 30, // docs
      		style: {
      			color: '#6D869F'
      		}
      	},
      	
      	plotOptions: {
      		line: { // base series options
      			allowPointSelect: false,
      			showCheckbox: false,
      			animation: {
      				duration: 1000
      			},
      			// connectNulls: false, // docs
      			//cursor: 'default',
      			//dashStyle: null,
      			//enableMouseTracking: true,
      			events: {},
      			//legendIndex: 0, // docs (+ pie points)
      			lineWidth: 2,
      			shadow: true,
      			// stacking: null,
      			marker: { 
      				enabled: true,
      				//symbol: null, 
      				lineWidth: 0,
      				radius: 4,
      				lineColor: '#FFFFFF',
      				//fillColor: null, 
      				states: { // states for a single point
      					hover: {
      						//radius: base + 2
      					},
      					select: {
      						fillColor: '#FFFFFF',
      						lineColor: '#000000',
      						lineWidth: 2
      					}					
      				}
      			},
      			point: {
      				events: {}
      			},
      			dataLabels: merge(defaultLabelOptions, {
      				enabled: false,
      				y: -6,
      				formatter: function() {
      					return this.y;
      				}
      			}),
      			
      			//pointStart: 0,
      			//pointInterval: 1,
      			showInLegend: true,
      			states: { // states for the entire series
      				hover: {
      					//enabled: false,
      					//lineWidth: base + 1,
      					marker: {
      						// lineWidth: base + 1,
      						// radius: base + 1
      					}
      				},
      				select: {
      					marker: {}
      				}
      			},
      			stickyTracking: true
      			//zIndex: null
      		}
      	},
      	labels: {
      		//items: [],
      		style: {
      			//font: defaultFont,
      			position: ABSOLUTE,
      			color: '#3E576F'
      		}
      	},
      	legend: {
      		enabled: true,
      		align: 'center',
      		//floating: false,
      		layout: 'horizontal',
      		labelFormatter: function() {
      			return this.name;
      		},
      		// lineHeight: 16, // docs: deprecated
      		borderWidth: 1,
      		borderColor: '#909090',
      		borderRadius: 5,
      		// margin: 10,
      		// reversed: false,
      		shadow: false,
      		// backgroundColor: null,
      		style: {
      			padding: '5px'
      		},
      		itemStyle: {
      			cursor: 'pointer',
      			color: '#3E576F'
      		},
      		itemHoverStyle: {
      			cursor: 'pointer',
      			color: '#000000'
      		},
      		itemHiddenStyle: {
      			color: '#C0C0C0'
      		},
      		itemCheckboxStyle: {
      			position: ABSOLUTE,
      			width: '13px', // for IE precision
      			height: '13px'
      		},
      		// itemWidth: undefined,
      		symbolWidth: 16,
      		symbolPadding: 5,
      		verticalAlign: 'bottom',
      		// width: undefined,
      		x: 0, // docs
      		y: 0 // docs
      	},
      	
      	loading: {
      		hideDuration: 100,
      		labelStyle: {
      			fontWeight: 'bold',
      			position: RELATIVE,
      			top: '1em'
      		},
      		showDuration: 100,
      		style: {
      			position: ABSOLUTE,
      			backgroundColor: 'white',
      			opacity: 0.5,
      			textAlign: 'center'
      		}
      	},
      	
      	tooltip: {
      		enabled: true,
      		//crosshairs: null,
      		backgroundColor: 'rgba(255, 255, 255, .85)',
      		borderWidth: 2,
      		borderRadius: 5,
      		//formatter: defaultFormatter,
      		shadow: true,
      		//shared: false,
      		snap: hasTouch ? 25 : 10,
      		style: {
      			color: '#333333',
      			fontSize: '12px',
      			padding: '5px',
      			whiteSpace: 'nowrap'
      		}
      	},
      	
      	toolbar: {
      		itemStyle: {
      			color: '#4572A7',
      			cursor: 'pointer'
      		}
      	},
      	
      	credits: {
      		enabled: true,
      		text: 'Highcharts.com',
      		href: 'http://www.highcharts.com',
      		position: {
      			align: 'right',
      			x: -10,
      			verticalAlign: 'bottom',
      			y: -5
      		},
      		style: {
      			cursor: 'pointer',
      			color: '#909090',
      			fontSize: '10px'
      		}
      	}
      };
      
      // Axis defaults
      var defaultXAxisOptions =  {
      	// allowDecimals: null,
      	// alternateGridColor: null,
      	// categories: [],
      	dateTimeLabelFormats: {
      		second: '%H:%M:%S',
      		minute: '%H:%M',
      		hour: '%H:%M',
      		day: '%e. %b',
      		week: '%e. %b',
      		month: '%b \'%y',
      		year: '%Y'
      	},
      	endOnTick: false,
      	gridLineColor: '#C0C0C0',
      	// gridLineDashStyle: 'solid', // docs
      	// gridLineWidth: 0,
      	// reversed: false,
      	
      	labels: defaultLabelOptions,
      		// { step: null },
      	lineColor: '#C0D0E0',
      	lineWidth: 1,
      	//linkedTo: null,
      	max: null,
      	min: null,
      	minPadding: 0.01,
      	maxPadding: 0.01,
      	//maxZoom: null,
      	minorGridLineColor: '#E0E0E0',
      	// minorGridLineDashStyle: null,
      	minorGridLineWidth: 1,
      	minorTickColor: '#A0A0A0',
      	//minorTickInterval: null,
      	minorTickLength: 2,
      	minorTickPosition: 'outside', // inside or outside
      	//minorTickWidth: 0,
      	//opposite: false,
      	//offset: 0,
      	//plotBands: [{
      	//	events: {},
      	//	zIndex: 1,
      	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
      	//}],
      	//plotLines: [{
      	//	events: {}
      	//  dashStyle: {}
      	//	zIndex:
      	//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
      	//}],
      	//reversed: false,
      	// showFirstLabel: true,
      	// showLastLabel: false,
      	startOfWeek: 1, 
      	startOnTick: false,
      	tickColor: '#C0D0E0',
      	//tickInterval: null,
      	tickLength: 5,
      	tickmarkPlacement: 'between', // on or between
      	tickPixelInterval: 100,
      	tickPosition: 'outside',
      	tickWidth: 1,
      	title: {
      		//text: null,
      		align: 'middle', // low, middle or high
      		//margin: 0 for horizontal, 10 for vertical axes,
      		//rotation: 0,
      		//side: 'outside',
      		style: {
      			color: '#6D869F',
      			//font: defaultFont.replace('normal', 'bold')
      			fontWeight: 'bold'
      		}
      		//x: 0,
      		//y: 0
      	},
      	type: 'linear' // linear, logarithmic or datetime // docs
      },
      
      defaultYAxisOptions = merge(defaultXAxisOptions, {
      	endOnTick: true,
      	gridLineWidth: 1,
      	tickPixelInterval: 72,
      	showLastLabel: true,
      	labels: {
      		align: 'right',
      		x: -8,
      		y: 3
      	},
      	lineWidth: 0,
      	maxPadding: 0.05,
      	minPadding: 0.05,
      	startOnTick: true,
      	tickWidth: 0,
      	title: {
      		rotation: 270,
      		text: 'Y-values'
      	},
      	stackLabels: {
      		enabled: false,
      		//align: dynamic,
      		//y: dynamic,
      		//x: dynamic,
      		//verticalAlign: dynamic,
      		//textAlign: dynamic,
      		//rotation: 0,
      		formatter: function() {
      			return this.total;
      		},
      		style: defaultLabelOptions.style
      	}
      }),
      
      defaultLeftAxisOptions = {
      	labels: {
      		align: 'right',
      		x: -8,
      		y: null // docs
      	},
      	title: {
      		rotation: 270
      	}
      },
      defaultRightAxisOptions = {
      	labels: {
      		align: 'left',
      		x: 8,
      		y: null // docs
      	},
      	title: {
      		rotation: 90
      	}
      },
      defaultBottomAxisOptions = { // horizontal axis
      	labels: {
      		align: 'center',
      		x: 0,
      		y: 14
      		// staggerLines: null
      	},
      	title: {
      		rotation: 0
      	}
      },
      defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
      	labels: {
      		y: -5
      		// staggerLines: null
      	}
      });
      
      
       
      
      // Series defaults
      var defaultPlotOptions = defaultOptions.plotOptions, 
      	defaultSeriesOptions = defaultPlotOptions.line; 
      //defaultPlotOptions.line = merge(defaultSeriesOptions);
      defaultPlotOptions.spline = merge(defaultSeriesOptions);
      defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
      	lineWidth: 0,
      	states: {
      		hover: {
      			lineWidth: 0
      		}
      	}
      });
      defaultPlotOptions.area = merge(defaultSeriesOptions, {
      	// threshold: 0,
      	// lineColor: null, // overrides color, but lets fillColor be unaltered
      	// fillOpacity: 0.75,
      	// fillColor: null
      
      });
      defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
      defaultPlotOptions.column = merge(defaultSeriesOptions, {
      	borderColor: '#FFFFFF',
      	borderWidth: 1,
      	borderRadius: 0,
      	//colorByPoint: undefined,
      	groupPadding: 0.2,
      	marker: null, // point options are specified in the base options
      	pointPadding: 0.1,
      	//pointWidth: null,
      	minPointLength: 0, 
      	states: {
      		hover: {
      			brightness: 0.1,
      			shadow: false
      		},
      		select: {
      			color: '#C0C0C0',
      			borderColor: '#000000',
      			shadow: false
      		}
      	},
      	dataLabels: {
      		y: null,
      		verticalAlign: null
      	}
      });
      defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
      	dataLabels: {
      		align: 'left',
      		x: 5,
      		y: 0
      	}
      });
      defaultPlotOptions.pie = merge(defaultSeriesOptions, {
      	//dragType: '', // n/a
      	borderColor: '#FFFFFF',
      	borderWidth: 1,
      	center: ['50%', '50%'],
      	colorByPoint: true, // always true for pies
      	dataLabels: {
      		// align: null,
      		// connectorWidth: 1,
      		// connectorColor: '#606060',
      		// connectorPadding: 5,
      		distance: 30,
      		enabled: true,
      		formatter: function() {
      			return this.point.name;
      		},
      		y: 5
      	},
      	//innerSize: 0,
      	legendType: 'point',
      	marker: null, // point options are specified in the base options
      	size: '75%',
      	showInLegend: false,
      	slicedOffset: 10,
      	states: {
      		hover: {
      			brightness: 0.1,
      			shadow: false
      		}
      	}
      	
      });
      
      // set the default time methods
      setTimeMethods();
      
      
      /**
       * Handle color operations. The object methods are chainable.
       * @param {String} input The input color in either rbga or hex format
       */
      var Color = function(input) {
      	// declare variables
      	var rgba = [], result;
      	
      	/**
      	 * Parse the input color to rgba array
      	 * @param {String} input
      	 */
      	function init(input) {
      		
      		// rgba
      		result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input);
      		if (result) {
      			rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
      		}
      
      		// hex
      		else {
      			result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input);
      			if (result) {
      				rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
      			}
      		}
      	
      	}
      	/**
      	 * Return the color a specified format
      	 * @param {String} format
      	 */
      	function get(format) {
      		var ret;
      		
      		// it's NaN if gradient colors on a column chart
      		if (rgba && !isNaN(rgba[0])) {
      			if (format === 'rgb') {
      				ret = 'rgb('+ rgba[0] +','+ rgba[1] +','+ rgba[2] +')';
      			} else if (format === 'a') {
      				ret = rgba[3];
      			} else {
      				ret = 'rgba('+ rgba.join(',') +')';
      			}
      		} else {
      			ret = input;
      		}
      		return ret;
      	}
      	
      	/**
      	 * Brighten the color
      	 * @param {Number} alpha
      	 */
      	function brighten(alpha) {
      		if (isNumber(alpha) && alpha !== 0) {
      			var i;
      			for (i = 0; i < 3; i++) {
      				rgba[i] += pInt(alpha * 255);
      				
      				if (rgba[i] < 0) {
      					rgba[i] = 0;
      				}
      				if (rgba[i] > 255) {
      					rgba[i] = 255;
      				}
      			}
      		}
      		return this;
      	}
      	/**
      	 * Set the color's opacity to a given alpha value
      	 * @param {Number} alpha
      	 */
      	function setOpacity(alpha) {
      		rgba[3] = alpha;
      		return this;
      	}	
      	
      	// initialize: parse the input
      	init(input);
      	
      	// public methods
      	return {
      		get: get,
      		brighten: brighten,
      		setOpacity: setOpacity
      	};
      };
      
      /**
       * A wrapper object for SVG elements 
       */
      function SVGElement () {}
      
      SVGElement.prototype = {
      	/**
      	 * Initialize the SVG renderer
      	 * @param {Object} renderer
      	 * @param {String} nodeName
      	 */
      	init: function(renderer, nodeName) {
      		this.element = doc.createElementNS(SVG_NS, nodeName);
      		this.renderer = renderer;
      	},
      	/**
      	 * Animate a given attribute
      	 * @param {Object} params
      	 * @param {Number} options The same options as in jQuery animation
      	 * @param {Function} complete Function to perform at the end of animation
      	 */
      	animate: function(params, options, complete) {
      		var animOptions = pick(options, globalAnimation, true);
      		if (animOptions) {
      			animOptions = merge(animOptions);
      			if (complete) { // allows using a callback with the global animation without overwriting it
      				animOptions.complete = complete;
      			}
      			animate(this, params, animOptions);
      		} else {
      			this.attr(params);
      			if (complete) {
      				complete();
      			}
      		}
      	},
      	/**
      	 * Set or get a given attribute
      	 * @param {Object|String} hash
      	 * @param {Mixed|Undefined} val
      	 */
      	attr: function(hash, val) {
      		var key, 
      			value, 
      			i, 
      			child,
      			element = this.element,
      			nodeName = element.nodeName,
      			renderer = this.renderer,
      			skipAttr,
      			shadows = this.shadows,
      			hasSetSymbolSize,
      			ret = this;
      			
      		// single key-value pair
      		if (isString(hash) && defined(val)) {
      			key = hash;
      			hash = {};
      			hash[key] = val;
      		}
      		
      		// used as a getter: first argument is a string, second is undefined
      		if (isString(hash)) {
      			key = hash;
      			if (nodeName === 'circle') {
      				key = { x: 'cx', y: 'cy' }[key] || key;
      			} else if (key === 'strokeWidth') {
      				key = 'stroke-width';
      			}
      			ret = attr(element, key) || this[key] || 0;
      			
      			if (key !== 'd' && key !== 'visibility') { // 'd' is string in animation step
      				ret = parseFloat(ret);
      			}
      			
      		// setter
      		} else {
      		
      			for (key in hash) {
      				skipAttr = false; // reset
      				value = hash[key];
      				
      				// paths
      				if (key === 'd') {
      					if (value && value.join) { // join path
      						value = value.join(' ');
      					}					
      					if (/(NaN| {2}|^$)/.test(value)) {
      						value = 'M 0 0';
      					}
      					this.d = value; // shortcut for animations
      					
      				// update child tspans x values
      				} else if (key === 'x' && nodeName === 'text') { 
      					for (i = 0; i < element.childNodes.length; i++ ) {
      						child = element.childNodes[i];
      						// if the x values are equal, the tspan represents a linebreak
      						if (attr(child, 'x') === attr(element, 'x')) {
      							//child.setAttribute('x', value);
      							attr(child, 'x', value);
      						}
      					}
      					
      					if (this.rotation) {
      						attr(element, 'transform', 'rotate('+ this.rotation +' '+ value +' '+
      							pInt(hash.y || attr(element, 'y')) +')');
      					}
      					
      				// apply gradients
      				} else if (key === 'fill') {
      					value = renderer.color(value, element, key);
      				
      				// circle x and y
      				} else if (nodeName === 'circle' && (key === 'x' || key === 'y')) {
      					key = { x: 'cx', y: 'cy' }[key] || key;
      					
      				// translation and text rotation
      				} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'verticalAlign') {
      					this[key] = value;
      					this.updateTransform();
      					skipAttr = true;
      	
      				// apply opacity as subnode (required by legacy WebKit and Batik)
      				} else if (key === 'stroke') {
      					value = renderer.color(value, element, key);
      					
      				// emulate VML's dashstyle implementation
      				} else if (key === 'dashstyle') {
      					key = 'stroke-dasharray';
      					value = value && value.toLowerCase();
      					if (value === 'solid') {
      						value = NONE;
      					} else if (value) {
      						value = value
      							.replace('shortdashdotdot', '3,1,1,1,1,1,')
      							.replace('shortdashdot', '3,1,1,1')
      							.replace('shortdot', '1,1,')
      							.replace('shortdash', '3,1,')
      							.replace('longdash', '8,3,')
      							.replace(/dot/g, '1,3,')
      							.replace('dash', '4,3,')
      							.replace(/,$/, '')
      							.split(','); // ending comma
      						
      						i = value.length;
      						while (i--) {
      							value[i] = pInt(value[i]) * hash['stroke-width'];
      						}
      						
      						value = value.join(',');
      					}	
      					
      				// special
      				} else if (key === 'isTracker') {
      					this[key] = value;
      				
      				// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
      				// is unable to cast them. Test again with final IE9.
      				} else if (key === 'width') {
      					value = pInt(value);
      				
      				// Text alignment
      				} else if (key === 'align') {
      					key = 'text-anchor';
      					value = { left: 'start', center: 'middle', right: 'end' }[value];
      				}
      				
      				
      				
      				// jQuery animate changes case
      				if (key === 'strokeWidth') {
      					key = 'stroke-width';
      				}
      				
      				// Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)				
      				if (isWebKit && key === 'stroke-width' && value === 0) {
      					value = 0.000001;
      				}
      				
      				// symbols
      				if (this.symbolName && /^(x|y|r|start|end|innerR)/.test(key)) {
      					
      					
      					if (!hasSetSymbolSize) {
      						this.symbolAttr(hash);
      						hasSetSymbolSize = true;
      					}
      					skipAttr = true;
      				}
      				
      				// let the shadow follow the main element
      				if (shadows && /^(width|height|visibility|x|y|d)$/.test(key)) {
      					i = shadows.length;
      					while (i--) {
      						attr(shadows[i], key, value);
      					}					
      				}
      				
      				// validate heights
      				if ((key === 'width' || key === 'height') && nodeName === 'rect' && value < 0) {
      					value = 0;
      				}
      				
      				if (key === 'text') {
      					// only one node allowed
      					this.textStr = value;
      					if (this.added) {
      						renderer.buildText(this);
      					}
      				} else if (!skipAttr) {
      					//element.setAttribute(key, value);
      					attr(element, key, value);
      				}
      				
      			}
      			
      		}
      		return ret;
      	},
      	
      	/**
      	 * If one of the symbol size affecting parameters are changed,
      	 * check all the others only once for each call to an element's
      	 * .attr() method
      	 * @param {Object} hash
      	 */
      	symbolAttr: function(hash) {
      		var wrapper = this;
      		
      		each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR'], function(key) {
      			wrapper[key] = pick(hash[key], wrapper[key]);
      		});
      		
      		wrapper.attr({ 
      			d: wrapper.renderer.symbols[wrapper.symbolName](
      					mathRound(wrapper.x * 2) / 2, // Round to halves. Issue #274.
      					mathRound(wrapper.y * 2) / 2, 
      					wrapper.r, 
      			{
      				start: wrapper.start, 
      				end: wrapper.end,
      				width: wrapper.width, 
      				height: wrapper.height,
      				innerR: wrapper.innerR
      			})
      		});
      	},
      	
      	/**
      	 * Apply a clipping path to this object
      	 * @param {String} id
      	 */
      	clip: function(clipRect) {
      		return this.attr('clip-path', 'url('+ this.renderer.url +'#'+ clipRect.id +')');
      	},
      	
      	/**
      	 * Calculate the coordinates needed for drawing a rectangle crisply and return the
      	 * calculated attributes
      	 * @param {Number} strokeWidth
      	 * @param {Number} x
      	 * @param {Number} y
      	 * @param {Number} width
      	 * @param {Number} height
      	 */
      	crisp: function(strokeWidth, x, y, width, height) {
      		
      		var wrapper = this,
      			key,
      			attr = {},
      			values = {},
      			normalizer;
      			
      		strokeWidth = strokeWidth || wrapper.strokeWidth || 0;
      		normalizer = strokeWidth % 2 / 2;
      
      		// normalize for crisp edges
      		values.x = mathFloor(x || wrapper.x || 0) + normalizer;
      		values.y = mathFloor(y || wrapper.y || 0) + normalizer;
      		values.width = mathFloor((width || wrapper.width || 0) - 2 * normalizer);
      		values.height = mathFloor((height || wrapper.height || 0) - 2 * normalizer);
      		values.strokeWidth = strokeWidth;
      		
      		for (key in values) {
      			if (wrapper[key] !== values[key]) { // only set attribute if changed
      				wrapper[key] = attr[key] = values[key];
      			}
      		}
      		
      		return attr;
      	},
      	
      	/**
      	 * Set styles for the element
      	 * @param {Object} styles
      	 */
      	css: function(styles) {
      		var elemWrapper = this,
      			elem = elemWrapper.element,
      			textWidth = styles && styles.width && elem.nodeName === 'text',
      			n,
      			serializedCss = '',
      			hyphenate = function(a, b){ return '-'+ b.toLowerCase(); };
      			
      		// convert legacy
      		if (styles && styles.color) {
      			styles.fill = styles.color;
      		}
      
      		// Merge the new styles with the old ones
      		styles = extend(
      			elemWrapper.styles,
      			styles
      		);
      		
      		
      		// store object
      		elemWrapper.styles = styles;
      		
      		
      		// serialize and set style attribute
      		if (isIE && !hasSVG) { // legacy IE doesn't support setting style attribute
      			if (textWidth) {
      				delete styles.width;
      			} 
      			css(elemWrapper.element, styles);	
      		} else {
      			for (n in styles) {
      				serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':'+ styles[n] + ';';
      			}
      			elemWrapper.attr({
      				style: serializedCss
      			});
      		}	
      		
      		
      		// re-build text
      		if (textWidth && elemWrapper.added) {
      			elemWrapper.renderer.buildText(elemWrapper);
      		}
      		
      		return elemWrapper;
      	},
      	
      	/**
      	 * Add an event listener
      	 * @param {String} eventType
      	 * @param {Function} handler
      	 */
      	on: function(eventType, handler) {
      		var fn = handler;
      		// touch
      		if (hasTouch && eventType === 'click') {
      			eventType = 'touchstart';
      			fn = function(e) {
      				e.preventDefault();
      				handler();
      			};
      		}
      		// simplest possible event model for internal use
      		this.element['on'+ eventType] = fn;
      		return this;
      	},
      	
      	
      	/**
      	 * Move an object and its children by x and y values
      	 * @param {Number} x
      	 * @param {Number} y
      	 */
      	translate: function(x, y) {
      		return this.attr({
      			translateX: x,
      			translateY: y
      		});
      	},
      	
      	/**
      	 * Invert a group, rotate and flip
      	 */
      	invert: function() {
      		var wrapper = this;
      		wrapper.inverted = true;
      		wrapper.updateTransform();
      		return wrapper;
      	},
      	
      	/**
      	 * Private method to update the transform attribute based on internal 
      	 * properties
      	 */
      	updateTransform: function() {
      		var wrapper = this,
      			translateX = wrapper.translateX || 0,
      			translateY = wrapper.translateY || 0,
      			inverted = wrapper.inverted,
      			rotation = wrapper.rotation,
      			transform = [];
      			
      		// flipping affects translate as adjustment for flipping around the group's axis
      		if (inverted) {
      			translateX += wrapper.attr('width');
      			translateY += wrapper.attr('height');
      		}
      			
      		// apply translate
      		if (translateX || translateY) {
      			transform.push('translate('+ translateX +','+ translateY +')');
      		}
      		
      		// apply rotation
      		if (inverted) {
      			transform.push('rotate(90) scale(-1,1)');
      		} else if (rotation) { // text rotation
      			transform.push('rotate('+ rotation +' '+ wrapper.x +' '+ wrapper.y +')');
      		}
      		
      		if (transform.length) {
      			attr(wrapper.element, 'transform', transform.join(' '));
      		}
      	},
      	/**
      	 * Bring the element to the front
      	 */
      	toFront: function() {
      		var element = this.element;
      		element.parentNode.appendChild(element);
      		return this;
      	},
      	
      	
      	/**
      	 * Break down alignment options like align, verticalAlign, x and y 
      	 * to x and y relative to the chart.
      	 * 
      	 * @param {Object} alignOptions
      	 * @param {Boolean} alignByTranslate
      	 * @param {Object} box The box to align to, needs a width and height
      	 * 
      	 */
      	align: function(alignOptions, alignByTranslate, box) {
      		var elemWrapper = this;
      		
      		if (!alignOptions) { // called on resize
      			alignOptions = elemWrapper.alignOptions;
      			alignByTranslate = elemWrapper.alignByTranslate;
      		} else { // first call on instanciate
      			elemWrapper.alignOptions = alignOptions;
      			elemWrapper.alignByTranslate = alignByTranslate;
      			if (!box) { // boxes other than renderer handle this internally
      				elemWrapper.renderer.alignedObjects.push(elemWrapper);
      			}
      		}
      		
      		box = pick(box, elemWrapper.renderer);
      		
      		var align = alignOptions.align,
      			vAlign = alignOptions.verticalAlign,
      			x = (box.x || 0) + (alignOptions.x || 0), // default: left align
      			y = (box.y || 0) + (alignOptions.y || 0), // default: top align
      			attribs = {};
      			
      			
      		// align
      		if (/^(right|center)$/.test(align)) {
      			x += (box.width - (alignOptions.width || 0) ) /
      					{ right: 1, center: 2 }[align];
      		}
      		attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);
      		
      		
      		// vertical align
      		if (/^(bottom|middle)$/.test(vAlign)) {
      			y += (box.height - (alignOptions.height || 0)) /
      					({ bottom: 1, middle: 2 }[vAlign] || 1);
      			
      		}
      		attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);
      		
      		// animate only if already placed
      		elemWrapper[elemWrapper.placed ? 'animate' : 'attr'](attribs);
      		elemWrapper.placed = true;
      		elemWrapper.alignAttr = attribs;
      		
      		return elemWrapper;
      	},
      	
      	/**
      	 * Get the bounding box (width, height, x and y) for the element
      	 */
      	getBBox: function() {		
      		var bBox,
      			width,
      			height,
      			rotation = this.rotation,
      			rad = rotation * deg2rad;
      			
      		try { // fails in Firefox if the container has display: none
      			// use extend because IE9 is not allowed to change width and height in case 
      			// of rotation (below)
      			bBox = extend({}, this.element.getBBox());
      		} catch(e) {
      			bBox = { width: 0, height: 0 };
      		}
      		width = bBox.width;
      		height = bBox.height;
      			
      		// adjust for rotated text
      		if (rotation) {
      			bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
      			bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
      		}
      		
      		return bBox;
      	},
      	
      	/* *
      	 * Manually compute width and height of rotated text from non-rotated. Shared by SVG and VML
      	 * @param {Object} bBox
      	 * @param {number} rotation
      	 * /
      	rotateBBox: function(bBox, rotation) {
      		var rad = rotation * math.PI * 2 / 360, // radians
      			width = bBox.width,
      			height = bBox.height;
      			
      		
      	},*/
      	
      	/**
      	 * Show the element
      	 */
      	show: function() {
      		return this.attr({ visibility: VISIBLE });
      	},
      	
      	/**
      	 * Hide the element
      	 */
      	hide: function() {
      		return this.attr({ visibility: HIDDEN });
      	},
      	
      	/**
      	 * Add the element
      	 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
      	 *    to append the element to the renderer.box.
      	 */ 
      	add: function(parent) {
      	
      		var renderer = this.renderer,
      			parentWrapper = parent || renderer,
      			parentNode = parentWrapper.element || renderer.box,
      			childNodes = parentNode.childNodes,
      			element = this.element,
      			zIndex = attr(element, 'zIndex'),
      			otherElement,
      			otherZIndex,
      			i;
      			
      		// mark as inverted
      		this.parentInverted = parent && parent.inverted;
      		
      		// build formatted text
      		if (this.textStr !== undefined) {
      			renderer.buildText(this);
      		}
      		
      		// mark the container as having z indexed children
      		if (zIndex) {
      			parentWrapper.handleZ = true;
      			zIndex = pInt(zIndex);
      		}
      
      		// insert according to this and other elements' zIndex
      		if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
      			for (i = 0; i < childNodes.length; i++) {
      				otherElement = childNodes[i];
      				otherZIndex = attr(otherElement, 'zIndex');
      				if (otherElement !== element && (
      						// insert before the first element with a higher zIndex
      						pInt(otherZIndex) > zIndex || 
      						// if no zIndex given, insert before the first element with a zIndex
      						(!defined(zIndex) && defined(otherZIndex))  
      						
      						)) {
      					parentNode.insertBefore(element, otherElement);
      					return this;
      				}
      			}
      		}
      		
      		// default: append at the end
      		parentNode.appendChild(element);
      		
      		this.added = true;
      		
      		return this;
      	},
      
      	/**
      	 * Destroy the element and element wrapper
      	 */
      	destroy: function() {
      		var wrapper = this,
      			element = wrapper.element || {},
      			shadows = wrapper.shadows,
      			parentNode = element.parentNode,
      			key;
      		
      		// remove events
      		element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
      		stop(wrapper); // stop running animations
      		
      		// remove element
      		if (parentNode) {
      			parentNode.removeChild(element);
      		}
      		
      		// destroy shadows
      		if (shadows) {
      			each(shadows, function(shadow) {
      				parentNode = shadow.parentNode;
      				if (parentNode) { // the entire chart HTML can be overwritten
      					parentNode.removeChild(shadow);
      				}				
      			});
      		}
      		
      		// remove from alignObjects
      		erase(wrapper.renderer.alignedObjects, wrapper);
      				
      		for (key in wrapper) {
      			delete wrapper[key];
      		}
      		
      		return null;
      	},
      	
      	/**
      	 * Empty a group element
      	 */
      	empty: function() {
      		var element = this.element,
      			childNodes = element.childNodes,
      			i = childNodes.length;
      			
      		while (i--) {
      			element.removeChild(childNodes[i]);
      		}
      	},
      	
      	/**
      	 * Add a shadow to the element. Must be done after the element is added to the DOM
      	 * @param {Boolean} apply
      	 */
      	shadow: function(apply, group) {
      		var shadows = [],
      			i,
      			shadow,
      			element = this.element,
      			
      			// compensate for inverted plot area
      			transform = this.parentInverted ? '(-1,-1)' : '(1,1)';
      			
      		
      		if (apply) {
      			for (i = 1; i <= 3; i++) {
      				shadow = element.cloneNode(0);
      				attr(shadow, {
      					'isShadow': 'true',
      					'stroke': 'rgb(0, 0, 0)',
      					'stroke-opacity': 0.05 * i,
      					'stroke-width': 7 - 2 * i,
      					'transform': 'translate'+ transform,
      					'fill': NONE
      				});
      				
      				if (group) {
      					group.element.appendChild(shadow);
      				} else {
      					element.parentNode.insertBefore(shadow, element);
      				}
      				
      				shadows.push(shadow);
      			}
      			
      			this.shadows = shadows;
      		}
      		return this;
      	
      	}
      };
      
      /**
       * The default SVG renderer
       */
      var SVGRenderer = function() {
      	this.init.apply(this, arguments);
      };
      SVGRenderer.prototype = {
      	
      	Element: SVGElement,
      	
      	/**
      	 * Initialize the SVGRenderer
      	 * @param {Object} container
      	 * @param {Number} width
      	 * @param {Number} height
      	 * @param {Boolean} forExport
      	 */
      	init: function(container, width, height, forExport) {
      		var renderer = this,
      			loc = location,
      			boxWrapper;
      					
      		boxWrapper = renderer.createElement('svg')
      			.attr({
      				xmlns: SVG_NS,
      				version: '1.1'
      			});
      		container.appendChild(boxWrapper.element);
      		
      		// object properties
      		renderer.box = boxWrapper.element;
      		renderer.boxWrapper = boxWrapper;
      		renderer.alignedObjects = [];
      		renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, ''); // page url used for internal references
      		renderer.defs = this.createElement('defs').add();
      		renderer.forExport = forExport;
      		
      		renderer.setSize(width, height, false);
      		
      	},
      	
      	
      	/**
      	 * Create a wrapper for an SVG element
      	 * @param {Object} nodeName
      	 */
      	createElement: function(nodeName) {
      		var wrapper = new this.Element();
      		wrapper.init(this, nodeName);
      		return wrapper;
      	},
      	
      	
      	/** 
      	 * Parse a simple HTML string into SVG tspans
      	 * 
      	 * @param {Object} textNode The parent text SVG node
      	 */
      	buildText: function(wrapper) {
      		var textNode = wrapper.element,
      			lines = pick(wrapper.textStr, '').toString()
      				.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
      				.replace(/<(i|em)>/g, '<span style="font-style:italic">')
      				.replace(/<a/g, '<span')
      				.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
      				.split(/<br.*?>/g),
      			childNodes = textNode.childNodes,
      			styleRegex = /style="([^"]+)"/,
      			hrefRegex = /href="([^"]+)"/,
      			parentX = attr(textNode, 'x'),
      			textStyles = wrapper.styles,
      			reverse = isFirefox && textStyles && textStyles.HcDirection === 'rtl' && 
      				!this.forExport && pInt(userAgent.split('Firefox/')[1]) < 4, // issue #38
      			arr,
      			width = textStyles && pInt(textStyles.width),
      			textLineHeight = textStyles && textStyles.lineHeight,
      			lastLine,
      			GET_COMPUTED_STYLE = 'getComputedStyle',
      			i = childNodes.length;
      		
      		// remove old text
      		while (i--) {
      			textNode.removeChild(childNodes[i]);
      		}
      		
      		if (width && !wrapper.added) {
      			this.box.appendChild(textNode); // attach it to the DOM to read offset width
      		}
      		
      		each(lines, function(line, lineNo) {
      			var spans, spanNo = 0, lineHeight;
      			
      			line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
      			spans = line.split('|||');
      			
      			each(spans, function (span) {
      				if (span !== '' || spans.length === 1) {
      					var attributes = {},
      						tspan = doc.createElementNS(SVG_NS, 'tspan');
      					if (styleRegex.test(span)) {
      						attr(
      							tspan, 
      							'style', 
      							span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
      						);
      					}
      					if (hrefRegex.test(span)) {
      						attr(tspan, 'onclick', 'location.href=\"'+ span.match(hrefRegex)[1] +'\"');
      						css(tspan, { cursor: 'pointer' });
      					}
      					
      					span = (span.replace(/<(.|\n)*?>/g, '') || ' ')
      						.replace(/&lt;/g, '<')
      						.replace(/&gt;/g, '>');
      					
      					// issue #38 workaround.
      					if (reverse) {
      						arr = [];
      						i = span.length;
      						while (i--) {
      							arr.push(span.charAt(i));
      						}
      						span = arr.join('');
      					}
      					
      					// add the text node
      					tspan.appendChild(doc.createTextNode(span));
      					
      					if (!spanNo) { // first span in a line, align it to the left
      						attributes.x = parentX;
      					} else {
      						// Firefox ignores spaces at the front or end of the tspan
      						attributes.dx = 3; // space
      					}
      					
      					// first span on subsequent line, add the line height
      					if (!spanNo) {						
      						if (lineNo) {
      							
      							// allow getting the right offset height in exporting in IE
      							if (!hasSVG && wrapper.renderer.forExport) {
      								css(tspan, { display: 'block' });
      							}
      							
      							// Webkit and opera sometimes return 'normal' as the line height. In that
      							// case, webkit uses offsetHeight, while Opera falls back to 18
      							lineHeight = win[GET_COMPUTED_STYLE] &&
      								pInt(win[GET_COMPUTED_STYLE](lastLine, null).getPropertyValue('line-height'));
      							
      							if (!lineHeight || isNaN(lineHeight)) {
      								lineHeight = textLineHeight || lastLine.offsetHeight || 18;
      							}
      							attr(tspan, 'dy', lineHeight);
      						}
      						lastLine = tspan; // record for use in next line						
      					}
      					
      					// add attributes
      					attr(tspan, attributes);
      					
      					// append it
      					textNode.appendChild(tspan);
      					
      					spanNo++;
      					
      					// check width and apply soft breaks
      					if (width) {
      						var words = span.replace(/-/g, '- ').split(' '),
      							tooLong,
      							actualWidth,
      							rest = [];
      							
      						while (words.length || rest.length) {
      							actualWidth = textNode.getBBox().width;
      							tooLong = actualWidth > width;
      							if (!tooLong || words.length === 1) { // new line needed
      								words = rest;
      								rest = [];
      								if (words.length) {
      									tspan = doc.createElementNS(SVG_NS, 'tspan');
      									attr(tspan, {
      										dy: textLineHeight || 16,
      										x: parentX
      									});
      									textNode.appendChild(tspan);
      								
      									if (actualWidth > width) { // a single word is pressing it out
      										width = actualWidth;
      									}
      								}
      							} else { // append to existing line tspan
      								tspan.removeChild(tspan.firstChild);
      								rest.unshift(words.pop());							
      							}
      							if (words.length) {
      								tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
      							}
      						}
      					}
      				}
      			});
      		});
      		
      		
      	},
      	
      	/**
      	 * Make a straight line crisper by not spilling out to neighbour pixels
      	 * @param {Array} points
      	 * @param {Number} width 
      	 */
      	crispLine: function(points, width) {
      		// points format: [M, 0, 0, L, 100, 0]
      		// normalize to a crisp line
      		if (points[1] === points[4]) {
      			points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
      		}
      		if (points[2] === points[5]) {
      			points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
      		}
      		return points;
      	},
      	
      	
      	/**
      	 * Draw a path
      	 * @param {Array} path An SVG path in array form
      	 */
      	path: function (path) {
      		return this.createElement('path').attr({ 
      			d: path, 
      			fill: NONE
      		});
      	},
      	
      	/**
      	 * Draw and return an SVG circle
      	 * @param {Number} x The x position
      	 * @param {Number} y The y position
      	 * @param {Number} r The radius
      	 */
      	circle: function (x, y, r) {
      		var attr = isObject(x) ?
      			x :
      			{
      				x: x,
      				y: y,
      				r: r
      			};
      		
      		return this.createElement('circle').attr(attr);
      	},
      	
      	/**
      	 * Draw and return an arc
      	 * @param {Number} x X position
      	 * @param {Number} y Y position
      	 * @param {Number} r Radius
      	 * @param {Number} innerR Inner radius like used in donut charts
      	 * @param {Number} start Starting angle
      	 * @param {Number} end Ending angle
      	 */
      	arc: function (x, y, r, innerR, start, end) {
      		// arcs are defined as symbols for the ability to set 
      		// attributes in attr and animate
      		
      		if (isObject(x)) {
      			y = x.y;
      			r = x.r;
      			innerR = x.innerR;
      			start = x.start;
      			end = x.end;
      			x = x.x;
      		}
      		
      		return this.symbol('arc', x || 0, y || 0, r || 0, {
      			innerR: innerR || 0,
      			start: start || 0,
      			end: end || 0
      		});
      	},
      	
      	/**
      	 * Draw and return a rectangle
      	 * @param {Number} x Left position
      	 * @param {Number} y Top position
      	 * @param {Number} width
      	 * @param {Number} height
      	 * @param {Number} r Border corner radius
      	 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
      	 */
      	rect: function (x, y, width, height, r, strokeWidth) {
      		if (isObject(x)) {
      			y = x.y;
      			width = x.width;
      			height = x.height;
      			r = x.r;
      			strokeWidth = x.strokeWidth;
      			x = x.x;	
      		}
      		var wrapper = this.createElement('rect').attr({
      			rx: r,
      			ry: r,
      			fill: NONE
      		});
      		
      		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
      	},
      	
      	/**
      	 * Resize the box and re-align all aligned elements
      	 * @param {Object} width
      	 * @param {Object} height
      	 * @param {Boolean} animate
      	 * 
      	 */
      	setSize: function(width, height, animate) {
      		var renderer = this,
      			alignedObjects = renderer.alignedObjects,
      			i = alignedObjects.length;
      		
      		renderer.width = width;
      		renderer.height = height;
      		
      		renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
      			width: width,
      			height: height
      		});		
      		
      		while (i--) {
      			alignedObjects[i].align();
      		}
      	},
      	
      	/**
      	 * Create a group
      	 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
      	 *     This can be used for styling and scripting.
      	 */
      	g: function(name) {
      		return this.createElement('g').attr(
      			defined(name) && { 'class': PREFIX + name }
      		);
      	},
      	
      	/**
      	 * Display an image
      	 * @param {String} src
      	 * @param {Number} x
      	 * @param {Number} y
      	 * @param {Number} width
      	 * @param {Number} height
      	 */
      	image: function(src, x, y, width, height) {
      		var attribs = {
      				preserveAspectRatio: NONE	
      			},
      			elemWrapper;
      			
      		// optional properties
      		if (arguments.length > 1) {
      			extend(attribs, {
      				x: x,
      				y: y,
      				width: width,
      				height: height
      			});
      		}
      		
      		elemWrapper = this.createElement('image').attr(attribs);		
      		
      		// set the href in the xlink namespace
      		if (elemWrapper.element.setAttributeNS) {
      			elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink', 
      				'href', src);
      		} else {
      			// could be exporting in IE
      			// using href throws "not supported" in ie7 and under, requries regex shim to fix later
      			elemWrapper.element.setAttribute('hc-svg-href', src);
      		}
      			
      		return elemWrapper;					
      	},
      	
      	/**
      	 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
      	 * 
      	 * @param {Object} symbol
      	 * @param {Object} x
      	 * @param {Object} y
      	 * @param {Object} radius
      	 * @param {Object} options
      	 */
      	symbol: function(symbol, x, y, radius, options) {
      		
      		var obj,
      			
      			// get the symbol definition function
      			symbolFn = this.symbols[symbol],
      			
      			// check if there's a path defined for this symbol
      			path = symbolFn && symbolFn(
      				mathRound(x), 
      				mathRound(y),
      				radius, 
      				options
      			),
      			
      			imageRegex = /^url\((.*?)\)$/,
      			imageSrc,
      			imageSize;
      			
      		if (path) {
      		
      			obj = this.path(path);
      			// expando properties for use in animate and attr
      			extend(obj, {
      				symbolName: symbol,
      				x: x,
      				y: y,
      				r: radius
      			});
      			if (options) {
      				extend(obj, options);
      			}
      			
      			
      		// image symbols
      		} else if (imageRegex.test(symbol)) {
      			
      			var centerImage = function(img, size) {
      				img.attr({
      					width: size[0],
      					height: size[1]
      				}).translate(
      					-mathRound(size[0] / 2),
      					-mathRound(size[1] / 2)
      				);
      			};
      			
      			imageSrc = symbol.match(imageRegex)[1];
      			imageSize = symbolSizes[imageSrc];
      			
      			// create the image synchronously, add attribs async
      			obj = this.image(imageSrc)
      				.attr({
      					x: x,
      					y: y
      				});
      
      			if (imageSize) {
      				centerImage(obj, imageSize);
      			} else {
      				// initialize image to be 0 size so export will still function if there's no cached sizes
      				obj.attr({ width: 0, height: 0 });
      
      				// create a dummy JavaScript image to get the width and height  
      				createElement('img', {
      					onload: function() {
      						var img = this;
      						centerImage(obj, symbolSizes[imageSrc] = [img.width, img.height]);
      					},
      					src: imageSrc
      				});
      			}
      				
      		// default circles
      		} else {
      			obj = this.circle(x, y, radius);
      		}
      		
      		return obj;
      	},
      	
      	/**
      	 * An extendable collection of functions for defining symbol paths.
      	 */
      	symbols: {
      		'square': function (x, y, radius) {
      			var len = 0.707 * radius;
      			return [
      				M, x-len, y-len,
      				L, x+len, y-len,
      				x+len, y+len,
      				x-len, y+len,
      				'Z'
      			];
      		},
      			
      		'triangle': function (x, y, radius) {
      			return [
      				M, x, y-1.33 * radius,
      				L, x+radius, y + 0.67 * radius,
      				x-radius, y + 0.67 * radius,
      				'Z'
      			];
      		},
      			
      		'triangle-down': function (x, y, radius) {
      			return [
      				M, x, y + 1.33 * radius,
      				L, x-radius, y-0.67 * radius,
      				x+radius, y-0.67 * radius,
      				'Z'
      			];
      		},
      		'diamond': function (x, y, radius) {
      			return [
      				M, x, y-radius,
      				L, x+radius, y,
      				x, y+radius,
      				x-radius, y,
      				'Z'
      			];
      		},
      		'arc': function (x, y, radius, options) {
      			var start = options.start,
      				end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
      				innerRadius = options.innerR,
      				cosStart = mathCos(start),
      				sinStart = mathSin(start),
      				cosEnd = mathCos(end),
      				sinEnd = mathSin(end),
      				longArc = options.end - start < mathPI ? 0 : 1;
      				
      			return [
      				M,
      				x + radius * cosStart,
      				y + radius * sinStart,
      				'A', // arcTo
      				radius, // x radius
      				radius, // y radius
      				0, // slanting
      				longArc, // long or short arc
      				1, // clockwise
      				x + radius * cosEnd,
      				y + radius * sinEnd,
      				L,				
      				x + innerRadius * cosEnd, 
      				y + innerRadius * sinEnd,
      				'A', // arcTo
      				innerRadius, // x radius
      				innerRadius, // y radius
      				0, // slanting
      				longArc, // long or short arc
      				0, // clockwise
      				x + innerRadius * cosStart,
      				y + innerRadius * sinStart,
      				
      				'Z' // close
      			];
      		}
      	},
      	
      	/**
      	 * Define a clipping rectangle
      	 * @param {String} id
      	 * @param {Number} x
      	 * @param {Number} y
      	 * @param {Number} width
      	 * @param {Number} height
      	 */
      	clipRect: function (x, y, width, height) {
      		var wrapper,
      			id = PREFIX + idCounter++,
      			
      			clipPath = this.createElement('clipPath').attr({
      				id: id
      			}).add(this.defs);
      		
      		wrapper = this.rect(x, y, width, height, 0).add(clipPath);
      		wrapper.id = id;
      		
      		return wrapper;
      	},
      	
      	
      	/**
      	 * Take a color and return it if it's a string, make it a gradient if it's a
      	 * gradient configuration object
      	 * 
      	 * @param {Object} color The color or config object
      	 */
      	color: function(color, elem, prop) {
      		var colorObject,
      			regexRgba = /^rgba/;
      		if (color && color.linearGradient) {
      			var renderer = this,
      				strLinearGradient = 'linearGradient',
      				linearGradient = color[strLinearGradient],
      				id = PREFIX + idCounter++,
      				gradientObject,
      				stopColor,
      				stopOpacity;
      			gradientObject = renderer.createElement(strLinearGradient).attr({
      				id: id,
      				gradientUnits: 'userSpaceOnUse',
      				x1: linearGradient[0],
      				y1: linearGradient[1],
      				x2: linearGradient[2],
      				y2: linearGradient[3]
      			}).add(renderer.defs);
      			
      			each(color.stops, function(stop) {
      				if (regexRgba.test(stop[1])) {
      					colorObject = Color(stop[1]);
      					stopColor = colorObject.get('rgb');
      					stopOpacity = colorObject.get('a');
      				} else {
      					stopColor = stop[1];
      					stopOpacity = 1;
      				}
      				renderer.createElement('stop').attr({
      					offset: stop[0],
      					'stop-color': stopColor,
      					'stop-opacity': stopOpacity
      				}).add(gradientObject);
      			});
      			
      			return 'url('+ this.url +'#'+ id +')';
      			
      		// Webkit and Batik can't show rgba.
      		} else if (regexRgba.test(color)) {
      			colorObject = Color(color);
      			attr(elem, prop +'-opacity', colorObject.get('a'));
      			
      			return colorObject.get('rgb');
      			
      			
      		} else {
      			return color;
      		}
      		
      	},
      	
      		
      	/**
      	 * Add text to the SVG object
      	 * @param {String} str
      	 * @param {Number} x Left position
      	 * @param {Number} y Top position
      	 */
      	text: function(str, x, y) {
      		
      		// declare variables
      		var defaultChartStyle = defaultOptions.chart.style,
      			wrapper;
      	
      		x = mathRound(pick(x, 0));
      		y = mathRound(pick(y, 0));
      		
      		wrapper = this.createElement('text')
      			.attr({
      				x: x,
      				y: y,
      				text: str	
      			})
      			.css({
      				fontFamily: defaultChartStyle.fontFamily,
      				fontSize: defaultChartStyle.fontSize
      			});
      			
      		wrapper.x = x;
      		wrapper.y = y;
      		return wrapper;
      	}
      }; // end SVGRenderer
      
      // general renderer
      Renderer = SVGRenderer;
      
      
      
      /* **************************************************************************** 
       *                                                                            * 
       * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
       *                                                                            *
       * For applications and websites that don't need IE support, like platform    *
       * targeted mobile apps and web apps, this code can be removed.               *
       *                                                                            *
       *****************************************************************************/
      var VMLRenderer;
      if (!hasSVG) {
      
      /**
       * The VML element wrapper.
       */
      var VMLElement = extendClass( SVGElement, {
      	
      	/**
      	 * Initialize a new VML element wrapper. It builds the markup as a string
      	 * to minimize DOM traffic.
      	 * @param {Object} renderer
      	 * @param {Object} nodeName
      	 */
      	init: function(renderer, nodeName) {
      		var markup =  ['<', nodeName, ' filled="f" stroked="f"'],
      			style = ['position: ', ABSOLUTE, ';'];
      		
      		// divs and shapes need size
      		if (nodeName === 'shape' || nodeName === DIV) {
      			style.push('left:0;top:0;width:10px;height:10px;');
      		}
      		if (docMode8) {
      			style.push('visibility: ', nodeName === DIV ? HIDDEN : VISIBLE);
      		}
      		
      		markup.push(' style="', style.join(''), '"/>');
      		
      		// create element with default attributes and style
      		if (nodeName) {
      			markup = nodeName === DIV || nodeName === 'span' || nodeName === 'img' ? 
      				markup.join('')
      				: renderer.prepVML(markup);
      			this.element = createElement(markup);
      		}
      		
      		this.renderer = renderer;
      	},
      	
      	/**
      	 * Add the node to the given parent
      	 * @param {Object} parent
      	 */
      	add: function(parent) {
      		var wrapper = this,
      			renderer = wrapper.renderer,
      			element = wrapper.element,
      			box = renderer.box,
      			inverted = parent && parent.inverted,
      		
      			// get the parent node
      			parentNode = parent ? 
      				parent.element || parent : 
      				box;
      			
      			
      		// if the parent group is inverted, apply inversion on all children
      		if (inverted) { // only on groups
      			renderer.invertChild(element, parentNode);			
      		}
      		
      		// issue #140 workaround - related to #61 and #74
      		if (docMode8 && parentNode.gVis === HIDDEN) {
      			css(element, { visibility: HIDDEN });
      		}
      		
      		// append it
      		parentNode.appendChild(element);
      		
      		// align text after adding to be able to read offset
      		wrapper.added = true;
      		if (wrapper.alignOnAdd) {
      			wrapper.updateTransform();
      		}		
      		
      		return wrapper;
      	},
      	
      	/**
      	 * Get or set attributes
      	 */
      	attr: function(hash, val) {
      		var key, 
      			value, 
      			i, 
      			element = this.element || {},
      			elemStyle = element.style,
      			nodeName = element.nodeName,
      			renderer = this.renderer,
      			symbolName = this.symbolName,
      			childNodes,
      			hasSetSymbolSize,
      			shadows = this.shadows,
      			skipAttr,
      			ret = this;
      			
      		// single key-value pair
      		if (isString(hash) && defined(val)) {
      			key = hash;
      			hash = {};
      			hash[key] = val;
      		}
      		
      		// used as a getter, val is undefined
      		if (isString(hash)) {
      			key = hash;
      			if (key === 'strokeWidth' || key === 'stroke-width') {
      				ret = this.strokeweight;
      			} else {
      				ret = this[key];
      			}
      			
      		// setter
      		} else {		
      			for (key in hash) {
      				value = hash[key];
      				skipAttr = false;
      				
      				// prepare paths
      				// symbols
      				if (symbolName && /^(x|y|r|start|end|width|height|innerR)/.test(key)) {
      					// if one of the symbol size affecting parameters are changed,
      					// check all the others only once for each call to an element's
      					// .attr() method
      					if (!hasSetSymbolSize) {
      						this.symbolAttr(hash);						
      					
      						hasSetSymbolSize = true;
      					} 
      					
      					skipAttr = true;
      					
      				} else if (key === 'd') {
      					value = value || [];
      					this.d = value.join(' '); // used in getter for animation
      					
      					// convert paths 
      					i = value.length;
      					var convertedPath = [];
      					while (i--) {					
      						
      						// Multiply by 10 to allow subpixel precision.
      						// Substracting half a pixel seems to make the coordinates
      						// align with SVG, but this hasn't been tested thoroughly
      						if (isNumber(value[i])) {
      							convertedPath[i] = mathRound(value[i] * 10) - 5;
      						}
      						// close the path
      						else if (value[i] === 'Z') {
      							convertedPath[i] = 'x';
      						} 
      						else {
      							convertedPath[i] = value[i];
      						}
      						
      					}
      					value = convertedPath.join(' ') || 'x';	
      					element.path = value;
      			
      					// update shadows
      					if (shadows) {
      						i = shadows.length;
      						while (i--) {
      							shadows[i].path = value;
      						}
      					}
      					skipAttr = true;
      	
      				// directly mapped to css
      				} else if (key === 'zIndex' || key === 'visibility') {
      					
      					// issue 61 workaround
      					if (docMode8 && key === 'visibility' && nodeName === 'DIV') {
      						element.gVis = value;
      						childNodes = element.childNodes;
      						i = childNodes.length;
      						while (i--) {
      							css(childNodes[i], { visibility: value });
      						}
      						if (value === VISIBLE) { // issue 74
      							value = null;
      						}
      					}
      					
      					if (value) {
      						elemStyle[key] = value;
      					}
      					
      					
      					
      					skipAttr = true;
      				
      				// width and height
      				} else if (/^(width|height)$/.test(key)) {
      					
      										
      					// clipping rectangle special
      					if (this.updateClipping) {
      						this[key] = value;
      						this.updateClipping();
      						
      					} else {
      						// normal
      						elemStyle[key] = value;
      					}
      					
      					skipAttr = true;
      					
      				// x and y 
      				} else if (/^(x|y)$/.test(key)) {
      
      					this[key] = value; // used in getter
      					
      					if (element.tagName === 'SPAN') {
      						this.updateTransform();
      					
      					} else {
      						elemStyle[{ x: 'left', y: 'top' }[key]] = value;
      					}
      					
      				// class name
      				} else if (key === 'class') {
      					// IE8 Standards mode has problems retrieving the className
      					element.className = value;
      			
      				// stroke
      				} else if (key === 'stroke') {
      					
      					value = renderer.color(value, element, key);				
      						
      					key = 'strokecolor';
      					
      				// stroke width
      				} else if (key === 'stroke-width' || key === 'strokeWidth') {
      					element.stroked = value ? true : false;
      					key = 'strokeweight';
      					this[key] = value; // used in getter, issue #113
      					if (isNumber(value)) {
      						value += PX;
      					}
      					
      				// dashStyle					 
      				} else if (key === 'dashstyle') {
      					var strokeElem = element.getElementsByTagName('stroke')[0] ||
      						createElement(renderer.prepVML(['<stroke/>']), null, null, element);
      					strokeElem[key] = value || 'solid';
      					this.dashstyle = value; /* because changing stroke-width will change the dash length
      						and cause an epileptic effect */ 
      					skipAttr = true;
      					
      				// fill
      				} else if (key === 'fill') {
      					
      					if (nodeName === 'SPAN') { // text color
      						elemStyle.color = value;
      					} else {
      						element.filled = value !== NONE ? true : false;
      						
      						value = renderer.color(value, element, key);
      						
      						key = 'fillcolor';
      					}
      				
      				// translation for animation
      				} else if (key === 'translateX' || key === 'translateY' || key === 'rotation' || key === 'align') {
      					if (key === 'align') {
      						key = 'textAlign';
      					}
      					this[key] = value;
      					this.updateTransform();
      					
      					skipAttr = true;
      				}
      				
      				// text for rotated and non-rotated elements
      				else if (key === 'text') {
      					this.bBox = null;
      					element.innerHTML = value;
      					skipAttr = true;
      				} 
      				
      					
      				// let the shadow follow the main element
      				if (shadows && key === 'visibility') {
      					i = shadows.length;
      					while (i--) {
      						shadows[i].style[key] = value;
      					}
      				}
      				
      				
      				
      				if (!skipAttr) {
      					if (docMode8) { // IE8 setAttribute bug
      						element[key] = value;
      					} else {
      						attr(element, key, value);
      					}
      				}
      			}			
      		}
      		return ret;
      	},
      	
      	/**
      	 * Set the element's clipping to a predefined rectangle
      	 * 
      	 * @param {String} id The id of the clip rectangle
      	 */
      	clip: function(clipRect) {
      		var wrapper = this,
      			clipMembers = clipRect.members;
      			
      		clipMembers.push(wrapper);
      		wrapper.destroyClip = function() {
      			erase(clipMembers, wrapper);
      		};
      		return wrapper.css(clipRect.getCSS(wrapper.inverted));
      	},
      	
      	/**
      	 * Set styles for the element
      	 * @param {Object} styles
      	 */
      	css: function(styles) {
      		var wrapper = this,
      			element = wrapper.element,
      			textWidth = styles && element.tagName === 'SPAN' && styles.width;
      		
      		/*if (textWidth) {
      			extend(styles, {
      				display: 'block',
      				whiteSpace: 'normal'
      			});	
      		}*/
      		if (textWidth) {
      			delete styles.width;
      			wrapper.textWidth = textWidth;
      			wrapper.updateTransform();	
      		}
      		
      		wrapper.styles = extend(wrapper.styles, styles);
      		css(wrapper.element, styles);
      		
      		return wrapper;
      	},
      	
      	/**
      	 * Extend element.destroy by removing it from the clip members array
      	 */
      	destroy: function() {
      		var wrapper = this;
      		
      		if (wrapper.destroyClip) {
      			wrapper.destroyClip();
      		}
      		
      		SVGElement.prototype.destroy.apply(wrapper);
      	},
      	
      	/**
      	 * Remove all child nodes of a group, except the v:group element
      	 */
      	empty: function() {
      		var element = this.element,
      			childNodes = element.childNodes,
      			i = childNodes.length,
      			node;
      			
      		while (i--) {
      			node = childNodes[i];
      			node.parentNode.removeChild(node);
      		}
      	},
      	
      	/**
      	 * VML override for calculating the bounding box based on offsets
      	 * 
      	 * @return {Object} A hash containing values for x, y, width and height
      	 */
      	
      	getBBox: function() {
      		var wrapper = this,
      			element = wrapper.element,
      			bBox = wrapper.bBox;
      		
      		if (!bBox) {
      			// faking getBBox in exported SVG in legacy IE
      			if (element.nodeName === 'text') {
      				element.style.position = ABSOLUTE;
      			}
      			
      			bBox = wrapper.bBox = {
      				x: element.offsetLeft,
      				y: element.offsetTop,
      				width: element.offsetWidth,
      				height: element.offsetHeight
      			};
      		}
      		return bBox;
      					
      	},
      	
      	/**
      	 * Add an event listener. VML override for normalizing event parameters.
      	 * @param {String} eventType
      	 * @param {Function} handler
      	 */
      	on: function(eventType, handler) {
      		// simplest possible event model for internal use
      		this.element['on'+ eventType] = function() {
      			var evt = win.event;
      			evt.target = evt.srcElement;
      			handler(evt);
      		};
      		return this;
      	},
      	
      	
      	/**
      	 * VML override private method to update elements based on internal 
      	 * properties based on SVG transform
      	 */
      	updateTransform: function(hash) { 
      		// aligning non added elements is expensive
      		if (!this.added) {
      			this.alignOnAdd = true;
      			return;
      		}
      		
      		var wrapper = this,
      			elem = wrapper.element,
      			translateX = wrapper.translateX || 0,
      			translateY = wrapper.translateY || 0,
      			x = wrapper.x || 0,
      			y = wrapper.y || 0,
      			align = wrapper.textAlign || 'left',
      			alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
      			nonLeft = align && align !== 'left';
      		
      		// apply translate
      		if (translateX || translateY) {
      			wrapper.css({
      				marginLeft: translateX,
      				marginTop: translateY
      			});
      		}
      		
      		// apply inversion
      		if (wrapper.inverted) { // wrapper is a group
      			each(elem.childNodes, function(child) {
      				wrapper.renderer.invertChild(child, elem);
      			});
      		}
      		
      		if (elem.tagName === 'SPAN') {
      			
      			var width, height,
      				rotation = wrapper.rotation,
      				lineHeight,
      				radians = 0,
      				costheta = 1,
      				sintheta = 0,
      				quad,
      				textWidth = pInt(wrapper.textWidth),
      				xCorr = wrapper.xCorr || 0,
      				yCorr = wrapper.yCorr || 0,
      				currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');
      				
      			if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed
      				
      				if (defined(rotation)) {
      					radians = rotation * deg2rad; // deg to rad
      					costheta = mathCos(radians);
      					sintheta = mathSin(radians);				
      					 
      					// Adjust for alignment and rotation.
      					// Test case: http://highcharts.com/tests/?file=text-rotation
      					css(elem, {
      						filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta, 
      							', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta, 
      							', sizingMethod=\'auto expand\')'].join('') : NONE
      					});
      				}
      				
      				width = elem.offsetWidth;
      				height = elem.offsetHeight;
      				
      				// update textWidth
      				if (width > textWidth) {
      					css(elem, {
      						width: textWidth +PX,
      						display: 'block',
      						whiteSpace: 'normal'
      					});
      					width = textWidth;
      				}
      				
      				// correct x and y
      				lineHeight = mathRound((pInt(elem.style.fontSize) || 12) * 1.2);
      				xCorr = costheta < 0 && -width;
      				yCorr = sintheta < 0 && -height;
      				
      				// correct for lineHeight and corners spilling out after rotation
      				quad = costheta * sintheta < 0;
      				xCorr += sintheta * lineHeight * (quad ? 1 - alignCorrection : alignCorrection);
      				yCorr -= costheta * lineHeight * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
      				
      				// correct for the length/height of the text
      				if (nonLeft) {
      					xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
      					if (rotation) {
      						yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
      					}
      					css(elem, {
      						textAlign: align
      					});
      				}
      				
      				// record correction
      				wrapper.xCorr = xCorr;
      				wrapper.yCorr = yCorr; 
      			}
      			
      			// apply position with correction
      			css(elem, {
      				left: x + xCorr,
      				top: y + yCorr
      			});
      			
      			// record current text transform
      			wrapper.cTT = currentTextTransform;
      		}
      	},
      	
      	/**
      	 * Apply a drop shadow by copying elements and giving them different strokes 
      	 * @param {Boolean} apply
      	 */
      	shadow: function(apply, group) {
      		var shadows = [],
      			i,
      			element = this.element,
      			renderer = this.renderer,
      			shadow,
      			elemStyle = element.style,
      			markup,
      			path = element.path;
      			
      		// some times empty paths are not strings
      		if (path && typeof path.value !== 'string') {
      			path = 'x';
      		}
      			
      		if (apply) {
      			for (i = 1; i <= 3; i++) {
      				markup = ['<shape isShadow="true" strokeweight="', ( 7 - 2 * i ) ,
      					'" filled="false" path="', path,
      					'" coordsize="100,100" style="', element.style.cssText, '" />'];
      				shadow = createElement(renderer.prepVML(markup),
      					null, {
      						left: pInt(elemStyle.left) + 1,
      						top: pInt(elemStyle.top) + 1
      					}
      				);
      				
      				// apply the opacity
      				markup = ['<stroke color="black" opacity="', (0.05 * i), '"/>'];
      				createElement(renderer.prepVML(markup), null, null, shadow);				
      				
      				
      				// insert it
      				if (group) {
      					group.element.appendChild(shadow);
      				} else {
      					element.parentNode.insertBefore(shadow, element);
      				}
      				
      				// record it
      				shadows.push(shadow);				
      				
      			}
      			
      			this.shadows = shadows;
      		}
      		return this;
      	
      	}
      });
      	
      /**
       * The VML renderer
       */
      VMLRenderer = function() {
      	this.init.apply(this, arguments);
      };
      VMLRenderer.prototype = merge( SVGRenderer.prototype, { // inherit SVGRenderer
      	
      	Element: VMLElement,
      	isIE8: userAgent.indexOf('MSIE 8.0') > -1,
      	
      
      	/**
      	 * Initialize the VMLRenderer
      	 * @param {Object} container
      	 * @param {Number} width
      	 * @param {Number} height
      	 */
      	init: function(container, width, height) {
      		var renderer = this,
      			boxWrapper;
      
      		renderer.alignedObjects = [];
      		
      		boxWrapper = renderer.createElement(DIV);
      		container.appendChild(boxWrapper.element);
      		
      		
      		// generate the containing box
      		renderer.box = boxWrapper.element;
      		renderer.boxWrapper = boxWrapper;
      		
      		
      		renderer.setSize(width, height, false);
      		
      		// The only way to make IE6 and IE7 print is to use a global namespace. However,
      		// with IE8 the only way to make the dynamic shapes visible in screen and print mode
      		// seems to be to add the xmlns attribute and the behaviour style inline. 
      		if (!doc.namespaces.hcv) {			
      			
      			doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');
      			
      			// setup default css
      			doc.createStyleSheet().cssText = 
      				'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke'+
      				'{ behavior:url(#default#VML); display: inline-block; } ';
      			
      		}	
      	},
      	
      	/**
      	 * Define a clipping rectangle. In VML it is accomplished by storing the values
      	 * for setting the CSS style to all associated members.
      	 * 
      	 * @param {Number} x
      	 * @param {Number} y
      	 * @param {Number} width
      	 * @param {Number} height
      	 */
      	clipRect: function (x, y, width, height) {
      				
      		// create a dummy element
      		var clipRect = this.createElement();
      		
      		// mimic a rectangle with its style object for automatic updating in attr
      		return extend(clipRect, {
      			members: [],
      			left: x,
      			top: y,
      			width: width,
      			height: height,
      			getCSS: function(inverted) {
      				var rect = this,//clipRect.element.style,
      					top = rect.top,
      					left = rect.left,
      					right = left + rect.width,
      					bottom = top + rect.height,
      					ret = {
      						clip: 'rect('+ 
      							mathRound(inverted ? left : top) + 'px,'+ 
      							mathRound(inverted ? bottom : right) + 'px,'+ 
      							mathRound(inverted ? right : bottom) + 'px,'+ 
      							mathRound(inverted ? top : left) +'px)'
      					};
      					
      				// issue 74 workaround
      				if (!inverted && docMode8) {
      					extend(ret, {
      						width: right +PX,
      						height: bottom +PX
      					});
      				}
      				return ret;
      			},
      			
      			// used in attr and animation to update the clipping of all members
      			updateClipping: function() {
      				each(clipRect.members, function(member) {
      					member.css(clipRect.getCSS(member.inverted));
      				});
      			}
      		});
      		
      	},
      	
      	
      	/**
      	 * Take a color and return it if it's a string, make it a gradient if it's a
      	 * gradient configuration object, and apply opacity.
      	 * 
      	 * @param {Object} color The color or config object
      	 */
      	color: function(color, elem, prop) {
      		var colorObject,
      			regexRgba = /^rgba/,
      			markup;
      			
      		if (color && color.linearGradient) {
      			
      			var stopColor, 
      				stopOpacity,
      				linearGradient = color.linearGradient,
      				angle,
      				color1,
      				opacity1,
      				color2,
      				opacity2;	
      				
      			each(color.stops, function(stop, i) {
      				if (regexRgba.test(stop[1])) {
      					colorObject = Color(stop[1]);
      					stopColor = colorObject.get('rgb');
      					stopOpacity = colorObject.get('a');
      				} else {
      					stopColor = stop[1];
      					stopOpacity = 1;
      				}
      				
      				if (!i) { // first
      					color1 = stopColor;
      					opacity1 = stopOpacity;
      				} else {
      					color2 = stopColor;
      					opacity2 = stopOpacity;
      				}
      			});
      			
      			
      			
      			// calculate the angle based on the linear vector
      			angle = 90  - math.atan(
      				(linearGradient[3] - linearGradient[1]) / // y vector
      				(linearGradient[2] - linearGradient[0]) // x vector
      				) * 180 / mathPI;
      			
      			// when colors attribute is used, the meanings of opacity and o:opacity2
      			// are reversed.
      			markup = ['<', prop, ' colors="0% ', color1, ',100% ', color2, '" angle="', angle,
      				'" opacity="', opacity2, '" o:opacity2="', opacity1,
      				'" type="gradient" focus="100%" />'];
      			createElement(this.prepVML(markup), null, null, elem);
      			
      			
      		
      		// if the color is an rgba color, split it and add a fill node
      		// to hold the opacity component
      		} else if (regexRgba.test(color) && elem.tagName !== 'IMG') {
      			
      			colorObject = Color(color);
      			
      			markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
      			createElement(this.prepVML(markup), null, null, elem);
      			
      			return colorObject.get('rgb');
      			
      			
      		} else {
      			return color;
      		}
      		
      	},
      	
      	/**
      	 * Take a VML string and prepare it for either IE8 or IE6/IE7. 
      	 * @param {Array} markup A string array of the VML markup to prepare
      	 */
      	prepVML: function(markup) {
      		var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
      			isIE8 = this.isIE8;
      	
      		markup = markup.join('');
      		
      		if (isIE8) { // add xmlns and style inline
      			markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
      			if (markup.indexOf('style="') === -1) {
      				markup = markup.replace('/>', ' style="'+ vmlStyle +'" />');
      			} else {
      				markup = markup.replace('style="', 'style="'+ vmlStyle);
      			}
      
      		} else { // add namespace
      			markup = markup.replace('<', '<hcv:');
      		}
      
      		return markup;
      	},
      	
      	/**
      	 * Create rotated and aligned text
      	 * @param {String} str
      	 * @param {Number} x
      	 * @param {Number} y
      	 */
      	text: function(str, x, y) {
      		
      		var defaultChartStyle = defaultOptions.chart.style; 
      			
      		return this.createElement('span')
      			.attr({
      				text: str,
      				x: mathRound(x),
      				y: mathRound(y)
      			})
      			.css({
      				whiteSpace: 'nowrap',
      				fontFamily: defaultChartStyle.fontFamily,
      				fontSize: defaultChartStyle.fontSize
      			});
      	},
      	
      	/**
      	 * Create and return a path element
      	 * @param {Array} path
      	 */
      	path: function (path) {
      		// create the shape
      		return this.createElement('shape').attr({
      			// subpixel precision down to 0.1 (width and height = 10px)
      			coordsize: '100 100',
      			d: path
      		});
      	},
      	
      	/**
      	 * Create and return a circle element. In VML circles are implemented as
      	 * shapes, which is faster than v:oval
      	 * @param {Number} x
      	 * @param {Number} y
      	 * @param {Number} r
      	 */
      	circle: function(x, y, r) {
      		return this.symbol('circle').attr({ x: x, y: y, r: r});
      	},
      	
      	/**
      	 * Create a group using an outer div and an inner v:group to allow rotating 
      	 * and flipping. A simple v:group would have problems with positioning
      	 * child HTML elements and CSS clip.
      	 * 
      	 * @param {String} name The name of the group
      	 */
      	g: function(name) {
      		var wrapper,
      			attribs;
      		
      		// set the class name	
      		if (name) {
      			attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
      		}
      		
      		// the div to hold HTML and clipping	
      		wrapper = this.createElement(DIV).attr(attribs);
      		
      		return wrapper;
      	},
      	
      	/**
      	 * VML override to create a regular HTML image
      	 * @param {String} src
      	 * @param {Number} x
      	 * @param {Number} y
      	 * @param {Number} width
      	 * @param {Number} height
      	 */
      	image: function(src, x, y, width, height) {
      		var obj = this.createElement('img')
      			.attr({ src: src });
      			
      		if (arguments.length > 1) {
      			obj.css({
      				left: x,
      				top: y,
      				width: width,
      				height: height
      			});
      		}
      		return obj;
      	},
      	
      	/**
      	 * VML uses a shape for rect to overcome bugs and rotation problems
      	 */
      	rect: function(x, y, width, height, r, strokeWidth) {
      		
      		if (isObject(x)) {
      			y = x.y;
      			width = x.width;
      			height = x.height;
      			r = x.r;
      			strokeWidth = x.strokeWidth;
      			x = x.x;
      		}
      		var wrapper = this.symbol('rect');
      		wrapper.r = r;
      		
      		return wrapper.attr(wrapper.crisp(strokeWidth, x, y, mathMax(width, 0), mathMax(height, 0)));
      	},
      	
      	/**
      	 * In the VML renderer, each child of an inverted div (group) is inverted
      	 * @param {Object} element
      	 * @param {Object} parentNode
      	 */
      	invertChild: function(element, parentNode) {
      		var parentStyle = parentNode.style;
      			
      		css(element, { 
      			flip: 'x',
      			left: pInt(parentStyle.width) - 10,
      			top: pInt(parentStyle.height) - 10,
      			rotation: -90
      		});
      	},
      	
      	/**
      	 * Symbol definitions that override the parent SVG renderer's symbols
      	 * 
      	 */
      	symbols: {
      		// VML specific arc function
      		arc: function (x, y, radius, options) {
      			var start = options.start,
      				end = options.end,
      				cosStart = mathCos(start),
      				sinStart = mathSin(start),
      				cosEnd = mathCos(end),
      				sinEnd = mathSin(end),
      				innerRadius = options.innerR,
      				circleCorrection = 0.07 / radius,
      				innerCorrection = (innerRadius && 0.1 / innerRadius) || 0;
      				
      			if (end - start === 0) { // no angle, don't show it. 
      				return ['x'];
      				
      			//} else if (end - start == 2 * mathPI) { // full circle
      			} else if (2 * mathPI - end + start < circleCorrection) { // full circle
      				// empirical correction found by trying out the limits for different radii
      				cosEnd = - circleCorrection;
      			} else if (end - start < innerCorrection) { // issue #186, another mysterious VML arc problem
      				cosEnd = mathCos(start + innerCorrection);
      			}
      								
      			return [
      				'wa', // clockwise arc to
      				x - radius, // left
      				y - radius, // top
      				x + radius, // right
      				y + radius, // bottom
      				x + radius * cosStart, // start x
      				y + radius * sinStart, // start y
      				x + radius * cosEnd, // end x
      				y + radius * sinEnd, // end y
      				
      				
      				'at', // anti clockwise arc to
      				x - innerRadius, // left
      				y - innerRadius, // top
      				x + innerRadius, // right
      				y + innerRadius, // bottom
      				x + innerRadius * cosEnd, // start x
      				y + innerRadius * sinEnd, // start y
      				x + innerRadius * cosStart, // end x
      				y + innerRadius * sinStart, // end y
      				
      				'x', // finish path
      				'e' // close
      			];
      			
      		},
      		// Add circle symbol path. This performs significantly faster than v:oval.
      		circle: function (x, y, r) {
      			return [
      				'wa', // clockwisearcto
      				x - r, // left
      				y - r, // top
      				x + r, // right
      				y + r, // bottom
      				x + r, // start x
      				y,     // start y
      				x + r, // end x
      				y,     // end y
      				//'x', // finish path
      				'e' // close
      			];
      		},
      		/** 
      		 * Add rectangle symbol path which eases rotation and omits arcsize problems
      		 * compared to the built-in VML roundrect shape
      		 * 
      		 * @param {Number} left Left position
      		 * @param {Number} top Top position
      		 * @param {Number} r Border radius
      		 * @param {Object} options Width and height
      		 */
      		
      		rect: function (left, top, r, options) {
      			if (!defined(options)) {
      				return [];
      			}
      			var width = options.width,
      				height = options.height,
      				right = left + width,
      				bottom = top + height;
      		
      			r = mathMin(r, width, height);
      			
      			return [
      				M,
      				left + r, top,
      				
      				L,
      				right - r, top,
      				'wa',
      				right - 2 * r, top,
      				right, top + 2 * r,
      				right - r, top,
      				right, top + r,
      				
      				L,
      				right, bottom - r,
      				'wa',
      				right - 2 * r, bottom - 2 * r,
      				right, bottom,
      				right, bottom - r,
      				right - r, bottom,
      				
      				L,
      				left + r, bottom,
      				'wa',
      				left, bottom - 2 * r,
      				left + 2 * r, bottom, 
      				left + r, bottom,
      				left, bottom - r,
      				
      				L,
      				left, top + r,
      				'wa',
      				left, top,
      				left + 2 * r, top + 2 * r,
      				left, top + r,
      				left + r, top,
      				
      				
      				'x',
      				'e'
      			];
      				
      		}
      	}
      });
      
      // general renderer
      Renderer = VMLRenderer;
      }
      /* **************************************************************************** 
       *                                                                            * 
       * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
       *                                                                            *
       *****************************************************************************/
      	
      
      /**
       * The chart class
       * @param {Object} options
       * @param {Function} callback Function to run when the chart has loaded
       */
      function Chart (options, callback) {
      	
      	defaultXAxisOptions = merge(defaultXAxisOptions, defaultOptions.xAxis);
      	defaultYAxisOptions = merge(defaultYAxisOptions, defaultOptions.yAxis);
      	defaultOptions.xAxis = defaultOptions.yAxis = null;
      		
      	// Handle regular options
      	options = merge(defaultOptions, options);
      	
      	// Define chart variables
      	var optionsChart = options.chart,
      		optionsMargin = optionsChart.margin,
      		margin = isObject(optionsMargin) ?
      			optionsMargin : 
      			[optionsMargin, optionsMargin, optionsMargin, optionsMargin],
      		optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
      		optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
      		optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
      		optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
      		spacingTop = optionsChart.spacingTop,
      		spacingRight = optionsChart.spacingRight,
      		spacingBottom = optionsChart.spacingBottom,
      		spacingLeft = optionsChart.spacingLeft,
      		spacingBox, 
      		chartTitleOptions,
      		chartSubtitleOptions,
      		plotTop,
      		marginRight,
      		marginBottom,
      		plotLeft,
      		axisOffset,
      		renderTo,
      		renderToClone,
      		container,
      		containerId,
      		containerWidth,
      		containerHeight,
      		chartWidth,
      		chartHeight,
      		oldChartWidth,
      		oldChartHeight,
      		chartBackground,
      		plotBackground,
      		plotBGImage,
      		plotBorder,
      		chart = this,
      		chartEvents = optionsChart.events,
      		runChartClick = chartEvents && !!chartEvents.click,
      		eventType,
      		isInsidePlot, // function
      		tooltip,
      		mouseIsDown,
      		loadingDiv,
      		loadingSpan,
      		loadingShown,
      		plotHeight,
      		plotWidth,
      		tracker,
      		trackerGroup,
      		placeTrackerGroup,
      		legend,
      		legendWidth,
      		legendHeight,
      		chartPosition,// = getPosition(container),
      		hasCartesianSeries = optionsChart.showAxes,
      		isResizing = 0,
      		axes = [],
      		maxTicks, // handle the greatest amount of ticks on grouped axes
      		series = [], 
      		inverted,
      		renderer,
      		tooltipTick,
      		tooltipInterval,
      		hoverX,
      		drawChartBox, // function
      		getMargins, // function
      		resetMargins, // function
      		setChartSize, // function
      		resize,
      		zoom, // function
      		zoomOut; // function
      		
      
      	/**
      	 * Create a new axis object
      	 * @param {Object} chart
      	 * @param {Object} options
      	 */
      	function Axis (chart, options) {
      
      		// Define variables
      		var isXAxis = options.isX,
      			opposite = options.opposite, // needed in setOptions			
      			horiz = inverted ? !isXAxis : isXAxis,
      			side = horiz ? 
      				(opposite ? 0 /* top */  : 2 /* bottom */) :
      				(opposite ? 1 /* right*/ : 3 /* left */  ),
      			stacks = {};
      			
      	
      		options = merge(
      				isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
      				[defaultTopAxisOptions, defaultRightAxisOptions, 
      					defaultBottomAxisOptions, defaultLeftAxisOptions][side],
      				options
      			);
      	
      		var axis = this,
      			type = options.type,
      			isDatetimeAxis = type === 'datetime',
      			isLog = type === 'logarithmic',
      			offset = options.offset || 0,
      			xOrY = isXAxis ? 'x' : 'y',
      			axisLength,
      			transA, // translation factor
      			oldTransA, // used for prerendering
      			transB = horiz ? plotLeft : marginBottom, // translation addend
      			translate, // fn
      			getPlotLinePath, // fn
      			axisGroup,
      			gridGroup,
      			axisLine,
      			dataMin,
      			dataMax,
      			associatedSeries,
      			userMin,
      			userMax,
      			max = null,
      			min = null,
      			oldMin,
      			oldMax,
      			minPadding = options.minPadding,
      			maxPadding = options.maxPadding,
      			isLinked = defined(options.linkedTo),
      			ignoreMinPadding, // can be set to true by a column or bar series
      			ignoreMaxPadding,
      			usePercentage,
      			events = options.events,
      			eventType,
      			plotLinesAndBands = [],
      			tickInterval,
      			minorTickInterval,
      			magnitude,
      			tickPositions, // array containing predefined positions
      			ticks = {},
      			minorTicks = {},
      			alternateBands = {},
      			tickAmount,
      			labelOffset,
      			axisTitleMargin,// = options.title.margin,
      			dateTimeLabelFormat,
      			categories = options.categories,
      			labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
      				function() {
      					var value = this.value, 
      						ret;
      					
      					if (dateTimeLabelFormat) { // datetime axis
      						ret = dateFormat(dateTimeLabelFormat, value);
      						
      					} else if (tickInterval % 1000000 === 0) { // use M abbreviation
      						ret = (value / 1000000) +'M';
      						
      					} else if (tickInterval % 1000 === 0) { // use k abbreviation
      						ret = (value / 1000) +'k';
      						
      					} else if (!categories && value >= 1000) { // add thousands separators
      						ret = numberFormat(value, 0);
      					
      					} else { // strings (categories) and small numbers
      						ret = value;
      					}
      					return ret;
      				},
      				
      			staggerLines = horiz && options.labels.staggerLines,
      			reversed = options.reversed,
      			tickmarkOffset = (categories && options.tickmarkPlacement === 'between') ? 0.5 : 0;		
      
      		/**
      		 * The Tick class
      		 */
      		function Tick(pos, minor) {
      			var tick = this;
      			tick.pos = pos;
      			tick.minor = minor;
      			tick.isNew = true;				
      			
      			if (!minor) {
      				tick.addLabel();
      			}
      		}
      		Tick.prototype = {
      			/**
      			 * Write the tick label
      			 */
      			addLabel: function() {
      				var pos = this.pos,
      					labelOptions = options.labels,
      					str,
      					withLabel = !((pos === min && !pick(options.showFirstLabel, 1)) ||
      						(pos === max && !pick(options.showLastLabel, 0))),
      					width = (categories && horiz && categories.length && 
      						!labelOptions.step && !labelOptions.staggerLines &&
      						!labelOptions.rotation &&
      						plotWidth / categories.length) ||
      						(!horiz && plotWidth / 2),
      					css,
      					label = this.label;
      					
      				
      				// get the string
      				str = labelFormatter.call({
      						isFirst: pos === tickPositions[0],
      						isLast: pos === tickPositions[tickPositions.length - 1],
      						dateTimeLabelFormat: dateTimeLabelFormat,
      						value: (categories && categories[pos] ? categories[pos] : pos)
      					});
      				
      				
      				// prepare CSS
      				css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) +PX };
      				css = extend(css, labelOptions.style);
      				
      				// first call
      				if (label === UNDEFINED) {
      					this.label =  
      						defined(str) && withLabel && labelOptions.enabled ?
      							renderer.text(
      									str,
      									0,
      									0
      								)
      								.attr({
      									align: labelOptions.align,
      									rotation: labelOptions.rotation
      								})
      								// without position absolute, IE export sometimes is wrong
      								.css(css)
      								.add(axisGroup):
      							null;
      							
      				// update
      				} else if (label) {
      					label.attr({ text: str })
      						.css(css);
      				}
      			},
      			/**
      			 * Get the offset height or width of the label
      			 */
      			getLabelSize: function() {
      				var label = this.label;
      				return label ? 
      					((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
      					0;
      				},
      			/**
      			 * Put everything in place
      			 * 
      			 * @param index {Number}
      			 * @param old {Boolean} Use old coordinates to prepare an animation into new position
      			 */
      			render: function(index, old) {
      				var tick = this,
      					major = !tick.minor,
      					label = tick.label,
      					pos = tick.pos,
      					labelOptions = options.labels,
      					gridLine = tick.gridLine,
      					gridLineWidth = major ? options.gridLineWidth : options.minorGridLineWidth,
      					gridLineColor = major ? options.gridLineColor : options.minorGridLineColor,
      					dashStyle = major ? 
      						options.gridLineDashStyle : 
      						options.minorGridLineDashStyle,
      					gridLinePath,
      					mark = tick.mark,
      					markPath,
      					tickLength = major ? options.tickLength : options.minorTickLength,
      					tickWidth = major ? options.tickWidth : (options.minorTickWidth || 0),
      					tickColor = major ? options.tickColor : options.minorTickColor,
      					tickPosition = major ? options.tickPosition : options.minorTickPosition,
      					step = labelOptions.step,
      					cHeight = (old && oldChartHeight) || chartHeight,
      					attribs,
      					x,
      					y;
      					
      				// get x and y position for ticks and labels
      				x = horiz ? 
      					translate(pos + tickmarkOffset, null, null, old) + transB : 
      					plotLeft + offset + (opposite ? ((old && oldChartWidth) || chartWidth) - marginRight - plotLeft : 0);
      					
      				y = horiz ?
      					cHeight - marginBottom + offset - (opposite ? plotHeight : 0) :
      					cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;
      					
      				// create the grid line
      				if (gridLineWidth) {
      					gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);
      					
      					if (gridLine === UNDEFINED) {
      						attribs = {
      							stroke: gridLineColor,
      							'stroke-width': gridLineWidth
      						};
      						if (dashStyle) {
      							attribs.dashstyle = dashStyle;
      						}
      						tick.gridLine = gridLine =
      							gridLineWidth ?
      								renderer.path(gridLinePath)
      									.attr(attribs).add(gridGroup) :
      								null;
      					} 
      					if (gridLine && gridLinePath) {
      						gridLine.animate({
      							d: gridLinePath
      						});
      					}
      				}
      				
      				// create the tick mark
      				if (tickWidth) {
      					
      					// negate the length
      					if (tickPosition === 'inside') {
      						tickLength = -tickLength;
      					}
      					if (opposite) {
      						tickLength = -tickLength;
      					}
      			
      					markPath = renderer.crispLine([
      						M, 
      						x, 
      						y, 
      						L, 
      						x + (horiz ? 0 : -tickLength), 
      						y + (horiz ? tickLength : 0)
      					], tickWidth);
      					
      					if (mark) { // updating
      						mark.animate({
      							d: markPath
      						});
      					} else { // first time
      						tick.mark = renderer.path(
      							markPath
      						).attr({
      							stroke: tickColor,
      							'stroke-width': tickWidth
      						}).add(axisGroup);
      					}
      				}
      				
      				// the label is created on init - now move it into place
      				if (label && !isNaN(x)) {
      					x = x + labelOptions.x - (tickmarkOffset && horiz ? 
      						tickmarkOffset * transA * (reversed ? -1 : 1) : 0); 
      					y = y + labelOptions.y - (tickmarkOffset && !horiz ? 
      						tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
      						
      					// vertically centered
      					if (!defined(labelOptions.y)) {
      						y += pInt(label.styles.lineHeight) * 0.9 - label.getBBox().height / 2;
      					}
      					
      						
      					// correct for staggered labels
      					if (staggerLines) {
      						y += (index / (step || 1) % staggerLines) * 16;
      					}
      					// apply step
      					if (step) {
      						// show those indices dividable by step 
      						label[index % step ? 'hide' : 'show']();
      					}
      					
      					label[tick.isNew ? 'attr' : 'animate']({
      						x: x,
      						y: y
      					});
      				}
      				
      				tick.isNew = false;
      			},
      			/**
      			 * Destructor for the tick prototype
      			 */
      			destroy: function() {
      				var tick = this,
      					n;
      				for (n in tick) {
      					if (tick[n] && tick[n].destroy) {
      						tick[n].destroy();
      					}
      				}
      			}
      		};
      		
      		/**
      		 * The object wrapper for plot lines and plot bands
      		 * @param {Object} options
      		 */
      		function PlotLineOrBand(options) {
      			var plotLine = this;
      			if (options) {
      				plotLine.options = options;
      				plotLine.id = options.id;
      			}
      			
      			//plotLine.render()
      			return plotLine;
      		}
      		
      		PlotLineOrBand.prototype = {
      
      		/**
      		 * Render the plot line or plot band. If it is already existing,
      		 * move it.
      		 */
      		render: function () {
      			var plotLine = this,
      				options = plotLine.options,
      				optionsLabel = options.label,
      				label = plotLine.label,
      				width = options.width,
      				to = options.to,
      				toPath, // bands only
      				from = options.from,
      				dashStyle = options.dashStyle,
      				svgElem = plotLine.svgElem,
      				path = [],
      				addEvent,
      				eventType,
      				xs,
      				ys,
      				x,
      				y,
      				color = options.color,
      				zIndex = options.zIndex,
      				events = options.events,
      				attribs;
      			
      			// plot line
      			if (width) {
      				path = getPlotLinePath(options.value, width);
      				attribs = {
      					stroke: color,
      					'stroke-width': width
      				};
      				if (dashStyle) {
      					attribs.dashstyle = dashStyle;
      				}
      			}
      			
      			// plot band
      			else if (defined(from) && defined(to)) {
      				// keep within plot area
      				from = mathMax(from, min);
      				to = mathMin(to, max);
      			
      				toPath = getPlotLinePath(to);
      				path = getPlotLinePath(from);
      				if (path && toPath) {
      					path.push(
      						toPath[4],
      						toPath[5],
      						toPath[1],
      						toPath[2]
      					);
      				} else { // outside the axis area
      					path = null;
      				}
      				attribs = {
      					fill: color
      				};
      			} else {
      				return;
      			}
      			// zIndex 
      			if (defined(zIndex)) {
      				attribs.zIndex = zIndex;
      			}
      			
      			// common for lines and bands
      			if (svgElem) {
      				if (path) {
      					svgElem.animate({
      						d: path
      					}, null, svgElem.onGetPath);
      				} else {
      					svgElem.hide();
      					svgElem.onGetPath = function() {
      						svgElem.show();
      					};
      				}
      			} else if (path && path.length) {
      				plotLine.svgElem = svgElem = renderer.path(path)
      					.attr(attribs).add();
      					
      				// events
      				if (events) {
      					addEvent = function(eventType) {
      						svgElem.on(eventType, function(e) {
      							events[eventType].apply(plotLine, [e]);
      						});
      					};
      					for (eventType in events) {
      						addEvent(eventType);
      					}
      				}
      			}
      			
      			// the plot band/line label
      			if (optionsLabel && defined(optionsLabel.text) && path && path.length && plotWidth > 0 && plotHeight > 0) {
      				// apply defaults
      				optionsLabel = merge({
      					align: horiz && toPath && 'center',
      					x: horiz ? !toPath && 4 : 10,
      					verticalAlign : !horiz && toPath && 'middle',
      					y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
      					rotation: horiz && !toPath && 90
      				}, optionsLabel);
      				
      				// add the SVG element
      				if (!label) {
      					plotLine.label = label = renderer.text(
      							optionsLabel.text,
      							0,
      							0
      						)
      						.attr({
      							align: optionsLabel.textAlign || optionsLabel.align,
      							rotation: optionsLabel.rotation,
      							zIndex: zIndex
      						})
      						.css(optionsLabel.style)
      						.add();
      				}
      				
      				// get the bounding box and align the label
      				xs = [path[1], path[4], pick(path[6], path[1])];
      				ys = [path[2], path[5], pick(path[7], path[2])];
      				x = mathMin.apply(math, xs);
      				y = mathMin.apply(math, ys);
      				
      				label.align(optionsLabel, false, {
      					x: x,
      					y: y,
      					width: mathMax.apply(math, xs) - x,
      					height: mathMax.apply(math, ys) - y
      				});
      				label.show();
      				
      			} else if (label) { // move out of sight
      				label.hide();
      			}
      			
      			// chainable
      			return plotLine;
      		},
      		
      		/**
      		 * Remove the plot line or band
      		 */
      		destroy: function() {
      			var obj = this,
      				n;
      				
      			for (n in obj) {
      				if (obj[n] && obj[n].destroy) {
      					obj[n].destroy(); // destroy SVG wrappers
      				}
      				delete obj[n];
      			}
      			// remove it from the lookup
      			erase(plotLinesAndBands, obj);
      		}
      		};
      		
      		/**
      		 * The class for stack items
      		 */
      		function StackItem(options, isNegative, x) {
      			var stackItem = this;
      		
      			// Tells if the stack is negative 
      			stackItem.isNegative = isNegative;
      			
      			// Save the options to be able to style the label
      			stackItem.options = options;
      			
      			// Save the x value to be able to position the label later
      			stackItem.x = x;
      			
      			// The align options and text align varies on whether the stack is negative and
      			// if the chart is inverted or not.
      			// First test the user supplied value, then use the dynamic.
      			stackItem.alignOptions = {
      				align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
      				verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
      				y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
      				x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
      			};
      			
      			stackItem.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
      		}
      		
      		StackItem.prototype = {
      			/**
      			 * Sets the total of this stack. Should be called when a serie is hidden or shown
      			 * since that will affect the total of other stacks.
      			 */
      			setTotal: function(total) {
      				this.total = total;
      				this.cum = total;
      			},
      
      			/**
      			 * Renders the stack total label and adds it to the stack label group.
      			 */
      			render: function(group) {
      				var stackItem = this,									// aliased this
      					str = stackItem.options.formatter.call(stackItem);	// format the text in the label
      
      				// Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
      				if (stackItem.label) {
      					stackItem.label.attr({text: str, visibility: HIDDEN});
      				// Create new label
      				} else {
      					stackItem.label =
      						chart.renderer.text(str, 0, 0)				// dummy positions, actual position updated with setOffset method in columnseries
      							.css(stackItem.options.style)			// apply style
      							.attr({align: stackItem.textAlign,			// fix the text-anchor
      								rotation: stackItem.options.rotation,	// rotation
      								visibility: HIDDEN })					// hidden until setOffset is called
      							.add(group);							// add to the labels-group
      				}
      			},
      
      			/**
      			 * Sets the offset that the stack has from the x value and repositions the label.
      			 */
      			setOffset: function(xOffset, xWidth) {
      				var stackItem = this,										// aliased this
      					neg = stackItem.isNegative,								// special treatment is needed for negative stacks
      					y = axis.translate(stackItem.total),					// stack value translated mapped to chart coordinates
      					yZero = axis.translate(0),								// stack origin
      					h = mathAbs(y - yZero),									// stack height
      					x = chart.xAxis[0].translate(stackItem.x) + xOffset,	// stack x position
      					plotHeight = chart.plotHeight,
      					stackBox = {	// this is the box for the complete stack
      							x: inverted ? (neg ? y : y - h) : x,
      							y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
      							width: inverted ? h : xWidth,
      							height: inverted ? xWidth : h
      					};
      				
      				if (stackItem.label) {
      					stackItem.label
      						.align(stackItem.alignOptions, null, stackBox)	// align the label to the box
      						.attr({visibility: VISIBLE});					// set visibility
      				}
      			}
      		};
      		
      		/**
      		 * Get the minimum and maximum for the series of each axis 
      		 */
      		function getSeriesExtremes() {
      			var posStack = [],
      				negStack = [],
      				run;
      				
      			// reset dataMin and dataMax in case we're redrawing
      			dataMin = dataMax = null;
      			
      			// get an overview of what series are associated with this axis
      			associatedSeries = [];
      			
      			each(series, function(serie) {
      				run = false;
      				
      				
      				// match this axis against the series' given or implicated axis
      				each(['xAxis', 'yAxis'], function(strAxis) {
      					if (
      						// the series is a cartesian type, and...
      						serie.isCartesian &&
      						// we're in the right x or y dimension, and...
      						((strAxis === 'xAxis' && isXAxis) || (strAxis === 'yAxis' && !isXAxis)) && (
      							// the axis number is given in the options and matches this axis index, or
      							(serie.options[strAxis] === options.index) || 
      							// the axis index is not given
      							(serie.options[strAxis] === UNDEFINED && options.index === 0)
      						)
      					) {
      						serie[strAxis] = axis;
      						associatedSeries.push(serie);
      						
      						// the series is visible, run the min/max detection
      						run = true;		
      					}
      				});
      				// ignore hidden series if opted 
      				if (!serie.visible && optionsChart.ignoreHiddenSeries) {
      					run = false;
      				}				
      				
      				if (run) {
      					
      					var stacking,
      						posPointStack,
      						negPointStack,
      						stackKey,
      						negKey;
      		
      					if (!isXAxis) {
      						stacking = serie.options.stacking;
      						usePercentage = stacking === 'percent';
      	
      						// create a stack for this particular series type
      						if (stacking) {
      							stackKey = serie.type + pick(serie.options.stack, '');
      							negKey = '-'+ stackKey;
      							serie.stackKey = stackKey; // used in translate
      									
      							posPointStack = posStack[stackKey] || []; // contains the total values for each x
      							posStack[stackKey] = posPointStack;
      							
      							negPointStack = negStack[negKey] || [];
      							negStack[negKey] = negPointStack;
      						}
      						if (usePercentage) {
      							dataMin = 0;
      							dataMax = 99;			
      						}
      					} 
      					if (serie.isCartesian) { // line, column etc. need axes, pie doesn't
      						each(serie.data, function(point, i) {
      							var pointX = point.x,
      								pointY = point.y,
      								isNegative = pointY < 0, 
      								pointStack = isNegative ? negPointStack : posPointStack,
      								key = isNegative ? negKey : stackKey,
      								totalPos,
      								pointLow;
      							
      							// initial values
      							if (dataMin === null) {
      
      								// start out with the first point
      								dataMin = dataMax = point[xOrY]; 
      							}
      		
      							// x axis
      							if (isXAxis) {
      								if (pointX > dataMax) {
      									dataMax = pointX;
      								} else if (pointX < dataMin) {
      									dataMin = pointX;
      								}
      							}
      							
      							// y axis
      							else if (defined(pointY)) {
      								if (stacking) {
      									pointStack[pointX] = 
      										defined(pointStack[pointX]) ? 
      										pointStack[pointX] + pointY : pointY;
      								}
      								totalPos = pointStack ? pointStack[pointX] : pointY;
      								pointLow = pick(point.low, totalPos);
      								if (!usePercentage) {
      									if (totalPos > dataMax) {
      										dataMax = totalPos;
      									} else if (pointLow < dataMin) {
      										dataMin = pointLow;
      									}
      								}
      								if (stacking) {		
      									// add the series
      									if (!stacks[key]) {
      										stacks[key] = {};
      									}
      									
      									// If the StackItem is there, just update the values,
      									// if not, create one first
      									if (!stacks[key][pointX]) {
      										stacks[key][pointX] = new StackItem(options.stackLabels, isNegative, pointX);
      									}
      									stacks[key][pointX].setTotal(totalPos);
      								}
      							}
      						});
      						
      							
      						// For column, areas and bars, set the minimum automatically to zero
      						// and prevent that minPadding is added in setScale
      						if (/(area|column|bar)/.test(serie.type) && !isXAxis) {
      							var threshold = 0; // use series.options.threshold?
      							if (dataMin >= threshold) {
      								dataMin = threshold;
      								ignoreMinPadding = true;
      							} else if (dataMax < threshold) {
      								dataMax = threshold;
      								ignoreMaxPadding = true;
      							}
      						}
      					}
      				}
      			});
      			
      		}
      	
      		/**
      		 * Translate from axis value to pixel position on the chart, or back
      		 * 
      		 */
      		translate = function(val, backwards, cvsCoord, old, handleLog) {
      			var sign = 1,
      				cvsOffset = 0,
      				localA = old ? oldTransA : transA,
      				localMin = old ? oldMin : min,
      				returnValue;
      				
      			if (!localA) {
      				localA = transA;
      			}
      				
      			if (cvsCoord) {
      				sign *= -1; // canvas coordinates inverts the value
      				cvsOffset = axisLength;
      			}
      			if (reversed) { // reversed axis
      				sign *= -1; 
      				cvsOffset -= sign * axisLength;
      			}
      			
      			if (backwards) { // reverse translation
      				if (reversed) {
      					val = axisLength - val;
      				}
      				returnValue = val / localA + localMin; // from chart pixel to value	
      				if (isLog && handleLog) {
      					returnValue = lin2log(returnValue);
      				}			
      			
      			} else { // normal translation
      				if (isLog && handleLog) {
      					val = log2lin(val);
      				}
      				returnValue = sign * (val - localMin) * localA + cvsOffset; // from value to chart pixel
      			}
      			
      			return returnValue;
      		};
      		
      		/**
      		 * Create the path for a plot line that goes from the given value on 
      		 * this axis, across the plot to the opposite side
      		 * @param {Number} value
      		 * @param {Number} lineWidth Used for calculation crisp line
      		 * @param {Number] old Use old coordinates (for resizing and rescaling)
      		 */
      		getPlotLinePath = function(value, lineWidth, old) {
      			var x1, 
      				y1, 
      				x2, 
      				y2,
      				translatedValue = translate(value, null, null, old),
      				cHeight = (old && oldChartHeight) || chartHeight,
      				cWidth = (old && oldChartWidth) || chartWidth,
      				skip;
      				
      			x1 = x2 = mathRound(translatedValue + transB);
      			y1 = y2 = mathRound(cHeight - translatedValue - transB);
      			
      			if (isNaN(translatedValue)) { // no min or max
      				skip = true;
      			
      			} else if (horiz) { 
      				y1 = plotTop;
      				y2 = cHeight - marginBottom;
      				if (x1 < plotLeft || x1 > plotLeft + plotWidth) {
      					skip = true;
      				}
      			} else {
      				x1 = plotLeft;
      				x2 = cWidth - marginRight;
      				if (y1 < plotTop || y1 > plotTop + plotHeight) {
      					skip = true;
      				}
      			}
      			return skip ? 
      				null : 
      				renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
      		};
      		
      		
      		/**
      		 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
      		 * @param {Number} interval
      		 */
      		function normalizeTickInterval(interval, multiples) {
      			var normalized, i;
      				
      			// round to a tenfold of 1, 2, 2.5 or 5
      			magnitude = multiples ? 1 : math.pow(10, mathFloor(math.log(interval) / math.LN10));
      			normalized = interval / magnitude;
      			
      			// multiples for a linear scale
      			if (!multiples) {
      				multiples = [1, 2, 2.5, 5, 10];
      				//multiples = [1, 2, 2.5, 4, 5, 7.5, 10];
      				
      				// the allowDecimals option
      				if (options.allowDecimals === false || isLog) {
      					if (magnitude === 1) {
      						multiples = [1, 2, 5, 10];
      					} else if (magnitude <= 0.1) {
      						multiples = [1 / magnitude];
      					}					
      				}
      			}
      			
      			// normalize the interval to the nearest multiple
      			for (i = 0; i < multiples.length; i++) {
      				interval = multiples[i];
      				if (normalized <= (multiples[i] + (multiples[i+1] || multiples[i])) / 2) {
      					break;
      				}
      			}
      			
      			// multiply back to the correct magnitude
      			interval *= magnitude;
      			
      			return interval;
      		}
      	
      		/**
      		 * Set the tick positions to a time unit that makes sense, for example
      		 * on the first of each month or on every Monday.
      		 */
      		function setDateTimeTickPositions() {
      			tickPositions = [];
      			var i,
      				useUTC = defaultOptions.global.useUTC,
      				oneSecond = 1000 / timeFactor,
      				oneMinute = 60000 / timeFactor,
      				oneHour = 3600000 / timeFactor,
      				oneDay = 24 * 3600000 / timeFactor,
      				oneWeek = 7 * 24 * 3600000 / timeFactor,
      				oneMonth = 30 * 24 * 3600000 / timeFactor,
      				oneYear = 31556952000 / timeFactor,
      			
      				units = [[
      					'second',						// unit name
      					oneSecond,						// fixed incremental unit
      					[1, 2, 5, 10, 15, 30]			// allowed multiples
      				], [
      					'minute',						// unit name
      					oneMinute,						// fixed incremental unit
      					[1, 2, 5, 10, 15, 30]			// allowed multiples
      				], [
      					'hour',							// unit name
      					oneHour,						// fixed incremental unit
      					[1, 2, 3, 4, 6, 8, 12]			// allowed multiples
      				], [
      					'day',							// unit name
      					oneDay,							// fixed incremental unit
      					[1, 2]							// allowed multiples
      				], [
      					'week',							// unit name
      					oneWeek,						// fixed incremental unit
      					[1, 2]							// allowed multiples
      				], [
      					'month',
      					oneMonth,
      					[1, 2, 3, 4, 6]
      				], [
      					'year',
      					oneYear,
      					null
      				]],
      			
      				unit = units[6], // default unit is years
      				interval = unit[1], 
      				multiples = unit[2];
      			
      			// loop through the units to find the one that best fits the tickInterval
      			for (i = 0; i < units.length; i++)  {
      				unit = units[i];
      				interval = unit[1];
      				multiples = unit[2];
      				
      				
      				if (units[i+1]) {
      					// lessThan is in the middle between the highest multiple and the next unit.
      					var lessThan = (interval * multiples[multiples.length - 1] + 
      								units[i + 1][1]) / 2;
      							
      					// break and keep the current unit
      					if (tickInterval <= lessThan) {
      						break;
      					}
      				}
      			}
      			
      			// prevent 2.5 years intervals, though 25, 250 etc. are allowed
      			if (interval === oneYear && tickInterval < 5 * interval) {
      				multiples = [1, 2, 5];
      			}
      	
      			// get the minimum value by flooring the date
      			var multitude = normalizeTickInterval(tickInterval / interval, multiples),
      				minYear, // used in months and years as a basis for Date.UTC()
      				minDate = new Date(min * timeFactor);
      				
      			minDate.setMilliseconds(0);
      			
      			if (interval >= oneSecond) { // second
      				minDate.setSeconds(interval >= oneMinute ? 0 :
      					multitude * mathFloor(minDate.getSeconds() / multitude));
      			}
      	
      			if (interval >= oneMinute) { // minute
      				minDate[setMinutes](interval >= oneHour ? 0 :
      					multitude * mathFloor(minDate[getMinutes]() / multitude));
      			}
      	
      			if (interval >= oneHour) { // hour
      				minDate[setHours](interval >= oneDay ? 0 :
      					multitude * mathFloor(minDate[getHours]() / multitude));
      			}
      	
      			if (interval >= oneDay) { // day
      				minDate[setDate](interval >= oneMonth ? 1 :
      					multitude * mathFloor(minDate[getDate]() / multitude));
      			}
      					
      			if (interval >= oneMonth) { // month
      				minDate[setMonth](interval >= oneYear ? 0 :
      					multitude * mathFloor(minDate[getMonth]() / multitude));
      				minYear = minDate[getFullYear]();
      			}
      			
      			if (interval >= oneYear) { // year
      				minYear -= minYear % multitude;
      				minDate[setFullYear](minYear);
      			}
      			
      			// week is a special case that runs outside the hierarchy
      			if (interval === oneWeek) {
      				// get start of current week, independent of multitude
      				minDate[setDate](minDate[getDate]() - minDate[getDay]() + 
      					options.startOfWeek);
      			}
      			
      			
      			// get tick positions
      			i = 1; // prevent crash just in case
      			minYear = minDate[getFullYear]();
      			var time = minDate.getTime() / timeFactor,
      				minMonth = minDate[getMonth](),
      				minDateDate = minDate[getDate]();
      				
      			// iterate and add tick positions at appropriate values
      			while (time < max && i < plotWidth) {
      				tickPositions.push(time);
      				
      				// if the interval is years, use Date.UTC to increase years
      				if (interval === oneYear) {
      					time = makeTime(minYear + i * multitude, 0) / timeFactor;
      				
      				// if the interval is months, use Date.UTC to increase months
      				} else if (interval === oneMonth) {
      					time = makeTime(minYear, minMonth + i * multitude) / timeFactor;
      					
      				// if we're using global time, the interval is not fixed as it jumps
      				// one hour at the DST crossover
      				} else if (!useUTC && (interval === oneDay || interval === oneWeek)) {
      					time = makeTime(minYear, minMonth, minDateDate + 
      						i * multitude * (interval === oneDay ? 1 : 7));
      					
      				// else, the interval is fixed and we use simple addition
      				} else {
      					time += interval * multitude;
      				}
      				
      				i++;
      			}
      			// push the last time
      			tickPositions.push(time);
      			
      			
      			// dynamic label formatter 
      			dateTimeLabelFormat = options.dateTimeLabelFormats[unit[0]];
      		}
      			
      		/**
      		 * Fix JS round off float errors
      		 * @param {Number} num
      		 */
      		function correctFloat(num) {
      			var invMag, ret = num;
      			magnitude = pick(magnitude, math.pow(10, mathFloor(math.log(tickInterval) / math.LN10)));
      			
      			if (magnitude < 1) {
      				invMag = mathRound(1 / magnitude)  * 10;
      				ret = mathRound(num * invMag) / invMag;
      			}
      			return ret;
      		}
      				
      		/**
      		 * Set the tick positions of a linear axis to round values like whole tens or every five.
      		 */
      		function setLinearTickPositions() {
      			
      			var i,
      				roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
      				roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval);
      				
      			tickPositions = [];
      			
      			// populate the intermediate values
      			i = correctFloat(roundedMin);
      			while (i <= roundedMax) {
      				tickPositions.push(i);
      				i = correctFloat(i + tickInterval);
      			}
      			
      		}
      		
      		/**
      		 * Set the tick positions to round values and optionally extend the extremes
      		 * to the nearest tick
      		 */
      		function setTickPositions(secondPass) {
      			var length,
      				catPad,
      				linkedParent,
      				linkedParentExtremes,
      				tickIntervalOption = options.tickInterval,
      				tickPixelIntervalOption = options.tickPixelInterval,
      				maxZoom = options.maxZoom || (
      					isXAxis && !defined(options.min) && !defined(options.max) ? 
      						mathMin(chart.smallestInterval * 5, dataMax - dataMin) : 
      						null					
      				),
      				zoomOffset;
      				
      			
      			axisLength = horiz ? plotWidth : plotHeight;
      			
      			// linked axis gets the extremes from the parent axis
      			if (isLinked) {
      				linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
      				linkedParentExtremes = linkedParent.getExtremes();
      				min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
      				max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
      			}
      			
      			// initial min and max from the extreme data values
      			else {
      				min = pick(userMin, options.min, dataMin);
      				max = pick(userMax, options.max, dataMax);
      			}
      			
      			if (isLog) {
      				min = log2lin(min);
      				max = log2lin(max);
      			}
      			
      			// maxZoom exceeded, just center the selection
      			if (max - min < maxZoom) { 
      				zoomOffset = (maxZoom - max + min) / 2;
      				// if min and max options have been set, don't go beyond it
      				min = mathMax(min - zoomOffset, pick(options.min, min - zoomOffset), dataMin);
      				max = mathMin(min + maxZoom, pick(options.max, min + maxZoom), dataMax);
      			}
      				
      			// pad the values to get clear of the chart's edges
      			if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
      				length = (max - min) || 1;
      				if (!defined(options.min) && !defined(userMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) { 
      					min -= length * minPadding; 
      				}
      				if (!defined(options.max) && !defined(userMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) { 
      					max += length * maxPadding;
      				}
      			}
      
      			// get tickInterval
      			if (min === max) {
      				tickInterval = 1;
      			} else if (isLinked && !tickIntervalOption &&
      					tickPixelIntervalOption === linkedParent.options.tickPixelInterval) {
      				tickInterval = linkedParent.tickInterval;
      			} else {
      				tickInterval = pick(
      					tickIntervalOption,
      					categories ? // for categoried axis, 1 is default, for linear axis use tickPix 
      						1 : 
      						(max - min) * tickPixelIntervalOption / axisLength
      				);
      			}
      			
      			if (!isDatetimeAxis && !defined(options.tickInterval)) { // linear
      				tickInterval = normalizeTickInterval(tickInterval);
      			}
      			axis.tickInterval = tickInterval; // record for linked axis
      			
      			// get minorTickInterval
      			minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
      					tickInterval / 5 : options.minorTickInterval;
      			
      			// find the tick positions
      			if (isDatetimeAxis)	{
      				setDateTimeTickPositions();
      			} else {
      				setLinearTickPositions();
      			}
      			
      			if (!isLinked) {
      				// pad categorised axis to nearest half unit
      				if (categories || (isXAxis && chart.hasColumn)) {
      					catPad = (categories ? 1 : tickInterval) * 0.5;
      					if (categories || !defined(pick(options.min, userMin))) {
      						min -= catPad;
      					}
      					if (categories || !defined(pick(options.max, userMax))) {
      						max += catPad;
      					}
      				}
      				
      				// reset min/max or remove extremes based on start/end on tick
      				var roundedMin = tickPositions[0],
      					roundedMax = tickPositions[tickPositions.length - 1];
      				
      				if (options.startOnTick) {
      					min = roundedMin;
      				} else if (min > roundedMin) {
      					tickPositions.shift();
      				}
      				
      				if (options.endOnTick) {
      					max = roundedMax;
      				} else if (max < roundedMax) {
      					tickPositions.pop();
      				}
      			
      				// record the greatest number of ticks for multi axis
      				if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
      					maxTicks = {
      						x: 0,
      						y: 0
      					};
      				}
      				
      				if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY]) {
      					maxTicks[xOrY] = tickPositions.length;
      				}
      			}
      			
      			
      		}
      		
      		/**
      		 * When using multiple axes, adjust the number of ticks to match the highest
      		 * number of ticks in that group
      		 */ 
      		function adjustTickAmount() {
      					
      			if (maxTicks && !isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale
      				var oldTickAmount = tickAmount,
      					calculatedTickAmount = tickPositions.length;
      					
      				// set the axis-level tickAmount to use below
      				tickAmount = maxTicks[xOrY];
      				
      				if (calculatedTickAmount < tickAmount) {
      					while (tickPositions.length < tickAmount) {
      						tickPositions.push( correctFloat(
      							tickPositions[tickPositions.length - 1] + tickInterval
      						));
      					}
      					transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
      					max = tickPositions[tickPositions.length - 1];
      				
      				}
      				if (defined(oldTickAmount) && tickAmount !== oldTickAmount) {
      					axis.isDirty = true;	
      				}
      			}
      			
      		}
      	
      		/**
      		 * Set the scale based on data min and max, user set min and max or options
      		 * 
      		 */
      		function setScale() {
      			var type, 
      				i;
      				
      			oldMin = min;
      			oldMax = max;
      				
      			// get data extremes if needed
      			getSeriesExtremes();
      					
      			// get fixed positions based on tickInterval
      			setTickPositions();
      			
      			// the translation factor used in translate function
      			oldTransA = transA;
      			transA = axisLength / ((max - min) || 1);
      							
      			// reset stacks
      			if (!isXAxis) {
      				for (type in stacks) {
      					for (i in stacks[type]) {
      						stacks[type][i].cum = stacks[type][i].total;
      					}
      				}
      			}
      
      			// mark as dirty if it is not already set to dirty and extremes have changed
      			if (!axis.isDirty) {
      				axis.isDirty = (min !== oldMin || max !== oldMax);
      			}
      			
      		}
      		
      		/**
      		 * Set the extremes and optionally redraw
      		 * @param {Number} newMin
      		 * @param {Number} newMax
      		 * @param {Boolean} redraw
      		 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      		 *    configuration
      		 * 
      		 */
      		function setExtremes(newMin, newMax, redraw, animation) {
      			
      			redraw = pick(redraw, true); // defaults to true
      				
      			fireEvent(axis, 'setExtremes', { // fire an event to enable syncing of multiple charts
      				min: newMin,
      				max: newMax
      			}, function() { // the default event handler
      				
      				userMin = newMin;
      				userMax = newMax;
      			
      				
      				// redraw
      				if (redraw) {
      					chart.redraw(animation);
      				}
      			});
      			
      		}
      		
      		/**
      		 * Get the actual axis extremes
      		 */
      		function getExtremes() {
      			return {
      				min: min,
      				max: max,
      				dataMin: dataMin,
      				dataMax: dataMax,
      				userMin: userMin,
      				userMax: userMax
      			};
      		}
      		
      		/**
      		 * Get the zero plane either based on zero or on the min or max value.
      		 * Used in bar and area plots
      		 */
      		function getThreshold(threshold) {
      			if (min > threshold) {
      				threshold = min;
      			} else if (max < threshold) {
      				threshold = max;
      			}
      			
      			return translate(threshold, 0, 1);
      		}
      		
      		/**
      		 * Add a plot band or plot line after render time
      		 * 
      		 * @param options {Object} The plotBand or plotLine configuration object
      		 */
      		function addPlotBandOrLine(options) {
      			var obj = new PlotLineOrBand(options).render();
      			plotLinesAndBands.push(obj);
      			return obj;
      		}
      		
      		/**
      		 * Render the tick labels to a preliminary position to get their sizes
      		 */
      		function getOffset() {
      			
      			var hasData = associatedSeries.length && defined(min) && defined(max),
      				titleOffset = 0,
      				titleMargin = 0,
      				axisTitleOptions = options.title,
      				labelOptions = options.labels,
      				directionFactor = [-1, 1, 1, -1][side],
      				n;
      			
      			if (!axisGroup) {
      				axisGroup = renderer.g('axis')
      					.attr({ zIndex: 7 })
      					.add();
      				gridGroup = renderer.g('grid')
      					.attr({ zIndex: 1 })
      					.add();
      			}
      			
      			labelOffset = 0; // reset
      			
      			if (hasData || isLinked) {
      				each(tickPositions, function(pos) {
      					if (!ticks[pos]) {
      						ticks[pos] = new Tick(pos);
      					} else {
      						ticks[pos].addLabel(); // update labels depending on tick interval
      					}
      					
      					// left side must be align: right and right side must have align: left for labels
      					if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === labelOptions.align) {
      					
      						// get the highest offset
      						labelOffset = mathMax(
      							ticks[pos].getLabelSize(),
      							labelOffset
      						);
      					}
      			
      				});
      				
      				if (staggerLines) {
      					labelOffset += (staggerLines - 1) * 16;
      				}
      			
      			} else { // doesn't have data
      				for (n in ticks) {
      					ticks[n].destroy();
      					delete ticks[n];
      				}
      			}
      			
      			if (axisTitleOptions && axisTitleOptions.text) {
      				if (!axis.axisTitle) {
      					axis.axisTitle = renderer.text(
      						axisTitleOptions.text,
      						0,
      						0
      					)
      					.attr({ 
      						zIndex: 7,
      						rotation: axisTitleOptions.rotation || 0,
      						align: 
      							axisTitleOptions.textAlign || 
      							{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
      					})
      					.css(axisTitleOptions.style)
      					.add();
      				}
      				
      				titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
      				titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);
      				
      			}
      			
      			// handle automatic or user set offset
      			offset = directionFactor * (options.offset || axisOffset[side]);
      			
      			axisTitleMargin = 
      				labelOffset +
      				(side !== 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x']) + 
      				titleMargin;
      			
      			axisOffset[side] = mathMax(
      				axisOffset[side], 
      				axisTitleMargin + titleOffset + directionFactor * offset
      			);
      			
      		}
      		
      		/**
      		 * Render the axis
      		 */
      		function render() {
      			var axisTitleOptions = options.title,
      				stackLabelOptions = options.stackLabels,
      				alternateGridColor = options.alternateGridColor,
      				lineWidth = options.lineWidth,
      				lineLeft,
      				lineTop,
      				linePath,
      				hasRendered = chart.hasRendered,
      				slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
      				hasData = associatedSeries.length && defined(min) && defined(max);
      			
      			// update metrics
      			axisLength = horiz ? plotWidth : plotHeight;
      			transA = axisLength / ((max - min) || 1);
      			transB = horiz ? plotLeft : marginBottom; // translation addend
      			
      			// If the series has data draw the ticks. Else only the line and title
      			if (hasData || isLinked) {
      				
      				// minor ticks
      				if (minorTickInterval && !categories) {
      					var pos = min + (tickPositions[0] - min) % minorTickInterval;
      					for (pos; pos <= max; pos += minorTickInterval) {
      						if (!minorTicks[pos]) {
      							minorTicks[pos] = new Tick(pos, true);
      						}
      						
      						// render new ticks in old position
      						if (slideInTicks && minorTicks[pos].isNew) {
      							minorTicks[pos].render(null, true);
      						}
      					
      						
      						minorTicks[pos].isActive = true;
      						minorTicks[pos].render();
      					}
      				}
      				
      				// major ticks
      				each(tickPositions, function(pos, i) {
      					// linked axes need an extra check to find out if 
      					if (!isLinked || (pos >= min && pos <= max)) {
      						
      						// render new ticks in old position
      						if (slideInTicks && ticks[pos].isNew) {
      							ticks[pos].render(i, true);
      						}
      						
      						ticks[pos].isActive = true;
      						ticks[pos].render(i);
      					}
      				});
      				
      				// alternate grid color
      				if (alternateGridColor) {
      					each(tickPositions, function(pos, i) {
      						if (i % 2 === 0 && pos < max) {
      							/*plotLinesAndBands.push(new PlotLineOrBand({
      								from: pos,
      								to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
      								color: alternateGridColor 
      							}));*/
      							
      							if (!alternateBands[pos]) {
      								alternateBands[pos] = new PlotLineOrBand();
      							}
      							alternateBands[pos].options = {
      								from: pos,
      								to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
      								color: alternateGridColor 
      							};
      							alternateBands[pos].render();
      							alternateBands[pos].isActive = true;
      						}
      					});
      				}
      				
      				// custom plot bands (behind grid lines)
      				/*if (!hasRendered) { // only first time
      					each(options.plotBands || [], function(plotBandOptions) {
      						plotLinesAndBands.push(new PlotLineOrBand(
      							extend({ zIndex: 1 }, plotBandOptions)
      						).render());
      					});
      				}*/
      				
      				
      				
      				
      				// custom plot lines and bands
      				if (!hasRendered) { // only first time
      					each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
      						plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
      					});
      				}
      				
      				
      			
      			} // end if hasData
      			
      			// remove inactive ticks
      			each([ticks, minorTicks, alternateBands], function(coll) {
      				var pos;
      				for (pos in coll) {
      					if (!coll[pos].isActive) {
      						coll[pos].destroy();
      						delete coll[pos];
      					} else {
      						coll[pos].isActive = false; // reset
      					}
      				}
      			});
      				
      				
      			
      			
      			// Static items. As the axis group is cleared on subsequent calls
      			// to render, these items are added outside the group.	
      			// axis line
      			if (lineWidth) {
      				lineLeft = plotLeft + (opposite ? plotWidth : 0) + offset;
      				lineTop = chartHeight - marginBottom - (opposite ? plotHeight : 0) + offset;
      				
      				linePath = renderer.crispLine([
      						M,
      						horiz ? 
      							plotLeft: 
      							lineLeft,
      						horiz ? 
      							lineTop: 
      							plotTop,
      						L, 
      						horiz ? 
      							chartWidth - marginRight : 
      							lineLeft,
      						horiz ? 
      							lineTop:
      							chartHeight - marginBottom
      					], lineWidth);
      				if (!axisLine) {
      					axisLine = renderer.path(linePath)
      						.attr({ 
      							stroke: options.lineColor, 
      							'stroke-width': lineWidth,
      							zIndex: 7
      						})
      						.add();
      				} else {
      					axisLine.animate({ d: linePath });
      				}
      					
      			}
      			
      			if (axis.axisTitle) {
      				// compute anchor points for each of the title align options
      				var margin = horiz ? plotLeft : plotTop,
      					fontSize = pInt(axisTitleOptions.style.fontSize || 12),
      				// the position in the length direction of the axis
      				alongAxis = { 
      					low: margin + (horiz ? 0 : axisLength), 
      					middle: margin + axisLength / 2, 
      					high: margin + (horiz ? axisLength : 0)
      				}[axisTitleOptions.align],
      				
      				// the position in the perpendicular direction of the axis
      				offAxis = (horiz ? plotTop + plotHeight : plotLeft) +
      					(horiz ? 1 : -1) * // horizontal axis reverses the margin
      					(opposite ? -1 : 1) * // so does opposite axes
      					axisTitleMargin +
      					//(isIE ? fontSize / 3 : 0)+ // preliminary fix for vml's centerline
      					(side === 2 ? fontSize : 0);
      				
      				axis.axisTitle[hasRendered ? 'animate' : 'attr']({
      					x: horiz ? 
      						alongAxis: 
      						offAxis + (opposite ? plotWidth : 0) + offset +
      							(axisTitleOptions.x || 0), // x
      					y: horiz ? 
      						offAxis - (opposite ? plotHeight : 0) + offset: 
      						alongAxis + (axisTitleOptions.y || 0) // y
      				});
      				
      			}
      			
      			// Stacked totals:
      			if (stackLabelOptions && stackLabelOptions.enabled) {
      				var stackKey, oneStack, stackCategory,
      					stackTotalGroup = axis.stackTotalGroup;
      
      				// Create a separate group for the stack total labels
      				if (!stackTotalGroup) {
      					axis.stackTotalGroup = stackTotalGroup =
      						renderer.g('stack-labels')
      							.attr({ 
      								visibility: VISIBLE,
      								zIndex: 6
      							})
      							.translate(plotLeft, plotTop)
      							.add();
      				}
      
      				// Render each stack total
      				for (stackKey in stacks) {
      					oneStack = stacks[stackKey];
      					for (stackCategory in oneStack) {
      						oneStack[stackCategory].render(stackTotalGroup);
      					}
      				}
      			}
      			// End stacked totals
      			
      			axis.isDirty = false;
      		}
      		
      		/**
      		 * Remove a plot band or plot line from the chart by id
      		 * @param {Object} id
      		 */
      		function removePlotBandOrLine(id) {
      			var i = plotLinesAndBands.length;
      			while (i--) {
      				if (plotLinesAndBands[i].id === id) {
      					plotLinesAndBands[i].destroy();
      				}
      			}
      		}
      		
      		/**
      		 * Redraw the axis to reflect changes in the data or axis extremes
      		 */
      		function redraw() {
      			
      			// hide tooltip and hover states
      			if (tracker.resetTracker) {
      				tracker.resetTracker();
      			}
      		
      			// render the axis
      			render();			
      			
      			// move plot lines and bands
      			each(plotLinesAndBands, function(plotLine) {
      				plotLine.render();
      			});
      			
      			// mark associated series as dirty and ready for redraw
      			each(associatedSeries, function(series) {
      				series.isDirty = true;
      			});
      						
      		}
      		
      		/**
      		 * Set new axis categories and optionally redraw
      		 * @param {Array} newCategories
      		 * @param {Boolean} doRedraw
      		 */
      		function setCategories(newCategories, doRedraw) {
      				// set the categories
      				axis.categories = categories = newCategories;
      				
      				// force reindexing tooltips
      				each(associatedSeries, function(series) {
      					series.translate();
      					series.setTooltipPoints(true);
      				});
      				
      				
      				// optionally redraw
      				axis.isDirty = true;
      				
      				if (pick(doRedraw, true)) {
      					chart.redraw();
      				}
      		}
      		
      		
      		
      		// Run Axis
      			
      		// inverted charts have reversed xAxes as default
      		if (inverted && isXAxis && reversed === UNDEFINED) {
      			reversed = true;
      		}
      		
      			
      		// expose some variables
      		extend(axis, {
      			addPlotBand: addPlotBandOrLine,
      			addPlotLine: addPlotBandOrLine,
      			adjustTickAmount: adjustTickAmount,
      			categories: categories,
      			getExtremes: getExtremes,
      			getPlotLinePath: getPlotLinePath,
      			getThreshold: getThreshold,
      			isXAxis: isXAxis,
      			options: options,
      			plotLinesAndBands: plotLinesAndBands,
      			getOffset: getOffset,
      			render: render,
      			setCategories: setCategories,
      			setExtremes: setExtremes,
      			setScale: setScale,
      			setTickPositions: setTickPositions,
      			translate: translate,
      			redraw: redraw,
      			removePlotBand: removePlotBandOrLine,
      			removePlotLine: removePlotBandOrLine,
      			reversed: reversed,
      			stacks: stacks
      		});
      		
      		// register event listeners
      		for (eventType in events) {
      			addEvent(axis, eventType, events[eventType]);
      		}
      		
      		// set min and max
      		setScale();
      	
      	} // end Axis
      	
      	
      	/**
      	 * The toolbar object
      	 * 
      	 * @param {Object} chart 
      	 */
      	function Toolbar(chart) {
      		var buttons = {};
      		
      		function add(id, text, title, fn) {
      			if (!buttons[id]) {
      				var button = renderer.text(
      					text,
      					0,
      					0
      				)
      				.css(options.toolbar.itemStyle)
      				.align({
      					align: 'right',
      					x: - marginRight - 20,
      					y: plotTop + 30
      				})
      				.on('click', fn)
      				/*.on('touchstart', function(e) {
      					e.stopPropagation(); // don't fire the container event
      					fn();
      				})*/
      				.attr({
      					align: 'right', 
      					zIndex: 20
      				})
      				.add();
      				buttons[id] = button;
      			}
      		}
      		function remove(id) {
      			discardElement(buttons[id].element);
      			buttons[id] = null;
      		}
      		
      		// public
      		return {
      			add: add,
      			remove: remove
      		};
      	}
      	
      	/**
      	 * The tooltip object
      	 * @param {Object} options Tooltip options
      	 */
      	function Tooltip (options) {
      		var currentSeries,
      			borderWidth = options.borderWidth,
      			crosshairsOptions = options.crosshairs,
      			crosshairs = [],
      			style = options.style,
      			shared = options.shared,
      			padding = pInt(style.padding),
      			boxOffLeft = borderWidth + padding, // off left/top position as IE can't 
      				//properly handle negative positioned shapes
      			tooltipIsHidden = true,
      			boxWidth,
      			boxHeight,
      			currentX = 0,			
      			currentY = 0;
      			
      		// remove padding CSS and apply padding on box instead
      		style.padding = 0;
      		
      		// create the elements
      		var group = renderer.g('tooltip')
      			.attr({	zIndex: 8 })
      			.add(),
      			
      			box = renderer.rect(boxOffLeft, boxOffLeft, 0, 0, options.borderRadius, borderWidth)
      				.attr({
      					fill: options.backgroundColor,
      					'stroke-width': borderWidth
      				})
      				.add(group)
      				.shadow(options.shadow),
      			label = renderer.text('', padding + boxOffLeft, pInt(style.fontSize) + padding + boxOffLeft)
      				.attr({ zIndex: 1 })
      				.css(style)
      				.add(group);
      				
      		group.hide();
      				
      		/**
      		 * In case no user defined formatter is given, this will be used
      		 */
      		function defaultFormatter() {
      			var pThis = this,
      				items = pThis.points || splat(pThis),
      				xAxis = items[0].series.xAxis,				
      				x = pThis.x,
      				isDateTime = xAxis && xAxis.options.type === 'datetime',
      				useHeader = isString(x) || isDateTime,
      				series,
      				s;
      			
      			// build the header	
      			s = useHeader ? 
      				['<span style="font-size: 10px">' +
      				(isDateTime ? dateFormat('%A, %b %e, %Y', x) :  x) +
      				'</span>'] : [];
      						
      			// build the values
      			each(items, function(item) {
      				s.push(item.point.tooltipFormatter(useHeader));
      			});
      			return s.join('<br/>');
      		}
      		
      		/**
      		 * Provide a soft movement for the tooltip
      		 * 
      		 * @param {Number} finalX
      		 * @param {Number} finalY 
      		 */
      		function move(finalX, finalY) {
      
      			currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
      			currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;
      			
      			group.translate(currentX, currentY);
      			
      			
      			// run on next tick of the mouse tracker
      			if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
      				tooltipTick = function() {
      					move(finalX, finalY);
      				};
      			} else {
      				tooltipTick = null;
      			}
      		}
      		
      		/**
      		 * Hide the tooltip
      		 */
      		function hide() {
      			if (!tooltipIsHidden) {
      				var hoverPoints = chart.hoverPoints;
      				
      				group.hide();
      			
      				each(crosshairs, function(crosshair) {
      					if (crosshair) {
      						crosshair.hide();
      					}
      				});
      			
      				// hide previous hoverPoints and set new
      				if (hoverPoints) {
      					each(hoverPoints, function(point) {
      						point.setState();
      					});
      				}
      				chart.hoverPoints = null;					
      				
      				
      				tooltipIsHidden = true;
      			}
      					
      		}
      		
      		/**
      		 * Refresh the tooltip's text and position. 
      		 * @param {Object} point
      		 * 
      		 */
      		function refresh(point) {
      			var x,
      				y,
      				boxX,
      				boxY,
      				show,
      				bBox,
      				plotX,
      				plotY = 0,
      				textConfig = {},
      				text,
      				pointConfig = [],
      				tooltipPos = point.tooltipPos,
      				formatter = options.formatter || defaultFormatter,
      				hoverPoints = chart.hoverPoints;
      				
      			// shared tooltip, array is sent over
      			if (shared) {
      				
      				// hide previous hoverPoints and set new
      				if (hoverPoints) {
      					each(hoverPoints, function(point) {
      						point.setState();
      					});
      				}
      				chart.hoverPoints = point;
      				 
      				each(point, function(item, i) {
      					/*var series = item.series,
      						hoverPoint = series.hoverPoint;
      					if (hoverPoint) {
      						hoverPoint.setState();
      					}
      					series.hoverPoint = item;*/
      					item.setState(HOVER_STATE);
      					plotY += item.plotY; // for average
      					
      					pointConfig.push(item.getLabelConfig());
      				});
      				
      				plotX = point[0].plotX;
      				plotY = mathRound(plotY) / point.length; // mathRound because Opera 10 has problems here
      				
      				textConfig = {
      					x: point[0].category
      				};
      				textConfig.points = pointConfig;
      				point = point[0];
      				
      			// single point tooltip
      			} else {
      				textConfig = point.getLabelConfig();
      			}
      			text = formatter.call(textConfig);
      			
      			// register the current series
      			currentSeries = point.series;
      			
      			// get the reference point coordinates (pie charts use tooltipPos)
      			plotX = shared ? plotX : point.plotX;
      			plotY = shared ? plotY : point.plotY;
      			x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
      			y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));
      				
      				
      			// hide tooltip if the point falls outside the plot
      			show = shared || !point.series.isCartesian || isInsidePlot(x, y);
      			
      			// update the inner HTML
      			if (text === false || !show) { 
      				hide();
      			} else {
      				
      			    // show it
      				if (tooltipIsHidden) {
      					group.show();
      					tooltipIsHidden = false;
      				}
      				
      				// update text
      				label.attr({
      					text: text
      				});
      				
      				// get the bounding box
      				bBox = label.getBBox();
      				boxWidth = bBox.width + 2 * padding;
      				boxHeight = bBox.height + 2 * padding;
      
      				// set the size of the box
      				box.attr({
      					width: boxWidth,
      					height: boxHeight,
      					stroke: options.borderColor || point.color || currentSeries.color || '#606060'
      				});
      				
      				// keep the box within the chart area
      				boxX = x - boxWidth + plotLeft - 25;
      				boxY = y - boxHeight + plotTop + 10;
      				
      				// it is too far to the left, adjust it
      				if (boxX < 7) {
      					boxX = plotLeft + x + 15;
      				}
      				
      				
      				if (boxY < 5) {
      					boxY = 5; // above
      				} else if (boxY + boxHeight > chartHeight) { 
      					boxY = chartHeight - boxHeight - 5; // below
      				}
      				
      				// do the move
      				move(mathRound(boxX - boxOffLeft), mathRound(boxY - boxOffLeft));
      				
      				
      			}
      			
      			
      			// crosshairs
      			if (crosshairsOptions) {
      				crosshairsOptions = splat(crosshairsOptions); // [x, y]
      				
      				var path, 
      					i = crosshairsOptions.length,
      					attribs,
      					axis;
      				
      				while (i--) {
      					axis = point.series[i ? 'yAxis' : 'xAxis'];
      					if (crosshairsOptions[i] && axis) {
      						path = axis
      							.getPlotLinePath(point[i ? 'y' : 'x'], 1);
      						if (crosshairs[i]) {
      							crosshairs[i].attr({ d: path, visibility: VISIBLE });
      						
      						} else {
      							attribs = {
      								'stroke-width': crosshairsOptions[i].width || 1,
      								stroke: crosshairsOptions[i].color || '#C0C0C0',
      								zIndex: 2
      							};
      							if (crosshairsOptions[i].dashStyle) {
      								attribs.dashstyle = crosshairsOptions[i].dashStyle;
      							}
      							crosshairs[i] = renderer.path(path)
      								.attr(attribs)
      								.add();
      						}
      					}
      				}				
      			}		
      		}
      		
      
      		
      		// public members
      		return {
      			shared: shared,
      			refresh: refresh,
      			hide: hide
      		};	
      	}
      	
      	/**
      	 * The mouse tracker object
      	 * @param {Object} chart
      	 * @param {Object} options
      	 */
      	function MouseTracker (chart, options) {
      
      		
      		var mouseDownX, 
      			mouseDownY,
      			hasDragged,
      			selectionMarker,
      			zoomType = optionsChart.zoomType,
      			zoomX = /x/.test(zoomType),
      			zoomY = /y/.test(zoomType),
      			zoomHor = (zoomX && !inverted) || (zoomY && inverted),
      			zoomVert = (zoomY && !inverted) || (zoomX && inverted);
      			
      		/**
      		 * Add crossbrowser support for chartX and chartY
      		 * @param {Object} e The event object in standard browsers
      		 */
      		function normalizeMouseEvent(e) {
      			var ePos,
      				pageZoomFix = isWebKit && doc.width / doc.documentElement.clientWidth - 1,
      				chartPosLeft,
      				chartPosTop,
      				chartX,
      				chartY;
      			
      			// common IE normalizing
      			e = e || win.event;
      			if (!e.target) {
      				e.target = e.srcElement;
      			}
      			
      			// iOS
      			ePos = e.touches ? e.touches.item(0) : e;
      			
      			// in certain cases, get mouse position
      			if (e.type !== 'mousemove' || win.opera || pageZoomFix) { // only Opera needs position on mouse move, see below
      				chartPosition = getPosition(container);
      				chartPosLeft = chartPosition.left;
      				chartPosTop = chartPosition.top;
      			}
      			
      			// chartX and chartY
      			if (isIE) { // IE including IE9 that has chartX but in a different meaning
      				chartX = e.x;
      				chartY = e.y;
      			} else {
      				if (ePos.layerX === UNDEFINED) { // Opera and iOS
      					chartX = ePos.pageX - chartPosLeft;
      					chartY = ePos.pageY - chartPosTop;
      				} else {
      					chartX = e.layerX;
      					chartY = e.layerY;
      				}
      			}
      			
      			// correct for page zoom bug in WebKit
      			if (pageZoomFix) {
      				chartX += mathRound((pageZoomFix + 1) * chartPosLeft - chartPosLeft);
      				chartY += mathRound((pageZoomFix + 1) * chartPosTop - chartPosTop);
      			}
      			
      			return extend(e, {
      				chartX: chartX,
      				chartY: chartY
      			});
      		}
      		
      		/**
      		 * Get the click position in terms of axis values.
      		 * 
      		 * @param {Object} e A mouse event
      		 */
      		function getMouseCoordinates(e) {
      			var coordinates = {
      				xAxis: [],
      				yAxis: []
      			}; 
      			each(axes, function(axis, i) {
      				var translate = axis.translate,
      					isXAxis = axis.isXAxis,
      					isHorizontal = inverted ? !isXAxis : isXAxis;
      					
      				coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
      					axis: axis,
      					value: translate(
      						isHorizontal ? 
      							e.chartX - plotLeft  : 
      							plotHeight - e.chartY + plotTop,
      						true
      					)								
      				});
      			});
      			return coordinates;
      		}
      		
      		/**
      		 * With line type charts with a single tracker, get the point closest to the mouse
      		 */
      		function onmousemove (e) {
      			var point,
      				points,
      				hoverPoint = chart.hoverPoint,
      				hoverSeries = chart.hoverSeries,
      				i,
      				j,
      				distance = chartWidth,
      				index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?
      				
      			// shared tooltip
      			if (tooltip && options.shared) {
      				points = [];
      				
      				// loop over all series and find the ones with points closest to the mouse
      				i = series.length;
      				for (j = 0; j < i; j++) {
      					if (series[j].visible && series[j].tooltipPoints.length) {
      						point = series[j].tooltipPoints[index];
      						point._dist = mathAbs(index - point.plotX);
      						distance = mathMin(distance, point._dist);
      						points.push(point);
      					}
      				}
      				// remove furthest points
      				i = points.length;
      				while (i--) {
      					if (points[i]._dist > distance) {
      						points.splice(i, 1);
      					}
      				}
      				// refresh the tooltip if necessary
      				if (points.length && (points[0].plotX !== hoverX)) {
      					tooltip.refresh(points);
      					hoverX = points[0].plotX;
      				}
      			}
      			
      			// separate tooltip and general mouse events
      			if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker
      		
      				// get the point
      				point = hoverSeries.tooltipPoints[index];
      				
      				// a new point is hovered, refresh the tooltip
      				if (point && point !== hoverPoint) {
      					
      					// trigger the events
      					point.onMouseOver();
      					
      				}				
      			}
      		}
      				
      		
      		
      		/**
      		 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
      		 */
      		function resetTracker() {
      			var hoverSeries = chart.hoverSeries,
      				hoverPoint = chart.hoverPoint;				
      
      			if (hoverPoint) {
      				hoverPoint.onMouseOut();
      			}
      			
      			if (hoverSeries) {
      				hoverSeries.onMouseOut();
      			}
      			
      			if (tooltip) {
      				tooltip.hide();
      			}
      			
      			hoverX = null;
      		}
      		
      		/**
      		 * Mouse up or outside the plot area
      		 */
      		function drop() {
      			if (selectionMarker) {
      				var selectionData = {
      						xAxis: [],
      						yAxis: []
      					},
      					selectionBox = selectionMarker.getBBox(),
      					selectionLeft = selectionBox.x - plotLeft,
      					selectionTop = selectionBox.y - plotTop;
      				
      					
      				// a selection has been made
      				if (hasDragged) {
      					
      					// record each axis' min and max
      					each(axes, function(axis, i) {
      						var translate = axis.translate,
      							isXAxis = axis.isXAxis,
      							isHorizontal = inverted ? !isXAxis : isXAxis,
      							selectionMin = translate(
      								isHorizontal ? 
      									selectionLeft : 
      									plotHeight - selectionTop - selectionBox.height, 
      								true,
      								0,
      								0,
      								1
      							),
      							selectionMax = translate(
      								isHorizontal ? 
      									selectionLeft + selectionBox.width : 
      									plotHeight - selectionTop, 
      								true,
      								0,
      								0,
      								1
      							);
      								
      							selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
      								axis: axis,
      								min: mathMin(selectionMin, selectionMax), // for reversed axes,
      								max: mathMax(selectionMin, selectionMax)
      							});
      							
      					});
      					fireEvent(chart, 'selection', selectionData, zoom);
      
      				}
      				selectionMarker = selectionMarker.destroy();
      			}
      			
      			chart.mouseIsDown = mouseIsDown = hasDragged = false;
      			removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
      
      		}
      		
      		/**
      		 * Set the JS events on the container element
      		 */
      		function setDOMEvents () {
      			var lastWasOutsidePlot = true;
      			
      			/*
      			 * Record the starting position of a dragoperation
      			 */
      			container.onmousedown = function(e) {
      				e = normalizeMouseEvent(e);
      				
      				// issue #295, dragging not always working in Firefox
      				if (!hasTouch && e.preventDefault) {
      					e.preventDefault();
      				}
      				
      				// record the start position
      				chart.mouseIsDown = mouseIsDown = true;
      				mouseDownX = e.chartX;
      				mouseDownY = e.chartY;
      				
      				addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
      			};
      						
      			// The mousemove, touchmove and touchstart event handler
      			var mouseMove = function(e) {
      
      				// let the system handle multitouch operations like two finger scroll
      				// and pinching
      				if (e && e.touches && e.touches.length > 1) {
      					return;
      				}
      				
      				// normalize
      				e = normalizeMouseEvent(e);
      				if (!hasTouch) { // not for touch devices
      					e.returnValue = false;
      				}
      				
      				var chartX = e.chartX,
      					chartY = e.chartY,
      					isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);
      					
      				// on touch devices, only trigger click if a handler is defined
      				if (hasTouch && e.type === 'touchstart') {
      					if (attr(e.target, 'isTracker')) {
      						if (!chart.runTrackerClick) {
      							e.preventDefault();
      						}	
      					} else if (!runChartClick && !isOutsidePlot) {
      						e.preventDefault();
      					}
      				}
      				
      				// cancel on mouse outside
      				if (isOutsidePlot) {
      				
      					if (!lastWasOutsidePlot) {
      						// reset the tracker					
      						resetTracker();	
      					}
      					
      					// drop the selection if any and reset mouseIsDown and hasDragged
      					//drop();
      					if (chartX < plotLeft) {
      						chartX = plotLeft;
      					} else if (chartX > plotLeft + plotWidth) {
      						chartX = plotLeft + plotWidth;
      					}
      					
      					if (chartY < plotTop) {
      						chartY = plotTop;
      					} else if (chartY > plotTop + plotHeight) {
      						chartY = plotTop + plotHeight;
      					}	
      					
      				}	
      					
      				if (mouseIsDown && e.type !== 'touchstart') { // make selection
      					
      					// determine if the mouse has moved more than 10px
      					hasDragged = Math.sqrt(
      						Math.pow(mouseDownX - chartX, 2) + 
      						Math.pow(mouseDownY - chartY, 2));
      					if (hasDragged > 10) {
      					
      						// make a selection
      						if (hasCartesianSeries && (zoomX || zoomY) && 
      								isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop)) {
      							if (!selectionMarker) {
      								selectionMarker = renderer.rect(
      									plotLeft,
      									plotTop,
      									zoomHor ? 1 : plotWidth,
      									zoomVert ? 1 : plotHeight,
      									0
      								)
      								.attr({
      									fill: 'rgba(69,114,167,0.25)',
      									zIndex: 7
      								})
      								.add();
      							}
      						}
      						
      						// adjust the width of the selection marker
      						if (selectionMarker && zoomHor) {
      							var xSize = chartX - mouseDownX;
      							selectionMarker.attr({
      								width: mathAbs(xSize),
      								x: (xSize > 0 ? 0 : xSize) + mouseDownX
      							});
      						}
      						// adjust the height of the selection marker
      						if (selectionMarker && zoomVert) {
      							var ySize = chartY - mouseDownY;
      							selectionMarker.attr({
      								height: mathAbs(ySize),
      								y: (ySize > 0 ? 0 : ySize) + mouseDownY
      							});
      						}
      					}
      					
      				} else if (!isOutsidePlot) {
      					// show the tooltip
      					onmousemove(e);
      				}
      				
      				lastWasOutsidePlot = isOutsidePlot;
      				
      				// when outside plot, allow touch-drag by returning true
      				return isOutsidePlot || !hasCartesianSeries;
      			};
      			
      			/*
      			 * When the mouse enters the container, run mouseMove
      			 */
      			container.onmousemove = mouseMove;
      			
      			/*
      			 * When the mouse leaves the container, hide the tracking (tooltip).
      			 */
      			addEvent(container, 'mouseleave', resetTracker);
      			
      			
      			container.ontouchstart = function(e) {
      				// For touch devices, use touchmove to zoom
      				if (zoomX || zoomY) {
      					container.onmousedown(e);
      				}
      				// Show tooltip and prevent the lower mouse pseudo event
      				mouseMove(e);
      			};
      			
      			/*
      			 * Allow dragging the finger over the chart to read the values on touch 
      			 * devices
      			 */
      			container.ontouchmove = mouseMove;
      			
      			/*
      			 * Allow dragging the finger over the chart to read the values on touch 
      			 * devices
      			 */
      			container.ontouchend = function() {
      				if (hasDragged) {
      					resetTracker();
      				}
      			};			
      			
      			
      			// MooTools 1.2.3 doesn't fire this in IE when using addEvent
      			container.onclick = function(e) {
      				var hoverPoint = chart.hoverPoint;
      				e = normalizeMouseEvent(e);
      				 
      				e.cancelBubble = true; // IE specific
      				
      				
      				if (!hasDragged) {
      					if (hoverPoint && attr(e.target, 'isTracker')) {
      						var plotX = hoverPoint.plotX,
      							plotY = hoverPoint.plotY;
      							
      						// add page position info
      						extend(hoverPoint, {
      							pageX: chartPosition.left + plotLeft + 
      								(inverted ? plotWidth - plotY : plotX),
      							pageY: chartPosition.top + plotTop + 
      								(inverted ? plotHeight - plotX : plotY)
      						});
      						
      						// the series click event
      						fireEvent(hoverPoint.series, 'click', extend(e, {
      							point: hoverPoint
      						}));
      						
      						// the point click event
      						hoverPoint.firePointEvent('click', e);
      					
      					} else { 
      						extend(e, getMouseCoordinates(e));
      						
      						// fire a click event in the chart
      						if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
      							fireEvent(chart, 'click', e);
      						}
      					}
      					
      					
      				}
      				// reset mouseIsDown and hasDragged
      				hasDragged = false;
      			};
      			
      		}
      		
      		/**
      		 * Create the image map that listens for mouseovers
      		 */
      		placeTrackerGroup = function() {
      			
      			// first create - plot positions is not final at this stage
      			if (!trackerGroup) {
      				chart.trackerGroup = trackerGroup = renderer.g('tracker')
      					.attr({ zIndex: 9 })
      					.add();
      			
      			// then position - this happens on load and after resizing and changing
      			// axis or box positions
      			} else {				
      				trackerGroup.translate(plotLeft, plotTop);
      				if (inverted) {
      					trackerGroup.attr({
      						width: chart.plotWidth,
      						height: chart.plotHeight
      					}).invert();
      				}
      			}			
      		};
      		
      		
      		// Run MouseTracker
      		placeTrackerGroup();
      		if (options.enabled) {
      			chart.tooltip = tooltip = Tooltip(options);
      		}
      		
      		setDOMEvents();
      		
      		// set the fixed interval ticking for the smooth tooltip
      		tooltipInterval = setInterval(function() {
      			if (tooltipTick) {
      				tooltipTick();
      			}
      		}, 32);
      		
      		// expose properties
      		extend(this, {
      			zoomX: zoomX,
      			zoomY: zoomY,
      			resetTracker: resetTracker
      		});
      	}
      	
      	
      	
      	/**
      	 * The overview of the chart's series
      	 * @param {Object} chart
      	 */
      	var Legend = function(chart) {
      
      		var options = chart.options.legend;
      			
      		if (!options.enabled) {
      			return;
      		}
      		
      		var horizontal = options.layout === 'horizontal',
      			symbolWidth = options.symbolWidth,
      			symbolPadding = options.symbolPadding,
      			allItems,
      			style = options.style,
      			itemStyle = options.itemStyle,
      			itemHoverStyle = options.itemHoverStyle,
      			itemHiddenStyle = options.itemHiddenStyle,
      			padding = pInt(style.padding),
      			rightPadding = 20,
      			//lineHeight = options.lineHeight || 16,
      			y = 18,
      			initialItemX = 4 + padding + symbolWidth + symbolPadding,
      			itemX,
      			itemY,
      			lastItemY,
      			itemHeight = 0,
      			box,
      			legendBorderWidth = options.borderWidth,
      			legendBackgroundColor = options.backgroundColor,
      			legendGroup,
      			offsetWidth,
      			widthOption = options.width,
      			series = chart.series,
      			reversedLegend = options.reversed;
      			
      			
      		
      		/**
      		 * Set the colors for the legend item
      		 * @param {Object} item A Series or Point instance
      		 * @param {Object} visible Dimmed or colored
      		 */
      		function colorizeItem(item, visible) {
      			var legendItem = item.legendItem,
      				legendLine = item.legendLine,
      				legendSymbol = item.legendSymbol,
      				hiddenColor = itemHiddenStyle.color,
      				textColor = visible ? options.itemStyle.color : hiddenColor,
      				lineColor = visible ? item.color : hiddenColor,
      				symbolAttr = visible ? item.pointAttr[NORMAL_STATE] : {
      					stroke: hiddenColor,
      					fill: hiddenColor
      				};
      					
      			if (legendItem) {
      				legendItem.css({ fill: textColor });
      			}
      			if (legendLine) {
      				legendLine.attr({ stroke: lineColor });
      			}
      			if (legendSymbol) {
      				legendSymbol.attr(symbolAttr);
      			}
      			
      		}
      		
      		/**
      		 * Position the legend item
      		 * @param {Object} item A Series or Point instance
      		 * @param {Object} visible Dimmed or colored
      		 */
      		function positionItem(item, itemX, itemY) {
      			var legendItem = item.legendItem,
      				legendLine = item.legendLine,
      				legendSymbol = item.legendSymbol,
      				checkbox = item.checkbox;
      			if (legendItem) {
      				legendItem.attr({ 
      					x: itemX,
      					y: itemY
      				});
      			}
      			if (legendLine) {
      				legendLine.translate(itemX, itemY - 4);
      			}
      			if (legendSymbol) {
      				legendSymbol.attr({
      					x: itemX + legendSymbol.xOff, 
      					y: itemY + legendSymbol.yOff
      				});
      			}
      			if (checkbox) {
      				checkbox.x = itemX;
      				checkbox.y = itemY;
      			}
      		}
      		
      		/**
      		 * Destroy a single legend item
      		 * @param {Object} item The series or point
      		 */
      		function destroyItem(item) {
      			var checkbox = item.checkbox;
      				
      			// pull out from the array
      			//erase(allItems, item);
      				
      			// destroy SVG elements
      			each(['legendItem', 'legendLine', 'legendSymbol'], function(key) {
      				if (item[key]) {
      					item[key].destroy();
      				}
      			});
      			
      			if (checkbox) {
      				discardElement(item.checkbox);
      			}
      			
      			
      		}
      		
      		
      		/**
      		 * Position the checkboxes after the width is determined
      		 */ 
      		function positionCheckboxes() {
      			each(allItems, function(item) {
      				var checkbox = item.checkbox,
      					alignAttr = legendGroup.alignAttr;
      				if (checkbox) {
      					css(checkbox, {
      						left: (alignAttr.translateX + item.legendItemWidth + checkbox.x - 40) +PX,
      						top: (alignAttr.translateY + checkbox.y - 11) + PX 
      					});
      				}
      			});
      		}
      		
      		/**
      		 * Render a single specific legend item
      		 * @param {Object} item A series or point
      		 */
      		function renderItem(item) {
      			var bBox,
      				itemWidth,
      				legendSymbol,
      				symbolX,
      				symbolY,
      				attribs,
      				simpleSymbol,
      				li = item.legendItem,
      				series = item.series || item,
      				i = allItems.length,
      				itemOptions = series.options,
      				strokeWidth = (itemOptions && itemOptions.borderWidth) || 0;				
      			
      			if (!li) { // generate it once, later move it
      			
      				// let these series types use a simple symbol
      				simpleSymbol = /^(bar|pie|area|column)$/.test(series.type);
      				
      				// generate the list item text
      				item.legendItem = li = renderer.text(
      						options.labelFormatter.call(item),
      						0, 
      						0
      					)
      					.css(item.visible ? itemStyle : itemHiddenStyle)
      					.on('mouseover', function() {
      						item.setState(HOVER_STATE);
      						li.css(itemHoverStyle);
      					})
      					.on('mouseout', function() {
      						li.css(item.visible ? itemStyle : itemHiddenStyle);
      						item.setState();
      					})
      					.on('click', function(event) {
      						var strLegendItemClick = 'legendItemClick',
      							fnLegendItemClick = function() {
      								item.setVisible();
      							};
      						
      						// click the name or symbol
      						if (item.firePointEvent) { // point
      							item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
      						} else {
      							fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
      						}
      					})
      					.attr({ zIndex: 2 })
      					.add(legendGroup);
      				
      				// draw the line
      				if (!simpleSymbol && itemOptions && itemOptions.lineWidth) {
      					var attrs = {
      							'stroke-width': itemOptions.lineWidth,
      							zIndex: 2
      						};
      					if (itemOptions.dashStyle) {
      						attrs.dashstyle = itemOptions.dashStyle;
      					}
      					item.legendLine = renderer.path([
      						M,
      						-symbolWidth - symbolPadding, 
      						0,
      						L, 
      						-symbolPadding, 
      						0
      					])
      					.attr(attrs)
      					.add(legendGroup);
      				}
      					
      				// draw a simple symbol
      				if (simpleSymbol) { // bar|pie|area|column
      					
      					legendSymbol = renderer.rect(
      						(symbolX = -symbolWidth - symbolPadding),
      						(symbolY = -11),
      						symbolWidth,
      						12,
      						2
      					).attr({
      						//'stroke-width': 0,
      						zIndex: 3
      					}).add(legendGroup);
      				}
      					
      				// draw the marker
      				else if (itemOptions && itemOptions.marker && itemOptions.marker.enabled) {
      					legendSymbol = renderer.symbol(
      						item.symbol,
      						(symbolX = -symbolWidth / 2 - symbolPadding), 
      						(symbolY = -4),
      						itemOptions.marker.radius
      					)
      					//.attr(item.pointAttr[NORMAL_STATE])
      					.attr({ zIndex: 3 })
      					.add(legendGroup);
      				
      				}
      				if (legendSymbol) {
      					legendSymbol.xOff = symbolX + (strokeWidth % 2 / 2);
      					legendSymbol.yOff = symbolY + (strokeWidth % 2 / 2);
      				}
      				
      				item.legendSymbol = legendSymbol;
      					
      				// colorize the items
      				colorizeItem(item, item.visible);
      				
      				
      				// add the HTML checkbox on top
      				if (itemOptions && itemOptions.showCheckbox) {
      					item.checkbox = createElement('input', {
      						type: 'checkbox',
      						checked: item.selected,
      						defaultChecked: item.selected // required by IE7						
      					}, options.itemCheckboxStyle, container);
      					
      					addEvent(item.checkbox, 'click', function(event) {
      						var target = event.target;
      						fireEvent(item, 'checkboxClick', { 
      								checked: target.checked 
      							}, 
      							function() {
      								item.select();
      							}
      						);
      					});
      				}
      			}
      			
      			
      			// calculate the positions for the next line
      			bBox = li.getBBox();
      			
      			itemWidth = item.legendItemWidth =  
      				options.itemWidth || symbolWidth + symbolPadding + bBox.width + rightPadding;
      			itemHeight = bBox.height;
      			
      			// if the item exceeds the width, start a new line
      			if (horizontal && itemX - initialItemX + itemWidth > 
      					(widthOption || (chartWidth - 2 * padding - initialItemX))) {
      				itemX = initialItemX;
      				itemY += itemHeight;
      			}		
      			lastItemY = itemY;
      			
      			// position the newly generated or reordered items
      			positionItem(item, itemX, itemY);
      			
      			// advance
      			if (horizontal)  {
      				itemX += itemWidth;
      			} else {
      				itemY += itemHeight;
      			}
      			
      			// the width of the widest item
      			offsetWidth = widthOption || mathMax(
      				horizontal ? itemX - initialItemX : itemWidth, 
      				offsetWidth
      			);
      			
      					
      			
      			// add it all to an array to use below
      			//allItems.push(item);
      		}
      
      		/**
      		 * Render the legend. This method can be called both before and after
      		 * chart.render. If called after, it will only rearrange items instead
      		 * of creating new ones.
      		 */
      		function renderLegend() {
      			itemX = initialItemX;
      			itemY = y;
      			offsetWidth = 0;
      			lastItemY = 0;
      			
      			if (!legendGroup) {
      				legendGroup = renderer.g('legend')
      					.attr({ zIndex: 7 })
      					.add();
      			}
      			
      			
      			// add each series or point
      			allItems = [];
      			each(series, function(serie) {
      				var seriesOptions = serie.options;
      				
      				if (!seriesOptions.showInLegend) {
      					return;
      				}
      				
      				// use points or series for the legend item depending on legendType
      				allItems = allItems.concat(seriesOptions.legendType === 'point' ?
      					serie.data : 
      					serie
      				);
      				
      			});
      			
      			// sort by legendIndex
      			allItems.sort(function(a, b) {
      				return (a.options.legendIndex || 0) - (b.options.legendIndex || 0);
      			});
      			
      			// reversed legend
      			if (reversedLegend) {
      				allItems.reverse();
      			}
      			
      			// render the items
      			each(allItems, renderItem);
      			
      			
      			
      			// Draw the border
      			legendWidth = widthOption || offsetWidth;
      			legendHeight = lastItemY - y + itemHeight;
      			
      			if (legendBorderWidth || legendBackgroundColor) {
      				legendWidth += 2 * padding;
      				legendHeight += 2 * padding;
      				
      				if (!box) {
      					box = renderer.rect(
      						0, 
      						0,
      						legendWidth,
      						legendHeight,
      						options.borderRadius,
      						legendBorderWidth || 0
      					).attr({
      						stroke: options.borderColor,
      						'stroke-width': legendBorderWidth || 0,
      						fill: legendBackgroundColor || NONE
      					})
      					.add(legendGroup)
      					.shadow(options.shadow);
      				
      				} else if (legendWidth > 0 && legendHeight > 0) {
      					box.animate(
      						box.crisp(null, null, null, legendWidth, legendHeight)
      					);
      				}
      				
      				// hide the border if no items
      				box[allItems.length ? 'show' : 'hide']();
      			}
      			
      			// 1.x compatibility: positioning based on style
      			var props = ['left', 'right', 'top', 'bottom'],
      				prop,
      				i = 4;
      			while(i--) {
      				prop = props[i];
      				if (style[prop] && style[prop] !== 'auto') {
      					options[i < 2 ? 'align' : 'verticalAlign'] = prop;
      					options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
      				}
      			}
      			
      			legendGroup.align(extend(options, {
      				width: legendWidth,
      				height: legendHeight
      			}), true, spacingBox);
      			
      			if (!isResizing) {
      				positionCheckboxes();
      			}
      		}
      		
      		
      		// run legend
      		renderLegend();
      		
      		// move checkboxes
      		addEvent(chart, 'endResize', positionCheckboxes);
      		
      		// expose 
      		return {
      			colorizeItem: colorizeItem,
      			destroyItem: destroyItem,
      			renderLegend: renderLegend
      		};
      	};
      	
      	
      	
      		
      	
      
      	/** 
      	 * Initialize an individual series, called internally before render time
      	 */
      	function initSeries(options) {
      		var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
      			typeClass = seriesTypes[type],
      			serie,
      			hasRendered = chart.hasRendered;
      			
      		// an inverted chart can't take a column series and vice versa
      		if (hasRendered) {
      			if (inverted && type === 'column') {
      				typeClass = seriesTypes.bar;
      			} else if (!inverted && type === 'bar') {
      				typeClass = seriesTypes.column;
      			}
      		}
      		
      		serie = new typeClass();
      		
      		serie.init(chart, options);
      		
      		// set internal chart properties
      		if (!hasRendered && serie.inverted) {
      			inverted = true;
      		}
      		if (serie.isCartesian) {
      			hasCartesianSeries = serie.isCartesian;
      		}
      		
      		series.push(serie);
      		
      		return serie;
      	}
      
      	/**
      	 * Add a series dynamically after  time
      	 * 
      	 * @param {Object} options The config options
      	 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
      	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      	 *    configuration
      	 * 
      	 * @return {Object} series The newly created series object
      	 */
      	function addSeries(options, redraw, animation) {
      		var series;
      		
      		if (options) {
      			setAnimation(animation, chart);
      			redraw = pick(redraw, true); // defaults to true
      			
      			fireEvent(chart, 'addSeries', { options: options }, function() {
      				series = initSeries(options);
      				series.isDirty = true;
      				
      				chart.isDirtyLegend = true; // the series array is out of sync with the display
      				if (redraw) {
      					chart.redraw();
      				}
      			});
      		}
      		
      		return series;
      	}
      	
      	/**
      	 * Check whether a given point is within the plot area
      	 * 
      	 * @param {Number} x Pixel x relative to the coordinateSystem
      	 * @param {Number} y Pixel y relative to the coordinateSystem
      	 */
      	isInsidePlot = function(x, y) {
      		return x >= 0 &&
      			x <= plotWidth &&
      			y >= 0 &&
      			y <= plotHeight;
      	};
      		
      	/**
      	 * Adjust all axes tick amounts
      	 */
      	function adjustTickAmounts() {
      		if (optionsChart.alignTicks !== false) {
      			each(axes, function(axis) {
      				axis.adjustTickAmount();
      			});
      		}
      		maxTicks = null;
      	}
      
      	/**
      	 * Redraw legend, axes or series based on updated data
      	 * 
      	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      	 *    configuration
      	 */
      	function redraw(animation) {
      		var redrawLegend = chart.isDirtyLegend,
      			hasStackedSeries,
      			isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
      			seriesLength = series.length,
      			i = seriesLength,
      			clipRect = chart.clipRect,
      			serie;
      			
      		setAnimation(animation, chart);
      		
      		// link stacked series
      		while (i--) {
      			serie = series[i];
      			if (serie.isDirty && serie.options.stacking) {
      				hasStackedSeries = true;
      				break;
      			}
      		}
      		if (hasStackedSeries) { // mark others as dirty
      			i = seriesLength;
      			while (i--) {
      				serie = series[i];
      				if (serie.options.stacking) {
      					serie.isDirty = true;
      				}
      			}
      		}
      		
      		// handle updated data in the series		
      		each(series, function(serie) {
      			if (serie.isDirty) { // prepare the data so axis can read it
      				serie.cleanData();
      				serie.getSegments();
      				
      				if (serie.options.legendType === 'point') {
      					redrawLegend = true;
      				}
      			}
      		});
      		
      		// handle added or removed series
      		if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
      			// draw legend graphics
      			legend.renderLegend();
      			
      			chart.isDirtyLegend = false;
      		}
      				
      		if (hasCartesianSeries) {
      			if (!isResizing) {
      				
      				// reset maxTicks
      				maxTicks = null;				
      				
      				// set axes scales
      				each(axes, function(axis) {
      					axis.setScale();
      				});
      			}
      			adjustTickAmounts();
      			getMargins();
      	
      			// redraw axes
      			each(axes, function(axis) {
      				if (axis.isDirty || isDirtyBox) {
      					axis.redraw();
      					isDirtyBox = true; // always redraw box to reflect changes in the axis labels 
      				}
      			});
      			
      			
      		}
      		
      		// the plot areas size has changed
      		if (isDirtyBox) {
      			drawChartBox();
      			placeTrackerGroup();
      			
      			// move clip rect
      			if (clipRect) {
      				stop(clipRect);
      				clipRect.animate({ // for chart resize
      					width: chart.plotSizeX,
      					height: chart.plotSizeY
      				});
      			}
      		
      		}
      		
      					
      		// redraw affected series
      		each(series, function(serie) {
      			if (serie.isDirty && serie.visible && 
      					(!serie.isCartesian || serie.xAxis)) { // issue #153 
      				serie.redraw();
      			}
      		});
      		
      		
      		// hide tooltip and hover states
      		if (tracker && tracker.resetTracker) {
      			tracker.resetTracker();
      		}
      		
      		// fire the event
      		fireEvent(chart, 'redraw');
      	}
      	
      	
      	
      	/**
      	 * Dim the chart and show a loading text or symbol
      	 * @param {String} str An optional text to show in the loading label instead of the default one
      	 */
      	function showLoading(str) {
      		var loadingOptions = options.loading;
      
      		// create the layer at the first call
      		if (!loadingDiv) {
      			loadingDiv = createElement(DIV, {
      				className: 'highcharts-loading'
      			}, extend(loadingOptions.style, {
      				left: plotLeft + PX,
      				top: plotTop + PX,
      				width: plotWidth + PX,
      				height: plotHeight + PX,
      				zIndex: 10,
      				display: NONE
      			}), container);
      			
      			loadingSpan = createElement(
      				'span', 
      				null, 
      				loadingOptions.labelStyle, 
      				loadingDiv
      			);
      
      		}
      		
      		// update text
      		loadingSpan.innerHTML = str || options.lang.loading;
      		
      		// show it
      		if (!loadingShown) {
      			css(loadingDiv, { opacity: 0, display: '' });
      			animate(loadingDiv, {
      				opacity: loadingOptions.style.opacity
      			}, {
      				duration: loadingOptions.showDuration
      			});
      			loadingShown = true;
      		}
      	}
      	/**
      	 * Hide the loading layer
      	 */
      	function hideLoading() {
      		animate(loadingDiv, {
      			opacity: 0
      		}, {
      			duration: options.loading.hideDuration, 
      			complete: function() {
      				css(loadingDiv, { display: NONE });
      			}
      		});
      		loadingShown = false;
      	}
      	
      	/**
      	 * Get an axis, series or point object by id.
      	 * @param id {String} The id as given in the configuration options
      	 */
      	function get(id) {
      		var i,
      			j,
      			data;
      		
      		// search axes
      		for (i = 0; i < axes.length; i++) {
      			if (axes[i].options.id === id) {
      				return axes[i];
      			}
      		}
      		
      		// search series
      		for (i = 0; i < series.length; i++) {
      			if (series[i].options.id === id) {
      				return series[i];
      			}
      		}
      		
      		// search points
      		for (i = 0; i < series.length; i++) {
      			data = series[i].data;
      			for (j = 0; j < data.length; j++) {
      				if (data[j].id === id) {
      					return data[j];
      				}
      			}
      		}
      		return null;	
      	}
      	
      	/** 
      	 * Create the Axis instances based on the config options
      	 */
      	function getAxes() {
      		var xAxisOptions = options.xAxis || {},
      			yAxisOptions = options.yAxis || {},
      			axis;
      			
      		// make sure the options are arrays and add some members
      		xAxisOptions = splat(xAxisOptions);
      		each(xAxisOptions, function(axis, i) {
      			axis.index = i; 
      			axis.isX = true;
      		});
      		
      		yAxisOptions = splat(yAxisOptions);
      		each(yAxisOptions, function(axis, i) {
      			axis.index = i;
      		});
      		
      		// concatenate all axis options into one array
      		axes = xAxisOptions.concat(yAxisOptions);
      		
      		// loop the options and construct axis objects
      		chart.xAxis = [];
      		chart.yAxis = [];
      		axes = map(axes, function(axisOptions) {
      			axis = new Axis(chart, axisOptions);
      			chart[axis.isXAxis ? 'xAxis' : 'yAxis'].push(axis);
      			
      			return axis;
      		});
      		
      		adjustTickAmounts();
      	}
      
      	
      	/**
      	 * Get the currently selected points from all series
      	 */
      	function getSelectedPoints() {
      		var points = [];
      		each(series, function(serie) {
      			points = points.concat( grep( serie.data, function(point) {
      				return point.selected;
      			}));
      		});
      		return points;
      	}
      	
      	/**
      	 * Get the currently selected series
      	 */
      	function getSelectedSeries() {
      		return grep(series, function (serie) {
      			return serie.selected;
      		});
      	}
      	
      	/**
      	 * Zoom out to 1:1
      	 */
      	zoomOut = function () {
      		fireEvent(chart, 'selection', { resetSelection: true }, zoom);
      		chart.toolbar.remove('zoom');
      
      	};
      	/**
      	 * Zoom into a given portion of the chart given by axis coordinates
      	 * @param {Object} event
      	 */
      	zoom = function (event) {
      		
      		// add button to reset selection
      		var lang = defaultOptions.lang,
      			animate = chart.pointCount < 100;
      		chart.toolbar.add('zoom', lang.resetZoom, lang.resetZoomTitle, zoomOut);
      		
      		// if zoom is called with no arguments, reset the axes
      		if (!event || event.resetSelection) {
      			each(axes, function(axis) {
      				axis.setExtremes(null, null, false, animate);
      			});
      		}
      			
      		// else, zoom in on all axes
      		else {
      			each(event.xAxis.concat(event.yAxis), function(axisData) {
      				var axis = axisData.axis;
      				
      				// don't zoom more than maxZoom
      				if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
      					axis.setExtremes(axisData.min, axisData.max, false, animate);
      				}
      			});
      		}
      		
      		// redraw chart
      		redraw();
      	};
      	
      	/**
      	 * Show the title and subtitle of the chart
      	 * 
      	 * @param titleOptions {Object} New title options
      	 * @param subtitleOptions {Object} New subtitle options
      	 * 
      	 */
      	function setTitle (titleOptions, subtitleOptions) {
      		
      		chartTitleOptions = merge(options.title, titleOptions);
      		chartSubtitleOptions = merge(options.subtitle, subtitleOptions);
      		
      		// add title and subtitle
      		each([
      			['title', titleOptions, chartTitleOptions],
      			['subtitle', subtitleOptions, chartSubtitleOptions]
      		], function(arr) {
      			var name = arr[0],
      				title = chart[name],
      				titleOptions = arr[1],
      				chartTitleOptions = arr[2];
      				
      			if (title && titleOptions) {
      				title.destroy(); // remove old
      				title = null;
      			}
      			if (chartTitleOptions && chartTitleOptions.text && !title) {
      				chart[name] = renderer.text(
      					chartTitleOptions.text, 
      					0,
      					0
      				)
      				.attr({
      					align: chartTitleOptions.align,
      					'class': 'highcharts-'+ name,
      					zIndex: 1
      				})
      				.css(chartTitleOptions.style)
      				.add()
      				.align(chartTitleOptions, false, spacingBox);
      			}
      		});
      		
      	}
      	
      	/**
      	 * Get chart width and height according to options and container size
      	 */
      	function getChartSize() {
      
      		containerWidth = (renderToClone || renderTo).offsetWidth;
      		containerHeight = (renderToClone || renderTo).offsetHeight;
      		chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
      		chart.chartHeight = chartHeight = optionsChart.height || 
      			// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
      			(containerHeight > 19 ? containerHeight : 400);
      	}
      
      	
      	/**
      	 * Get the containing element, determine the size and create the inner container
      	 * div to hold the chart
      	 */
      	function getContainer() {
      		renderTo = optionsChart.renderTo;
      		containerId = PREFIX + idCounter++;
      	
      		if (isString(renderTo)) {
      			renderTo = doc.getElementById(renderTo);
      		}
      	
      		// remove previous chart
      		renderTo.innerHTML = '';
      		
      		// If the container doesn't have an offsetWidth, it has or is a child of a node
      		// that has display:none. We need to temporarily move it out to a visible
      		// state to determine the size, else the legend and tooltips won't render
      		// properly 
      		if (!renderTo.offsetWidth) {
      			renderToClone = renderTo.cloneNode(0);
      			css(renderToClone, {
      				position: ABSOLUTE,
      				top: '-9999px',
      				display: ''
      			});
      			doc.body.appendChild(renderToClone);
      		}
      		
      		// get the width and height
      		getChartSize();
      		
      		// create the inner container
      		chart.container = container = createElement(DIV, {
      				className: 'highcharts-container' + 
      					(optionsChart.className ? ' '+ optionsChart.className : ''),
      				id: containerId
      			}, extend({
      				position: RELATIVE,
      				overflow: HIDDEN, // needed for context menu (avoid scrollbars) and  
      					// content overflow in IE
      				width: chartWidth + PX,
      				height: chartHeight + PX,
      				textAlign: 'left'
      			}, optionsChart.style),
      			renderToClone || renderTo
      		);
      		
      		chart.renderer = renderer = 
      			optionsChart.forExport ? // force SVG, used for SVG export
      				new SVGRenderer(container, chartWidth, chartHeight, true) : 
      				new Renderer(container, chartWidth, chartHeight);
      				
      		// Issue 110 workaround:
      		// In Firefox, if a div is positioned by percentage, its pixel position may land
      		// between pixels. The container itself doesn't display this, but an SVG element
      		// inside this container will be drawn at subpixel precision. In order to draw
      		// sharp lines, this must be compensated for. This doesn't seem to work inside
      		// iframes though (like in jsFiddle).
      		var subPixelFix, rect;
      		if (isFirefox && container.getBoundingClientRect) {
      			subPixelFix = function() {
      				css(container, { left: 0, top: 0 });
      				rect = container.getBoundingClientRect();
      				css(container, {
      					left: (-(rect.left - pInt(rect.left))) + PX,
      					top: (-(rect.top - pInt(rect.top))) + PX
      				});
      			};
      			
      			// run the fix now
      			subPixelFix();
      			
      			// run it on resize
      			addEvent(win, 'resize', subPixelFix);
      			
      			// remove it on chart destroy
      			addEvent(chart, 'destroy', function() {
      				removeEvent(win, 'resize', subPixelFix);
      			});
      		}
      	}
      	
      	/**
      	 * Calculate margins by rendering axis labels in a preliminary position. Title,
      	 * subtitle and legend have already been rendered at this stage, but will be 
      	 * moved into their final positions
      	 */
      	getMargins = function() {
      		var legendOptions = options.legend,
      			legendMargin = pick(legendOptions.margin, 10),
      			legendX = legendOptions.x,
      			legendY = legendOptions.y,
      			align = legendOptions.align,
      			verticalAlign = legendOptions.verticalAlign,
      			titleOffset;
      
      		resetMargins();
      
      		// adjust for title and subtitle
      		if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
      			titleOffset = mathMax(
      				(chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y) || 0, 
      				(chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y) || 0				
      			);
      			if (titleOffset) {
      				plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
      			}
      		}
      		// adjust for legend
      		if (legendOptions.enabled && !legendOptions.floating) {
      			if (align === 'right') { // horizontal alignment handled first
      				if (!defined(optionsMarginRight)) {
      					marginRight = mathMax(
      						marginRight,
      						legendWidth - legendX + legendMargin + spacingRight
      					);
      				}
      			} else if (align === 'left') {
      				if (!defined(optionsMarginLeft)) {
      					plotLeft = mathMax(
      						plotLeft,
      						legendWidth + legendX + legendMargin + spacingLeft
      					);
      				}
      				
      			} else if (verticalAlign === 'top') {
      				if (!defined(optionsMarginTop)) {
      					plotTop = mathMax(
      						plotTop, 
      						legendHeight + legendY + legendMargin + spacingTop
      					);
      				}
      			
      			} else if (verticalAlign === 'bottom') {
      				if (!defined(optionsMarginBottom)) {
      					marginBottom = mathMax(
      						marginBottom, 
      						legendHeight - legendY + legendMargin + spacingBottom
      					);
      				}
      			}
      		}
      		
      		// pre-render axes to get labels offset width
      		if (hasCartesianSeries) {
      			each(axes, function(axis) {
      				axis.getOffset();
      			});
      		}
      		
      		if (!defined(optionsMarginLeft)) {
      			plotLeft += axisOffset[3];
      		}
      		if (!defined(optionsMarginTop)) {
      			plotTop += axisOffset[0];
      		}
      		if (!defined(optionsMarginBottom)) {
      			marginBottom += axisOffset[2];
      		}
      		if (!defined(optionsMarginRight)) {
      			marginRight += axisOffset[1];
      		}
      		
      		setChartSize();
      		
      	};
      	
      	/**
      	 * Add the event handlers necessary for auto resizing
      	 * 
      	 */
      	function initReflow() {
      		var reflowTimeout;
      		function reflow() {
      			var width = optionsChart.width || renderTo.offsetWidth,
      				height = optionsChart.height || renderTo.offsetHeight;
      			
      			if (width && height) { // means container is display:none
      				if (width !== containerWidth || height !== containerHeight) {
      					clearTimeout(reflowTimeout);
      					reflowTimeout = setTimeout(function() {
      						resize(width, height, false);
      					}, 100);
      				}
      				containerWidth = width;
      				containerHeight = height;
      			}
      		}
      		addEvent(win, 'resize', reflow);
      		addEvent(chart, 'destroy', function() {
      			removeEvent(win, 'resize', reflow);
      		});
      	}
      	
      	/**
      	 * Resize the chart to a given width and height
      	 * @param {Number} width
      	 * @param {Number} height
      	 * @param {Object|Boolean} animation
      	 */
      	resize = function(width, height, animation) {
      		var chartTitle = chart.title,
      			chartSubtitle = chart.subtitle;
      		
      		isResizing += 1;
      		
      		// set the animation for the current process
      		setAnimation(animation, chart);
      		
      		oldChartHeight = chartHeight;
      		oldChartWidth = chartWidth;
      		chart.chartWidth = chartWidth = mathRound(width);
      		chart.chartHeight = chartHeight = mathRound(height);
      		
      		css(container, {
      			width: chartWidth + PX,
      			height: chartHeight + PX
      		});
      		renderer.setSize(chartWidth, chartHeight, animation);
      		
      		// update axis lengths for more correct tick intervals:
      		plotWidth = chartWidth - plotLeft - marginRight; 
      		plotHeight = chartHeight - plotTop - marginBottom;
      		
      		// handle axes
      		maxTicks = null;
      		each(axes, function(axis) {
      			axis.isDirty = true;
      			axis.setScale();
      		});
      		
      		// make sure non-cartesian series are also handled
      		each(series, function(serie) {
      			serie.isDirty = true;
      		});
      		
      		chart.isDirtyLegend = true; // force legend redraw
      		chart.isDirtyBox = true; // force redraw of plot and chart border
      		
      		getMargins();
      		 
      		// move titles
      		if (chartTitle) {
      			chartTitle.align(null, null, spacingBox);
      		}
      		if (chartSubtitle) {
      			chartSubtitle.align(null, null, spacingBox);
      		}
      		
      		redraw(animation);
      		
      		
      		oldChartHeight = null;
      		fireEvent(chart, 'resize');
      		
      		// fire endResize and set isResizing back 
      		setTimeout(function() {
      			fireEvent(chart, 'endResize', null, function() {
      				isResizing -= 1;
      			});
      		}, (globalAnimation && globalAnimation.duration) || 500);
      	};
      	
      	/**
      	 * Set the public chart properties. This is done before and after the pre-render
      	 * to determine margin sizes
      	 */
      	setChartSize = function() {
      		
      		chart.plotLeft = plotLeft = mathRound(plotLeft);
      		chart.plotTop = plotTop = mathRound(plotTop);
      		chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
      		chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);
      		
      		chart.plotSizeX = inverted ? plotHeight : plotWidth;
      		chart.plotSizeY = inverted ? plotWidth : plotHeight;
      		
      		spacingBox = {
      			x: spacingLeft,
      			y: spacingTop,
      			width: chartWidth - spacingLeft - spacingRight,
      			height: chartHeight - spacingTop - spacingBottom
      		};
      	};
      	
      	/**
      	 * Initial margins before auto size margins are applied
      	 */
      	resetMargins = function() {
      		plotTop = pick(optionsMarginTop, spacingTop);
      		marginRight = pick(optionsMarginRight, spacingRight);
      		marginBottom = pick(optionsMarginBottom, spacingBottom);
      		plotLeft = pick(optionsMarginLeft, spacingLeft);
      		axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
      	};
      	
      	/**
      	 * Draw the borders and backgrounds for chart and plot area
      	 */
      	drawChartBox = function() {
      		var chartBorderWidth = optionsChart.borderWidth || 0,
      			chartBackgroundColor = optionsChart.backgroundColor,
      			plotBackgroundColor = optionsChart.plotBackgroundColor,
      			plotBackgroundImage = optionsChart.plotBackgroundImage,
      			mgn,
      			plotSize = {
      				x: plotLeft,
      				y: plotTop,
      				width: plotWidth,
      				height: plotHeight
      			};
      
      		// Chart area
      		mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
      			
      		if (chartBorderWidth || chartBackgroundColor) {
      			if (!chartBackground) {
      				chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn, 
      						optionsChart.borderRadius, chartBorderWidth)
      					.attr({ 
      						stroke: optionsChart.borderColor,
      						'stroke-width': chartBorderWidth,
      						fill: chartBackgroundColor || NONE
      					})
      					.add()
      					.shadow(optionsChart.shadow);
      			} else { // resize
      				chartBackground.animate(
      					chartBackground.crisp(null, null, null, chartWidth - mgn, chartHeight - mgn)
      				);
      			}
      		}
      		
      		
      		// Plot background
      		if (plotBackgroundColor) {
      			if (!plotBackground) {
      				plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
      					.attr({
      						fill: plotBackgroundColor
      					})
      					.add()
      					.shadow(optionsChart.plotShadow);
      			} else {
      				plotBackground.animate(plotSize);
      			}
      		}
      		if (plotBackgroundImage) {
      			if (!plotBGImage) {
      				plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
      					.add();
      			} else {
      				plotBGImage.animate(plotSize);
      			}
      		}
      		
      		// Plot area border
      		if (optionsChart.plotBorderWidth) {
      			if (!plotBorder) {
      				plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, optionsChart.plotBorderWidth)
      					.attr({
      						stroke: optionsChart.plotBorderColor,
      						'stroke-width': optionsChart.plotBorderWidth,
      						zIndex: 4
      					})
      					.add();
      			} else {
      				plotBorder.animate(
      					plotBorder.crisp(null, plotLeft, plotTop, plotWidth, plotHeight)
      				);
      			}
      		}
      		
      		// reset
      		chart.isDirtyBox = false;
      	};
      	
      	/**
      	 * Render all graphics for the chart
      	 */
      	function render () {
      		var labels = options.labels,
      			credits = options.credits,
      			creditsHref;
      		
      		// Title
      		setTitle();
      		
      		
      		// Legend
      		legend = chart.legend = new Legend(chart);
      		
      		// Get margins by pre-rendering axes
      		getMargins();
      		each(axes, function(axis) {
      			axis.setTickPositions(true); // update to reflect the new margins 
      		});
      		adjustTickAmounts();
      		getMargins(); // second pass to check for new labels
      		
      		
      		// Draw the borders and backgrounds
      		drawChartBox();
      						
      		// Axes
      		if (hasCartesianSeries) {
      			each(axes, function(axis) { 
      				axis.render();
      			});
      		}
      		
      		
      		// The series
      		if (!chart.seriesGroup) {
      			chart.seriesGroup = renderer.g('series-group')
      				.attr({ zIndex: 3 })
      				.add();
      		}
      		each(series, function(serie) {
      			serie.translate();
      			serie.setTooltipPoints();
      			serie.render();
      		});
      		
      		
      		// Labels
      		if (labels.items) {
      			each(labels.items, function() {
      				var style = extend(labels.style, this.style),
      					x = pInt(style.left) + plotLeft,
      					y = pInt(style.top) + plotTop + 12;
      				
      				// delete to prevent rewriting in IE
      				delete style.left;
      				delete style.top;
      				
      				renderer.text(
      					this.html,
      					x,
      					y
      				)
      				.attr({ zIndex: 2 })
      				.css(style)
      				.add();
      					
      			});
      		}
      		
      		// Toolbar (don't redraw)
      		if (!chart.toolbar) {
      			chart.toolbar = Toolbar(chart);
      		}
      		
      		// Credits
      		if (credits.enabled && !chart.credits) {
      			creditsHref = credits.href;
      			renderer.text(
      				credits.text,
      				0,
      				0
      			)
      			.on('click', function() {
      				if (creditsHref) {
      					location.href = creditsHref;
      				}
      			})
      			.attr({
      				align: credits.position.align, 
      				zIndex: 8
      			})
      			.css(credits.style)
      			.add()
      			.align(credits.position); 
      		}
      		
      		placeTrackerGroup();
      
      		// Set flag
      		chart.hasRendered = true;
      		
      		// If the chart was rendered outside the top container, put it back in
      		if (renderToClone) {
      			renderTo.appendChild(container);
      			discardElement(renderToClone);
      			//updatePosition(container);
      		}
      	}
      	
      	/**
      	 * Clean up memory usage
      	 */
      	function destroy() {
      		var i = series.length,
      			parentNode = container && container.parentNode;
      		
      		// fire the chart.destoy event
      		fireEvent(chart, 'destroy');
      
      		// remove events
      		removeEvent(win, 'unload', destroy);
      		removeEvent(chart);
      		
      		each(axes, function(axis) {
      			removeEvent(axis);
      		});
      
      		// destroy each series
      		while (i--) {
      			series[i].destroy();
      		}
      		
      		// remove container and all SVG
      		if (container) { // can break in IE when destroyed before finished loading
      			container.innerHTML = '';
      			removeEvent(container);
      			if (parentNode) {
      				parentNode.removeChild(container);
      			}
      			
      			// IE6 leak 
      			container =	null;
      		}
      		
      		// IE7 leak
      		if (renderer) { // can break in IE when destroyed before finished loading
      			renderer.alignedObjects = null;
      		}
      			
      		// memory and CPU leak
      		clearInterval(tooltipInterval);
      		
      		// clean it all up
      		for (i in chart) {
      			delete chart[i];
      		}
      		
      	}
      	/**
      	 * Prepare for first rendering after all data are loaded
      	 */
      	function firstRender() {
      
      		// VML namespaces can't be added until after complete. Listening
      		// for Perini's doScroll hack is not enough.
      		var ONREADYSTATECHANGE = 'onreadystatechange',
      			COMPLETE = 'complete';
      		// Note: in spite of JSLint's complaints, win == win.top is required
      		if (!hasSVG && win == win.top && doc.readyState !== COMPLETE) {
      			doc.attachEvent(ONREADYSTATECHANGE, function() {
      				doc.detachEvent(ONREADYSTATECHANGE, firstRender);
      				if (doc.readyState === COMPLETE) {
      					firstRender();
      				}
      			});
      			return;
      		}
      
      		// create the container
      		getContainer();
      		
      		resetMargins();
      		setChartSize();
      		
      		// Initialize the series
      		each(options.series || [], function(serieOptions) {
      			initSeries(serieOptions);
      		});
      	
      		// Set the common inversion and transformation for inverted series after initSeries
      		chart.inverted = inverted = pick(inverted, options.chart.inverted); 
      			
      		
      		getAxes();
      		
      		
      		chart.render = render;
      		
      		// depends on inverted and on margins being set	
      		chart.tracker = tracker = new MouseTracker(chart, options.tooltip);
      		
      		//globalAnimation = false;
      		render();
      		
      		fireEvent(chart, 'load');
      		
      		//globalAnimation = true;
      		
      		// run callbacks
      		if (callback) {
      			callback.apply(chart, [chart]);
      		}
      		each(chart.callbacks, function(fn) {
      			fn.apply(chart, [chart]);
      		});
      	}
      	
      	// Run chart
      		
      	
      	// Destroy the chart and free up memory. 
      	addEvent(win, 'unload', destroy);
      	
      	// Set up auto resize
      	if (optionsChart.reflow !== false) {
      		addEvent(chart, 'load', initReflow);
      	}
      	
      	// Chart event handlers
      	if (chartEvents) {
      		for (eventType in chartEvents) { 
      			addEvent(chart, eventType, chartEvents[eventType]);
      		}
      	}
      	
      	
      	chart.options = options;
      	chart.series = series;
      
      	
      	
      	
      	
      	// Expose methods and variables
      	chart.addSeries = addSeries;
      	chart.animation = pick(optionsChart.animation, true);
      	chart.destroy = destroy;
      	chart.get = get;
      	chart.getSelectedPoints = getSelectedPoints;
      	chart.getSelectedSeries = getSelectedSeries;
      	chart.hideLoading = hideLoading;
      	chart.isInsidePlot = isInsidePlot;
      	chart.redraw = redraw;
      	chart.setSize = resize;
      	chart.setTitle = setTitle;
      	chart.showLoading = showLoading;	
      	chart.pointCount = 0;
      	chart.counters = new ChartCounters();
      	/*
      	if ($) $(function() {
      		$container = $('#container');
      		var origChartWidth,
      			origChartHeight;
      		if ($container) {
      			$('<button>+</button>')
      				.insertBefore($container)
      				.click(function() {
      					if (origChartWidth === UNDEFINED) {
      						origChartWidth = chartWidth;
      						origChartHeight = chartHeight;
      					}				
      					chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
      				});
      			$('<button>-</button>')
      				.insertBefore($container)
      				.click(function() {
      					if (origChartWidth === UNDEFINED) {
      						origChartWidth = chartWidth;
      						origChartHeight = chartHeight;
      					}							
      					chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
      				});
      			$('<button>1:1</button>')
      				.insertBefore($container)
      				.click(function() {				
      					if (origChartWidth === UNDEFINED) {
      						origChartWidth = chartWidth;
      						origChartHeight = chartHeight;
      					}							
      					chart.resize(origChartWidth, origChartHeight);
      				});
      		}
      	})
      	*/
      	
      	
      	
      		
      	firstRender();
      	
      	
      } // end Chart
      
      // Hook for exporting module
      Chart.prototype.callbacks = [];
      /**
       * The Point object and prototype. Inheritable and used as base for PiePoint
       */
      var Point = function() {};
      Point.prototype = {
      
      	/**
      	 * Initialize the point
      	 * @param {Object} series The series object containing this point
      	 * @param {Object} options The data in either number, array or object format
      	 */
      	init: function(series, options) {
      		var point = this,
      			counters = series.chart.counters,
      			defaultColors;
      		point.series = series;
      		point.applyOptions(options);
      		point.pointAttr = {};
      		
      		if (series.options.colorByPoint) {
      			defaultColors = series.chart.options.colors;
      			if (!point.options) {
      				point.options = {};
      			}
      			point.color = point.options.color = point.color || defaultColors[counters.color++];
      			
      			// loop back to zero
      			counters.wrapColor(defaultColors.length);
      		}
      		
      		series.chart.pointCount++;
      		return point;
      	},
      	/**
      	 * Apply the options containing the x and y data and possible some extra properties.
      	 * This is called on point init or from point.update.
      	 * 
      	 * @param {Object} options
      	 */
      	applyOptions: function(options) {
      		var point = this,
      			series = point.series;
      	
      		point.config = options;
      		
      		// onedimensional array input
      		if (isNumber(options) || options === null) {
      			point.y = options;	
      		}
      		
      		// object input
      		else if (isObject(options) && !isNumber(options.length)) {
      			
      			// copy options directly to point
      			extend(point, options);
      			point.options = options;
      		}
      		
      		// categorized data with name in first position
      		else if (isString(options[0])) {
      			point.name = options[0];
      			point.y = options[1];
      		}
      		
      		// two-dimentional array
      		else if (isNumber(options[0])) {
      			point.x = options[0];
      			point.y = options[1];
      		}
      		
      		/* 
      		 * If no x is set by now, get auto incremented value. All points must have an
      		 * x value, however the y value can be null to create a gap in the series
      		 */
      		if (point.x === UNDEFINED) {
      			point.x = series.autoIncrement();
      		}
      		
      	},
      	
      	/**
      	 * Destroy a point to clear memory. Its reference still stays in series.data.
      	 */
      	destroy: function() {
      		var point = this,
      			series = point.series,
      			prop;
      			
      		series.chart.pointCount--;
      			
      		if (point === series.chart.hoverPoint) {
      			point.onMouseOut();
      		}
      		series.chart.hoverPoints = null; // remove reference
      		
      		// remove all events
      		removeEvent(point);
      		
      		each(['graphic', 'tracker', 'group', 'dataLabel', 'connector'], function(prop) {
      			if (point[prop]) {
      				point[prop].destroy();
      			}
      		});		
      		
      		if (point.legendItem) { // pies have legend items
      			point.series.chart.legend.destroyItem(point);
      		}
      		
      		for (prop in point) {
      			point[prop] = null;
      		}
      		
      		
      	},
      	
      	/**
      	 * Return the configuration hash needed for the data label and tooltip formatters
      	 */
      	getLabelConfig: function() {
      		var point = this;
      		return {
      			x: point.category,
      			y: point.y,
      			series: point.series,
      			point: point,
      			percentage: point.percentage,
      			total: point.total || point.stackTotal
      		};
      	},
      		
      	/**
      	 * Toggle the selection status of a point
      	 * @param {Boolean} selected Whether to select or unselect the point.
      	 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
      	 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
      	 */
      	select: function(selected, accumulate) {
      		var point = this,
      			series = point.series,
      			chart = series.chart;
      			
      		point.selected = selected = pick(selected, !point.selected);
      		
      		//series.isDirty = true;
      		point.firePointEvent(selected ? 'select' : 'unselect');
      		point.setState(selected && SELECT_STATE);
      		
      		// unselect all other points unless Ctrl or Cmd + click
      		if (!accumulate) {
      			each(chart.getSelectedPoints(), function (loopPoint) {
      				if (loopPoint.selected && loopPoint !== point) {
      					loopPoint.selected = false;
      					loopPoint.setState(NORMAL_STATE);
      					loopPoint.firePointEvent('unselect');
      				}
      			});
      		}
      		
      	},
      	
      	onMouseOver: function() {
      		var point = this,
      			chart = point.series.chart,
      			tooltip = chart.tooltip,
      			hoverPoint = chart.hoverPoint;
      			
      		// set normal state to previous series
      		if (hoverPoint && hoverPoint !== point) {
      			hoverPoint.onMouseOut();
      		}
      		
      		// trigger the event
      		point.firePointEvent('mouseOver');
      		
      		// update the tooltip
      		if (tooltip && !tooltip.shared) {
      			tooltip.refresh(point);
      		}
      		
      		// hover this
      		point.setState(HOVER_STATE);
      		chart.hoverPoint = point;
      	},
      	
      	onMouseOut: function() {
      		var point = this;
      		point.firePointEvent('mouseOut');
      		
      		point.setState();
      		point.series.chart.hoverPoint = null;
      	},
      	
      	/**
      	 * Extendable method for formatting each point's tooltip line 
      	 * 
      	 * @param {Boolean} useHeader Whether a common header is used for multiple series in the tooltip
      	 * 
      	 * @return {String} A string to be concatenated in to the common tooltip text
      	 */
      	tooltipFormatter: function(useHeader) {
      		var point = this,
      			series = point.series;
      				
      		return ['<span style="color:'+ series.color +'">', (point.name || series.name), '</span>: ',
      			(!useHeader ? ('<b>x = '+ (point.name || point.x) + ',</b> ') : ''), 
      			'<b>', (!useHeader ? 'y = ' : '' ), point.y, '</b>'].join('');
      		
      	},
      	
      	/**
      	 * Update the point with new options (typically x/y data) and optionally redraw the series.
      	 * 
      	 * @param {Object} options Point options as defined in the series.data array
      	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
      	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      	 *    configuration
      	 * 
      	 */
      	update: function(options, redraw, animation) {
      		var point = this,
      			series = point.series,
      			dataLabel = point.dataLabel,
      			graphic = point.graphic,
      			chart = series.chart;
      		
      		redraw = pick(redraw, true);
      		
      		// fire the event with a default handler of doing the update
      		point.firePointEvent('update', { options: options }, function() {
      
      			point.applyOptions(options);
      			
      			// update visuals
      			if (isObject(options)) {
      				series.getAttribs();
      				if (graphic) {
      					graphic.attr(point.pointAttr[series.state]);
      				}
      			}
      			
      			// redraw
      			series.isDirty = true;
      			if (redraw) {
      				chart.redraw(animation);
      			}
      		});
      	},
      	
      	/**
      	 * Remove a point and optionally redraw the series and if necessary the axes
      	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
      	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      	 *    configuration
      	 */
      	remove: function(redraw, animation) {
      		var point = this,
      			series = point.series,
      			chart = series.chart,
      			data = series.data;
      		
      		setAnimation(animation, chart);
      		redraw = pick(redraw, true);
      		
      		// fire the event with a default handler of removing the point			
      		point.firePointEvent('remove', null, function() {
      
      			erase(data, point);
      			
      			point.destroy();
      			
      			
      			// redraw
      			series.isDirty = true;
      			if (redraw) {
      				chart.redraw();
      			}
      		});
      			
      		
      	},
      	
      	/**
      	 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
      	 * causes a name clash in MooTools
      	 * @param {String} eventType
      	 * @param {Object} eventArgs Additional event arguments
      	 * @param {Function} defaultFunction Default event handler
      	 */
      	firePointEvent: function(eventType, eventArgs, defaultFunction) {
      		var point = this,
      			series = this.series,
      			seriesOptions = series.options;
      		
      		// load event handlers on demand to save time on mouseover/out
      		if (seriesOptions.point.events[eventType] || (
      				point.options && point.options.events && point.options.events[eventType])) {
      			this.importEvents();
      		}
      			
      		// add default handler if in selection mode
      		if (eventType === 'click' && seriesOptions.allowPointSelect) {
      			defaultFunction = function (event) {
      				// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
      				point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
      			};
      		}
      			
      		fireEvent(this, eventType, eventArgs, defaultFunction);
      	},
      	/**
      	 * Import events from the series' and point's options. Only do it on 
      	 * demand, to save processing time on hovering.
      	 */
      	importEvents: function() {
      		if (!this.hasImportedEvents) {
      			var point = this,
      				options = merge(point.series.options.point, point.options),
      				events = options.events,
      				eventType;
      				
      			point.events = events;
      			
      			for (eventType in events) {
      				addEvent(point, eventType, events[eventType]);
      			}
      			this.hasImportedEvents = true;
      			
      		}
      	},
      	
      	/**
      	 * Set the point's state
      	 * @param {String} state
      	 */
      	setState: function(state) {
      		var point = this,
      			series = point.series,
      			stateOptions = series.options.states,
      			markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
      			normalDisabled = markerOptions && !markerOptions.enabled,
      			markerStateOptions = markerOptions && markerOptions.states[state],
      			stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
      			stateMarkerGraphic = series.stateMarkerGraphic,
      			chart = series.chart,
      			pointAttr = point.pointAttr;
      			
      		state = state || NORMAL_STATE; // empty string
      		
      		if (
      				// already has this state
      				state === point.state ||
      				// selected points don't respond to hover
      				(point.selected && state !== SELECT_STATE) ||
      				// series' state options is disabled
      				(stateOptions[state] && stateOptions[state].enabled === false) ||
      				// point marker's state options is disabled
      				(state && (stateDisabled || (normalDisabled && !markerStateOptions.enabled)))
      
      			) {
      			return;
      		}
      		
      		// apply hover styles to the existing point
      		if (point.graphic) {
      			point.graphic.attr(pointAttr[state]);
      		}
      		// if a graphic is not applied to each point in the normal state, create a shared
      		// graphic for the hover state
      		else {
      			if (state) {
      				if (!stateMarkerGraphic) {
      					series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.circle(
      						0, 0, pointAttr[state].r
      					)
      					.attr(pointAttr[state])
      					.add(series.group);
      				}
      				
      				stateMarkerGraphic.translate(
      					point.plotX, 
      					point.plotY
      				);
      			}
      			
      			if (stateMarkerGraphic) {
      				stateMarkerGraphic[state ? 'show' : 'hide']();
      			}
      		}
      		
      		point.state = state;
      	}
      };
      
      /**
       * The base function which all other series types inherit from
       * @param {Object} chart
       * @param {Object} options
       */
      var Series = function() {};
      
      Series.prototype = {
      	
      	isCartesian: true,
      	type: 'line',
      	pointClass: Point,
      	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
      		stroke: 'lineColor',
      		'stroke-width': 'lineWidth',
      		fill: 'fillColor',
      		r: 'radius'
      	},
      	init: function(chart, options) {
      		var series = this,
      			eventType,
      			events,
      			//pointEvent,
      			index = chart.series.length;
      			
      		series.chart = chart;
      		options = series.setOptions(options); // merge with plotOptions
      		
      		// set some variables
      		extend(series, {
      			index: index,
      			options: options,
      			name: options.name || 'Series '+ (index + 1),
      			state: NORMAL_STATE,
      			pointAttr: {},
      			visible: options.visible !== false, // true by default
      			selected: options.selected === true // false by default
      		});
      		
      		// register event listeners
      		events = options.events;
      		for (eventType in events) {
      			addEvent(series, eventType, events[eventType]);
      		}
      		if (
      			(events && events.click) || 
      			(options.point && options.point.events && options.point.events.click) ||
      			options.allowPointSelect 
      		) {
      			chart.runTrackerClick = true;
      		}
      		
      		series.getColor();
      		series.getSymbol();
      		
      		
      		// set the data
      		series.setData(options.data, false);
      			
      	},
      	
      	
      	/**
      	 * Return an auto incremented x value based on the pointStart and pointInterval options. 
      	 * This is only used if an x value is not given for the point that calls autoIncrement.
      	 */
      	autoIncrement: function() {
      		var series = this,
      			options = series.options,
      			xIncrement = series.xIncrement;
      			
      		xIncrement = pick(xIncrement, options.pointStart, 0);
      		
      		series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);
      		
      		series.xIncrement = xIncrement + series.pointInterval;
      		return xIncrement;
      	},
      	
      	/**
      	 * Sort the data and remove duplicates 
      	 */
      	cleanData: function() {
      		var series = this,
      			chart = series.chart,
      			data = series.data,
      			closestPoints,
      			smallestInterval,
      			chartSmallestInterval = chart.smallestInterval,
      			interval,
      			i;
      			
      		// sort the data points
      		data.sort(function(a, b){
      			return (a.x - b.x);
      		});
      		
      		// remove points with equal x values
      		// record the closest distance for calculation of column widths
      		/*for (i = data.length - 1; i >= 0; i--) {
      			if (data[i - 1]) {
      				if (data[i - 1].x == data[i].x)	{
      					data[i - 1].destroy();
      					data.splice(i - 1, 1); // remove the duplicate
      				}
      			}
      		}*/
      		
      		// connect nulls
      		if (series.options.connectNulls) {
      			for (i = data.length - 1; i >= 0; i--) {
      				if (data[i].y === null && data[i - 1] && data[i + 1]) {
      					data.splice(i, 1);
      				}
      			}
      		}
      		
      		// find the closes pair of points
      		for (i = data.length - 1; i >= 0; i--) {
      			if (data[i - 1]) {
      				interval = data[i].x - data[i - 1].x;
      				if (interval > 0 && (smallestInterval === UNDEFINED || interval < smallestInterval)) {
      					smallestInterval = interval;
      					closestPoints = i;	
      				}
      			}
      		}
      		
      		if (chartSmallestInterval === UNDEFINED || smallestInterval < chartSmallestInterval) {
      			chart.smallestInterval = smallestInterval;
      		}
      		series.closestPoints = closestPoints;
      	},		
      		
      	/**
      	 * Divide the series data into segments divided by null values. Also sort
      	 * the data points and delete duplicate values.
      	 */
      	getSegments: function() {
      		var lastNull = -1,
      			segments = [],
      			data = this.data;
      		
      		// create the segments
      		each(data, function(point, i) {
      			if (point.y === null) {
      				if (i > lastNull + 1) {
      					segments.push(data.slice(lastNull + 1, i));
      				}
      				lastNull = i;	
      			} else if (i === data.length - 1) { // last value
      				segments.push(data.slice(lastNull + 1, i + 1));
      			}
      		});
      		this.segments = segments;
      		
      		
      	},
      	/**
      	 * Set the series options by merging from the options tree
      	 * @param {Object} itemOptions
      	 */
      	setOptions: function(itemOptions) {
      		var plotOptions = this.chart.options.plotOptions,
      			options = merge(
      				plotOptions[this.type],
      				plotOptions.series,
      				itemOptions
      			);
      		
      		return options;
      		
      	},
      	/**
      	 * Get the series' color
      	 */
      	getColor: function(){
      		var defaultColors = this.chart.options.colors,
      			counters = this.chart.counters;
      		this.color = this.options.color || defaultColors[counters.color++] || '#0000ff';
      		counters.wrapColor(defaultColors.length);
      	},
      	/**
      	 * Get the series' symbol
      	 */
      	getSymbol: function(){
      		var defaultSymbols = this.chart.options.symbols,
      			counters = this.chart.counters;
      		this.symbol = this.options.marker.symbol || defaultSymbols[counters.symbol++];
      		counters.wrapSymbol(defaultSymbols.length);
      	},
      	
      	/**
      	 * Add a point dynamically after chart load time
      	 * @param {Object} options Point options as given in series.data
      	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
      	 * @param {Boolean} shift If shift is true, a point is shifted off the start 
      	 *    of the series as one is appended to the end.
      	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      	 *    configuration
      	 */
      	addPoint: function(options, redraw, shift, animation) {
      		var series = this,
      			data = series.data,
      			graph = series.graph,
      			area = series.area,
      			chart = series.chart,
      			point = (new series.pointClass()).init(series, options);
      			
      		setAnimation(animation, chart);
      		
      		if (graph && shift) { // make graph animate sideways
      			graph.shift = shift;
      		}
      		if (area) {
      			area.shift = shift;
      			area.isArea = true;
      		}
      			
      		redraw = pick(redraw, true);
      			
      		data.push(point);
      		if (shift) {
      			data[0].remove(false);
      		}
      		series.getAttribs();
      		
      		
      		// redraw
      		series.isDirty = true;
      		if (redraw) {
      			chart.redraw();
      		}
      	},
      	
      	/**
      	 * Replace the series data with a new set of data
      	 * @param {Object} data
      	 * @param {Object} redraw
      	 */
      	setData: function(data, redraw) {
      		var series = this,
      			oldData = series.data,
      			initialColor = series.initialColor,
      			chart = series.chart,
      			i = (oldData && oldData.length) || 0;
      		
      		series.xIncrement = null; // reset for new data
      		if (defined(initialColor)) { // reset colors for pie
      			chart.counters.color = initialColor;
      		}
      		
      		data = map(splat(data || []), function(pointOptions) {
      			return (new series.pointClass()).init(series, pointOptions);
      		});
      		
      		// destroy old points
      		while (i--) {
      			oldData[i].destroy();
      		}
      		
      		// set the data
      		series.data = data;
      	
      		series.cleanData();	
      		series.getSegments();
      		
      		
      		// cache attributes for shapes
      		series.getAttribs();
      		
      		// redraw
      		series.isDirty = true;
      		chart.isDirtyBox = true;
      		if (pick(redraw, true)) {
      			chart.redraw(false);
      		}
      	},
      	
      	/**
      	 * Remove a series and optionally redraw the chart
      	 * 
      	 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
      	 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
      	 *    configuration
      	 */
      	
      	remove: function(redraw, animation) {
      		var series = this,
      			chart = series.chart;
      		redraw = pick(redraw, true);
      		
      		if (!series.isRemoving) {  /* prevent triggering native event in jQuery
      				(calling the remove function from the remove event) */ 
      			series.isRemoving = true;
      
      			// fire the event with a default handler of removing the point			
      			fireEvent(series, 'remove', null, function() {
      				
      						
      				// destroy elements
      				series.destroy();
      			
      				
      				// redraw
      				chart.isDirtyLegend = chart.isDirtyBox = true;
      				if (redraw) {
      					chart.redraw(animation);
      				}
      			});
      			
      		} 
      		series.isRemoving = false;
      	},
      	
      	/**
      	 * Translate data points from raw data values to chart specific positioning data
      	 * needed later in drawPoints, drawGraph and drawTracker. 
      	 */
      	translate: function() {
      		var series = this, 
      			chart = series.chart, 
      			stacking = series.options.stacking,
      			categories = series.xAxis.categories,
      			yAxis = series.yAxis,
      			data = series.data,			
      			i = data.length;
      			
      		// do the translation
      		while (i--) {
      			var point = data[i],
      				xValue = point.x, 
      				yValue = point.y, 
      				yBottom = point.low,
      				stack = yAxis.stacks[(yValue < 0 ? '-' : '') + series.stackKey],
      				pointStack,
      				pointStackTotal;
      			point.plotX = series.xAxis.translate(xValue);
      			
      			// calculate the bottom y value for stacked series
      			if (stacking && series.visible && stack && stack[xValue]) {
      				pointStack = stack[xValue];
      				pointStackTotal = pointStack.total;
      				pointStack.cum = yBottom = pointStack.cum - yValue; // start from top
      				yValue = yBottom + yValue;
      				
      				if (stacking === 'percent') {
      					yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
      					yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
      				}
      
      				point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
      				point.stackTotal = pointStackTotal;
      			}
      			
      			if (defined(yBottom)) {
      				point.yBottom = yAxis.translate(yBottom, 0, 1, 0, 1);
      			}
      			
      			// set the y value
      			if (yValue !== null) {
      				point.plotY = yAxis.translate(yValue, 0, 1, 0, 1);
      			}
      			
      			// set client related positions for mouse tracking
      			point.clientX = chart.inverted ? 
      				chart.plotHeight - point.plotX : 
      				point.plotX; // for mouse tracking
      				
      			// some API data
      			point.category = categories && categories[point.x] !== UNDEFINED ? 
      				categories[point.x] : point.x;
      				
      		}
      	},
      	/**
      	 * Memoize tooltip texts and positions
      	 */
      	setTooltipPoints: function (renew) {
      		var series = this,
      			chart = series.chart,
      			inverted = chart.inverted,
      			data = [],
      			plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
      			low,
      			high,
      			tooltipPoints = []; // a lookup array for each pixel in the x dimension
      			
      		// renew
      		if (renew) {
      			series.tooltipPoints = null;
      		}
      			
      		// concat segments to overcome null values
      		each(series.segments, function(segment){
      			data = data.concat(segment);
      		});
      		
      		// loop the concatenated data and apply each point to all the closest
      		// pixel positions
      		if (series.xAxis && series.xAxis.reversed) {
      			data = data.reverse();//reverseArray(data);
      		}
      		
      		each(data, function(point, i) {
      			
      			low = data[i - 1] ? data[i - 1]._high + 1 : 0;
      			high = point._high = data[i + 1] ? (
      				mathFloor((point.plotX + (data[i + 1] ? 
      					data[i + 1].plotX : plotSize)) / 2)) :
      					plotSize;
      			
      			while (low <= high) {
      				tooltipPoints[inverted ? plotSize - low++ : low++] = point;
      			}
      		});
      		series.tooltipPoints = tooltipPoints;
      	},
      	
      	
      
      	
      	/**
      	 * Series mouse over handler
      	 */
      	onMouseOver: function() {
      		var series = this,
      			chart = series.chart,
      			hoverSeries = chart.hoverSeries;
      			
      		if (!hasTouch && chart.mouseIsDown) {
      			return;
      		}
      		
      		// set normal state to previous series
      		if (hoverSeries && hoverSeries !== series) {
      			hoverSeries.onMouseOut();
      		}
      		
      		// trigger the event, but to save processing time, 
      		// only if defined
      		if (series.options.events.mouseOver) { 
      			fireEvent(series, 'mouseOver');
      		}
      		
      		
      		// bring to front
      		// Todo: optimize. This is one of two operations slowing down the tooltip in Firefox.
      		// Can the tracking be done otherwise?
      		if (series.tracker) {
      			series.tracker.toFront();
      		}
      		
      		// hover this
      		series.setState(HOVER_STATE);
      		chart.hoverSeries = series;
      	},
      	
      	/**
      	 * Series mouse out handler
      	 */
      	onMouseOut: function() {
      		// trigger the event only if listeners exist
      		var series = this,
      			options = series.options,
      			chart = series.chart,
      			tooltip = chart.tooltip,
      			hoverPoint = chart.hoverPoint;
      		
      		// trigger mouse out on the point, which must be in this series
      		if (hoverPoint) {
      			hoverPoint.onMouseOut();
      		}		
      		
      		// fire the mouse out event
      		if (series && options.events.mouseOut) { 
      			fireEvent(series, 'mouseOut');
      		}
      		
      		
      		// hide the tooltip
      		if (tooltip && !options.stickyTracking) {
      			tooltip.hide();
      		}
      		
      		// set normal state
      		series.setState();
      		chart.hoverSeries = null;		
      	},
      	
      	/**
      	 * Animate in the series
      	 */
      	animate: function(init) {
      		var series = this,
      			chart = series.chart,
      			clipRect = series.clipRect,
      			animation = series.options.animation;
      			
      		if (animation && !isObject(animation)) {
      			animation = {};
      		}
      			
      		if (init) { // initialize the animation
      			if (!clipRect.isAnimating) { // apply it only for one of the series
      				clipRect.attr( 'width', 0 );
      				clipRect.isAnimating = true;
      			}
      			
      		} else { // run the animation
      			clipRect.animate({ 
      				width: chart.plotSizeX 
      			}, animation);
      			
      			// delete this function to allow it only once
      			this.animate = null;
      		}
      	},
      	
      	
      	/**
      	 * Draw the markers
      	 */
      	drawPoints: function(){
      		var series = this,
      			pointAttr,
      			data = series.data, 
      			chart = series.chart,
      			plotX,
      			plotY,
      			i,
      			point,
      			radius,
      			graphic;
      		
      		if (series.options.marker.enabled) {
      			i = data.length;
      			while (i--) {
      				point = data[i];
      				plotX = point.plotX;
      				plotY = point.plotY;
      				graphic = point.graphic;
      				
      				// only draw the point if y is defined
      				if (plotY !== UNDEFINED && !isNaN(plotY)) {
      				
      					/* && removed this code because points stayed after zoom
      						point.plotX >= 0 && point.plotX <= chart.plotSizeX &&
      						point.plotY >= 0 && point.plotY <= chart.plotSizeY*/
      					
      					// shortcuts
      					pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
      					radius = pointAttr.r;
      					
      					if (graphic) { // update
      						graphic.animate({
      							x: plotX,
      							y: plotY,
      							r: radius
      						});
      					} else {
      						point.graphic = chart.renderer.symbol(
      							pick(point.marker && point.marker.symbol, series.symbol),
      							plotX,
      							plotY, 
      							radius
      						)
      						.attr(pointAttr)
      						.add(series.group);
      					}
      				}
      			}
      		}
      		
      	},
      	
      	/**
      	 * Convert state properties from API naming conventions to SVG attributes
      	 * 
      	 * @param {Object} options API options object
      	 * @param {Object} base1 SVG attribute object to inherit from
      	 * @param {Object} base2 Second level SVG attribute object to inherit from
      	 */
      	convertAttribs: function(options, base1, base2, base3) {
      		var conversion = this.pointAttrToOptions,
      			attr,
      			option,
      			obj = {};
      		
      		options = options || {};
      		base1 = base1 || {};
      		base2 = base2 || {};
      		base3 = base3 || {};
      		
      		for (attr in conversion) {
      			option = conversion[attr];
      			obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);		 
      		}
      		return obj;
      	},
      	
      	/**
      	 * Get the state attributes. Each series type has its own set of attributes
      	 * that are allowed to change on a point's state change. Series wide attributes are stored for
      	 * all series, and additionally point specific attributes are stored for all 
      	 * points with individual marker options. If such options are not defined for the point,
      	 * a reference to the series wide attributes is stored in point.pointAttr.
      	 */
      	getAttribs: function() {
      		var series = this, 
      			normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
      			stateOptions = normalOptions.states,
      			stateOptionsHover = stateOptions[HOVER_STATE],
      			pointStateOptionsHover,
      			seriesColor = series.color,
      			normalDefaults = {
      				stroke: seriesColor,
      				fill: seriesColor
      			},
      			data = series.data,
      			i,
      			point,
      			seriesPointAttr = [],
      			pointAttr,
      			pointAttrToOptions = series.pointAttrToOptions,
      			hasPointSpecificOptions,
      			key;
      			
      		// series type specific modifications
      		if (series.options.marker) { // line, spline, area, areaspline, scatter
      			
      			// if no hover radius is given, default to normal radius + 2  
      			stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
      			stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;
      			
      		} else { // column, bar, pie
      			
      			// if no hover color is given, brighten the normal color
      			stateOptionsHover.color = stateOptionsHover.color || 
      				Color(stateOptionsHover.color || seriesColor)
      					.brighten(stateOptionsHover.brightness).get();
      		}
      		
      		// general point attributes for the series normal state
      		seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);
      		
      		// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
      		each([HOVER_STATE, SELECT_STATE], function(state) {
      			seriesPointAttr[state] = 
      					series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
      		});
      				
      		// set it
      		series.pointAttr = seriesPointAttr;
      		
      		
      		// Generate the point-specific attribute collections if specific point
      		// options are given. If not, create a referance to the series wide point 
      		// attributes
      		i = data.length;
      		while (i--) {
      			point = data[i];
      			normalOptions = (point.options && point.options.marker) || point.options;
      			if (normalOptions && normalOptions.enabled === false) {
      				normalOptions.radius = 0;
      			}
      			hasPointSpecificOptions = false;
      			
      			// check if the point has specific visual options
      			if (point.options) {
      				for (key in pointAttrToOptions) {
      					if (defined(normalOptions[pointAttrToOptions[key]])) {
      						hasPointSpecificOptions = true;
      					}
      				}
      			}
      			
      			
      			
      			// a specific marker config object is defined for the individual point:
      			// create it's own attribute collection
      			if (hasPointSpecificOptions) {
      
      				pointAttr = [];
      				stateOptions = normalOptions.states || {}; // reassign for individual point
      				pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};
      				
      				// if no hover color is given, brighten the normal color
      				if (!series.options.marker) { // column, bar, point
      					pointStateOptionsHover.color = 
      						Color(pointStateOptionsHover.color || point.options.color)
      							.brighten(pointStateOptionsHover.brightness || 
      								stateOptionsHover.brightness).get();
      				
      				}
      				
      				// normal point state inherits series wide normal state
      				pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);
      									
      				// inherit from point normal and series hover
      				pointAttr[HOVER_STATE] = series.convertAttribs(
      					stateOptions[HOVER_STATE],
      					seriesPointAttr[HOVER_STATE],
      					pointAttr[NORMAL_STATE]
      				);
      				// inherit from point normal and series hover
      				pointAttr[SELECT_STATE] = series.convertAttribs(
      					stateOptions[SELECT_STATE],
      					seriesPointAttr[SELECT_STATE],
      					pointAttr[NORMAL_STATE]
      				);
      				
      				
      				
      			// no marker config object is created: copy a reference to the series-wide
      			// attribute collection
      			} else {
      				pointAttr = seriesPointAttr;
      			}
      		
      			point.pointAttr = pointAttr;
      
      		}
      
      	},
      
      	
      	/**
      	 * Clear DOM objects and free up memory
      	 */
      	destroy: function() {
      		var series = this,
      			chart = series.chart,
      			//chartSeries = series.chart.series,
      			clipRect = series.clipRect,
      			issue134 = /\/5[0-9\.]+ (Safari|Mobile)\//.test(userAgent), // todo: update when Safari bug is fixed
      			destroy,
      			prop;
      		
      		// add event hook
      		fireEvent(series, 'destroy');
      		
      		// remove all events
      		removeEvent(series);
      			
      		// remove legend items
      		if (series.legendItem) {
      			series.chart.legend.destroyItem(series);
      		}
      		
      		// destroy all points with their elements
      		each(series.data, function(point) {
      			point.destroy();
      		});
      		// destroy all SVGElements associated to the series
      		each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function(prop) {
      			if (series[prop]) {
      				
      				// issue 134 workaround
      				destroy = issue134 && prop === 'group' ?
      					'hide' :
      					'destroy';
      					
      				series[prop][destroy]();
      			}
      		});
      		
      		// remove from hoverSeries
      		if (chart.hoverSeries === series) {
      			chart.hoverSeries = null;
      		}
      		erase(chart.series, series);
      				
      		// clear all members
      		for (prop in series) {
      			delete series[prop];
      		} 
      	},
      	
      	/**
      	 * Draw the data labels
      	 */
      	drawDataLabels: function() {
      		if (this.options.dataLabels.enabled) {
      			var series = this,
      				x, 
      				y, 
      				data = series.data, 
      				options = series.options.dataLabels,
      				str, 
      				dataLabelsGroup = series.dataLabelsGroup, 
      				chart = series.chart, 
      				inverted = chart.inverted,
      				seriesType = series.type,
      				color,
      				stacking = series.options.stacking,
      				isBarLike = seriesType === 'column' || seriesType === 'bar',
      				vAlignIsNull = options.verticalAlign === null,
      				yIsNull = options.y === null;
      
      			if (isBarLike) {
      				if (stacking) {
      					// In stacked series the default label placement is inside the bars
      					if (vAlignIsNull) {
      						options = merge(options, {verticalAlign: 'middle'});
      					}
      
      					// If no y delta is specified, try to create a good default
      					if (yIsNull) {
      						options = merge(options, {y: {top: 14, middle: 4, bottom: -6}[options.verticalAlign]}); 
      					}
      				} else {
      					// In non stacked series the default label placement is on top of the bars
      					if (vAlignIsNull) {
      						options = merge(options, {verticalAlign: 'top'});
      					}
      				}
      			}
      
      			// create a separate group for the data labels to avoid rotation
      			if (!dataLabelsGroup) {
      				dataLabelsGroup = series.dataLabelsGroup = 
      					chart.renderer.g('data-labels')
      						.attr({ 
      							visibility: series.visible ? VISIBLE : HIDDEN,
      							zIndex: 6							
      						})
      						.translate(chart.plotLeft, chart.plotTop)
      						.add();
      			}
      		
      			// determine the color
      			color = options.color;
      			if (color === 'auto') { // 1.0 backwards compatibility
      				color = null;	
      			}
      			options.style.color = pick(color, series.color);
      		
      			// make the labels for each point
      			each(data, function(point, i){
      				var barX = point.barX,
      					plotX = (barX && barX + point.barW / 2) || point.plotX || -999,
      					plotY = pick(point.plotY, -999),
      					dataLabel = point.dataLabel,
      					align = options.align,
      					individualYDelta = yIsNull ? (point.y > 0 ? -6 : 12) : options.y;
      
      				// get the string
      				str = options.formatter.call(point.getLabelConfig());
      				x = (inverted ? chart.plotWidth - plotY : plotX) + options.x;
      				y = (inverted ? chart.plotHeight - plotX : plotY) + individualYDelta;
      				
      				// in columns, align the string to the column
      				if (seriesType === 'column') {
      					x += { left: -1, right: 1 }[align] * point.barW / 2 || 0;
      				}
      				
      				if (inverted && point.y < 0) {
      					align = 'right';
      					x -= 10;
      				}
      
      				// update existing label
      				if (dataLabel) {
      					// vertically centered
      					if (inverted && !options.y) {
      						y = y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2;
      					}
      					dataLabel
      						.attr({
      							text: str
      						}).animate({
      							x: x,
      							y: y
      						});
      				// create new label
      				} else if (defined(str)) {
      					dataLabel = point.dataLabel = chart.renderer.text(
      						str, 
      						x, 
      						y
      					)
      					.attr({
      						align: align,
      						rotation: options.rotation,
      						zIndex: 1
      					})
      					.css(options.style)
      					.add(dataLabelsGroup);
      					// vertically centered
      					if (inverted && !options.y) {
      						dataLabel.attr({
      							y: y + pInt(dataLabel.styles.lineHeight) * 0.9 - dataLabel.getBBox().height / 2
      						});
      					}
      				}
      				
      				
      				/*if (series.isCartesian) {
      					dataLabel[chart.isInsidePlot(plotX, plotY) ? 'show' : 'hide']();
      				}*/
      
      				if (isBarLike && series.options.stacking) {
      					var barY = point.barY,
      						barW = point.barW,
      						barH = point.barH;
      
      					dataLabel.align(options, null, 
      						{
      							x: inverted ? chart.plotWidth - barY - barH : barX,
      							y: inverted ? chart.plotHeight - barX - barW : barY,
      							width: inverted ? barH : barW,
      							height: inverted ? barW : barH
      						});
      				}
      			});
      		}
      	},
      	
      	/**
      	 * Draw the actual graph
      	 */
      	drawGraph: function(state) {
      		var series = this, 
      			options = series.options, 
      			chart = series.chart,
      			graph = series.graph,
      			graphPath = [],
      			fillColor,
      			area = series.area,
      			group = series.group,
      			color = options.lineColor || series.color, 
      			lineWidth = options.lineWidth,
      			dashStyle =  options.dashStyle,
      			segmentPath,
      			renderer = chart.renderer,
      			translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),
      			useArea = /^area/.test(series.type),
      			singlePoints = [], // used in drawTracker
      			areaPath = [],
      			attribs;
      			
      		
      		// divide into segments and build graph and area paths
      		each(series.segments, function(segment) {
      			segmentPath = [];
      			
      			// build the segment line
      			each(segment, function(point, i) {
      
      				if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
      					segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));
      				
      				} else {
      				
      					// moveTo or lineTo
      					segmentPath.push(i ? L : M);
      					
      					// step line?
      					if (i && options.step) {
      						var lastPoint = segment[i - 1];
      						segmentPath.push(
      							point.plotX, 
      							lastPoint.plotY						
      						);
      					}
      					
      					// normal line to next point
      					segmentPath.push(
      						point.plotX, 
      						point.plotY
      					);
      				}
      			});
      			
      			// add the segment to the graph, or a single point for tracking
      			if (segment.length > 1) {
      				graphPath = graphPath.concat(segmentPath);
      			} else {
      				singlePoints.push(segment[0]);
      			}
      			
      			// build the area
      			if (useArea) {
      				var areaSegmentPath = [],
      					i,
      					segLength = segmentPath.length;
      				for (i = 0; i < segLength; i++) {
      					areaSegmentPath.push(segmentPath[i]);
      				}
      				if (segLength === 3) { // for animation from 1 to two points
      					areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
      				}
      				if (options.stacking && series.type !== 'areaspline') {
      					// follow stack back. Todo: implement areaspline
      					for (i = segment.length - 1; i >= 0; i--) {
      						areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
      					}
      				
      				} else { // follow zero line back
      					areaSegmentPath.push(
      						L,
      						segment[segment.length - 1].plotX, 
      						translatedThreshold,
      						L,
      						segment[0].plotX, 
      						translatedThreshold
      					);
      				}
      				areaPath = areaPath.concat(areaSegmentPath);
      			}
      		});
      
      		// used in drawTracker:
      		series.graphPath = graphPath;
      		series.singlePoints = singlePoints;
      
      		// draw the area if area series or areaspline
      		if (useArea) {
      			fillColor = pick(
      				options.fillColor,
      				Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
      			);
      			if (area) {
      				area.animate({ d: areaPath });
      			
      			} else {
      				// draw the area
      				series.area = series.chart.renderer.path(areaPath)
      					.attr({
      						fill: fillColor
      					}).add(group);
      			}
      		}
      		
      		// draw the graph
      		if (graph) {
      			//graph.animate({ d: graphPath.join(' ') });
      			graph.animate({ d: graphPath });
      			
      		} else {
      			if (lineWidth) {
      				attribs = {
      					'stroke': color,
      					'stroke-width': lineWidth
      				};
      				if (dashStyle) {
      					attribs.dashstyle = dashStyle;
      				}
      				
      				series.graph = renderer.path(graphPath)
      					.attr(attribs).add(group).shadow(options.shadow);
      			}
      		}
      	},
      	
      	
      	/**
      	 * Render the graph and markers
      	 */
      	render: function() {
      		var series = this,
      			chart = series.chart,
      			group,
      			setInvert,
      			options = series.options,
      			animation = options.animation,
      			doAnimation = animation && series.animate,
      			duration = doAnimation ? (animation && animation.duration) || 500 : 0,
      			clipRect = series.clipRect,
      			renderer = chart.renderer;
      			
      		
      		// Add plot area clipping rectangle. If this is before chart.hasRendered,
      		// create one shared clipRect. 
      		if (!clipRect) {
      			clipRect = series.clipRect = !chart.hasRendered && chart.clipRect ?
      				chart.clipRect : 
      				renderer.clipRect(0, 0, chart.plotSizeX, chart.plotSizeY);
      			if (!chart.clipRect) {
      				chart.clipRect = clipRect;
      			}
      		}
      		
      			
      		// the group
      		if (!series.group) {
      			group = series.group = renderer.g('series');
      				
      			if (chart.inverted) {
      				setInvert = function() {
      					group.attr({
      						width: chart.plotWidth,
      						height: chart.plotHeight
      					}).invert();
      				};
      				
      				setInvert(); // do it now
      				addEvent(chart, 'resize', setInvert); // do it on resize
      				addEvent(series, 'destroy', function() {
      					removeEvent(chart, 'resize', setInvert);
      				});
      			} 
      			group.clip(series.clipRect)
      				.attr({ 
      					visibility: series.visible ? VISIBLE : HIDDEN,
      					zIndex: options.zIndex
      				})
      				.translate(chart.plotLeft, chart.plotTop)
      				.add(chart.seriesGroup);
      		}
      			
      		series.drawDataLabels();
      
      		// initiate the animation
      		if (doAnimation) {
      			series.animate(true);
      		}
      		
      		// cache attributes for shapes
      		//series.getAttribs();
      		
      		// draw the graph if any
      		if (series.drawGraph) {
      			series.drawGraph();
      		}
      		
      		// draw the points
      		series.drawPoints();
      		
      		// draw the mouse tracking area
      		if (series.options.enableMouseTracking !== false) {
      			series.drawTracker();
      		}
      		
      		// run the animation
      		if (doAnimation) {
      			series.animate();
      		}
      		
      		// finish the individual clipRect
      		setTimeout(function() {
      			clipRect.isAnimating = false;
      			group = series.group; // can be destroyed during the timeout
      			if (group && clipRect !== chart.clipRect && clipRect.renderer) {
      				group.clip((series.clipRect = chart.clipRect));
      				clipRect.destroy();
      			}
      		}, duration);
      		
      		
      		series.isDirty = false; // means data is in accordance with what you see
      		
      	},
      	
      	/**
      	 * Redraw the series after an update in the axes.
      	 */
      	redraw: function() {
      		var series = this,
      			chart = series.chart,
      			clipRect = series.clipRect,
      			group = series.group;
      		
      		/*if (clipRect) {
      			stop(clipRect);
      			clipRect.animate({ // for chart resize
      				width: chart.plotSizeX,
      				height: chart.plotSizeY
      			});
      		}*/
      		
      		// reposition on resize
      		if (group) {
      			if (chart.inverted) {
      				group.attr({
      					width: chart.plotWidth,
      					height: chart.plotHeight
      				});
      			}
      			
      			group.animate({
      				translateX: chart.plotLeft, 
      				translateY: chart.plotTop
      			});
      		}
      		
      		series.translate();
      		series.setTooltipPoints(true);
      		series.render();
      	},
      	
      	/**
      	 * Set the state of the graph
      	 */
      	setState: function(state) {
      		var series = this,
      			options = series.options,
      			graph = series.graph,
      			stateOptions = options.states,
      			lineWidth = options.lineWidth;
      
      		state = state || NORMAL_STATE;
      				
      		if (series.state !== state) {
      			series.state = state;
      			
      			if (stateOptions[state] && stateOptions[state].enabled === false) {
      				return;
      			}
      		
      			if (state) {
      				lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
      			}
      			
      			if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
      				graph.attr({ // use attr because animate will cause any other animation on the graph to stop
      					'stroke-width': lineWidth
      				}, state ? 0 : 500);
      			}
      		}
      	},
      	
      	/**
      	 * Set the visibility of the graph
      	 * 
      	 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
      	 *        the visibility is toggled.
      	 */
      	setVisible: function(vis, redraw) {
      		var series = this,
      			chart = series.chart,
      			legendItem = series.legendItem,
      			seriesGroup = series.group,
      			seriesTracker = series.tracker,
      			dataLabelsGroup = series.dataLabelsGroup,
      			showOrHide,
      			i,
      			data = series.data,
      			point,
      			ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
      			oldVisibility = series.visible;
      		
      		// if called without an argument, toggle visibility
      		series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
      		showOrHide = vis ? 'show' : 'hide';
      		
      		// show or hide series
      		if (seriesGroup) { // pies don't have one
      			seriesGroup[showOrHide]();
      		}
      		
      		// show or hide trackers
      		if (seriesTracker) {
      			seriesTracker[showOrHide]();
      		} else {
      			i = data.length;
      			while (i--) {
      				point = data[i];
      				if (point.tracker) {
      					point.tracker[showOrHide]();
      				}
      			}
      		}
      		
      		
      		if (dataLabelsGroup) {
      			dataLabelsGroup[showOrHide]();
      		}
      		
      		if (legendItem) {
      			chart.legend.colorizeItem(series, vis);
      		}
      			
      		
      		// rescale or adapt to resized chart
      		series.isDirty = true;
      		// in a stack, all other series are affected
      		if (series.options.stacking) {
      			each(chart.series, function(otherSeries) {
      				if (otherSeries.options.stacking && otherSeries.visible) { 
      					otherSeries.isDirty = true;
      				}
      			});
      		}
      		
      		if (ignoreHiddenSeries) {
      			chart.isDirtyBox = true;
      		}
      		if (redraw !== false) {
      			chart.redraw();
      		}
      		
      		fireEvent(series, showOrHide);
      	},
      	
      	/**
      	 * Show the graph
      	 */
      	show: function() {
      		this.setVisible(true);
      	},
      	
      	/**
      	 * Hide the graph
      	 */
      	hide: function() {
      		this.setVisible(false);
      	},
      	
      	
      	/**
      	 * Set the selected state of the graph
      	 * 
      	 * @param selected {Boolean} True to select the series, false to unselect. If
      	 *        UNDEFINED, the selection state is toggled.
      	 */
      	select: function(selected) {
      		var series = this;
      		// if called without an argument, toggle
      		series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;
      
      		if (series.checkbox) {
      			series.checkbox.checked = selected;
      		}
      		
      		fireEvent(series, selected ? 'select' : 'unselect');
      	},
      	
      	
      	/**
      	 * Draw the tracker object that sits above all data labels and markers to
      	 * track mouse events on the graph or points. For the line type charts
      	 * the tracker uses the same graphPath, but with a greater stroke width
      	 * for better control.
      	 */
      	drawTracker: function() {
      		var series = this,
      			options = series.options,
      			trackerPath = [].concat(series.graphPath),
      			trackerPathLength = trackerPath.length,
      			chart = series.chart,
      			snap = chart.options.tooltip.snap,
      			tracker = series.tracker,
      			cursor = options.cursor,
      			css = cursor && { cursor: cursor },
      			singlePoints = series.singlePoints,
      			singlePoint,
      			i;
      	
      		// Extend end points. A better way would be to use round linecaps,
      		// but those are not clickable in VML.
      		if (trackerPathLength) {
      			i = trackerPathLength + 1;
      			while (i--) {
      				if (trackerPath[i] === M) { // extend left side
      					trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
      				}
      				if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
      					trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
      				}
      			}
      		}
      		
      		// handle single points
      		for (i = 0; i < singlePoints.length; i++) {
      			singlePoint = singlePoints[i];
      			trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
      				L, singlePoint.plotX + snap, singlePoint.plotY);
      		}
      		
      		// draw the tracker
      		if (tracker) {
      			tracker.attr({ d: trackerPath });
      			
      		} else { // create
      			series.tracker = chart.renderer.path(trackerPath)
      				.attr({
      					isTracker: true,
      					stroke: TRACKER_FILL,
      					fill: NONE,
      					'stroke-width' : options.lineWidth + 2 * snap,
      					visibility: series.visible ? VISIBLE : HIDDEN,
      					zIndex: 1
      				})
      				.on(hasTouch ? 'touchstart' : 'mouseover', function() {
      					if (chart.hoverSeries !== series) {
      						series.onMouseOver();
      					}
      				})
      				.on('mouseout', function() {
      					if (!options.stickyTracking) {
      						series.onMouseOut();
      					}
      				})
      				.css(css)
      				.add(chart.trackerGroup);
      		}
      		
      	}
      	
      }; // end Series prototype
      
      
      /**
       * LineSeries object
       */
      var LineSeries = extendClass(Series);
      seriesTypes.line = LineSeries;
      
      /**
       * AreaSeries object
       */
      var AreaSeries = extendClass(Series, {
      	type: 'area'
      });
      seriesTypes.area = AreaSeries;
      
      
      
      
      /**
       * SplineSeries object
       */
      var SplineSeries = extendClass( Series, {
      	type: 'spline',
      	
      	/**
      	 * Draw the actual graph
      	 */
      	getPointSpline: function(segment, point, i) {
      		var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
      			denom = smoothing + 1,
      			plotX = point.plotX,
      			plotY = point.plotY,
      			lastPoint = segment[i - 1],
      			nextPoint = segment[i + 1],
      			leftContX,
      			leftContY,
      			rightContX,
      			rightContY,
      			ret;
      			
      		// find control points
      		if (i && i < segment.length - 1) {
      			var lastX = lastPoint.plotX,
      				lastY = lastPoint.plotY,
      				nextX = nextPoint.plotX,
      				nextY = nextPoint.plotY,
      				correction;
      			
      			leftContX = (smoothing * plotX + lastX) / denom;
      			leftContY = (smoothing * plotY + lastY) / denom;
      			rightContX = (smoothing * plotX + nextX) / denom;
      			rightContY = (smoothing * plotY + nextY) / denom;
      		
      			// have the two control points make a straight line through main point
      			correction = ((rightContY - leftContY) * (rightContX - plotX)) / 
      				(rightContX - leftContX) + plotY - rightContY;
      				
      			leftContY += correction;
      			rightContY += correction;
      			
      			// to prevent false extremes, check that control points are between
      			// neighbouring points' y values
      			if (leftContY > lastY && leftContY > plotY) {
      				leftContY = mathMax(lastY, plotY);
      				rightContY = 2 * plotY - leftContY; // mirror of left control point
      			} else if (leftContY < lastY && leftContY < plotY) {
      				leftContY = mathMin(lastY, plotY);
      				rightContY = 2 * plotY - leftContY;
      			} 
      			if (rightContY > nextY && rightContY > plotY) {
      				rightContY = mathMax(nextY, plotY);
      				leftContY = 2 * plotY - rightContY;
      			} else if (rightContY < nextY && rightContY < plotY) {
      				rightContY = mathMin(nextY, plotY);
      				leftContY = 2 * plotY - rightContY;
      			}
      			
      			// record for drawing in next point
      			point.rightContX = rightContX;
      			point.rightContY = rightContY;
      			
      		}
      		
      		// moveTo or lineTo
      		if (!i) {
      			ret = [M, plotX, plotY];
      		}
      		
      		// curve from last point to this
      		else {
      			ret = [
      				'C',
      				lastPoint.rightContX || lastPoint.plotX, 
      				lastPoint.rightContY || lastPoint.plotY,
      				leftContX || plotX, 
      				leftContY || plotY,
      				plotX, 
      				plotY
      			];
      			lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
      		}
      		return ret;
      	}
      });
      seriesTypes.spline = SplineSeries;
      
      
      
      /**
       * AreaSplineSeries object
       */
      var AreaSplineSeries = extendClass(SplineSeries, {
      	type: 'areaspline'
      });
      seriesTypes.areaspline = AreaSplineSeries;
      
      /**
       * ColumnSeries object
       */
      var ColumnSeries = extendClass(Series, {
      	type: 'column',
      	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
      		stroke: 'borderColor',
      		'stroke-width': 'borderWidth',
      		fill: 'color',
      		r: 'borderRadius'
      	},
      	init: function() {
      		Series.prototype.init.apply(this, arguments);
      		
      		var series = this,
      			chart = series.chart;
      		
      		// flag the chart in order to pad the x axis
      		chart.hasColumn = true;
      		
      		// if the series is added dynamically, force redraw of other
      		// series affected by a new column
      		if (chart.hasRendered) {
      			each(chart.series, function(otherSeries) {
      				if (otherSeries.type === series.type) {
      					otherSeries.isDirty = true;
      				}
      			});
      		}
      	},
      	
      	/**
      	 * Translate each point to the plot area coordinate system and find shape positions
      	 */
      	translate: function() {
      		var series = this,
      			chart = series.chart,
      			options = series.options,
      			stacking = options.stacking,
      			borderWidth = options.borderWidth,
      			columnCount = 0,
      			reversedXAxis = series.xAxis.reversed,
      			categories = series.xAxis.categories,
      			stackGroups = {},
      			stackKey,
      			columnIndex;
      		
      		Series.prototype.translate.apply(series);
      		
      		// Get the total number of column type series.
      		// This is called on every series. Consider moving this logic to a 
      		// chart.orderStacks() function and call it on init, addSeries and removeSeries
      		each(chart.series, function(otherSeries) {
      			if (otherSeries.type === series.type && otherSeries.visible) {
      				if (otherSeries.options.stacking) {
      					stackKey = otherSeries.stackKey;
      					if (stackGroups[stackKey] === UNDEFINED) {
      						stackGroups[stackKey] = columnCount++;	
      					}					
      					columnIndex = stackGroups[stackKey];
      				} else {
      					columnIndex = columnCount++;
      				}
      				otherSeries.columnIndex = columnIndex;
      			}
      		});
      		
      		// calculate the width and position of each column based on 
      		// the number of column series in the plot, the groupPadding
      		// and the pointPadding options
      		var data = series.data,
      			closestPoints = series.closestPoints,
      			categoryWidth = mathAbs(
      				data[1] ? data[closestPoints].plotX - data[closestPoints - 1].plotX : 
      				chart.plotSizeX / ((categories && categories.length) || 1)
      			),
      			groupPadding = categoryWidth * options.groupPadding,
      			groupWidth = categoryWidth - 2 * groupPadding,
      			pointOffsetWidth = groupWidth / columnCount,
      			optionPointWidth = options.pointWidth,
      			pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 : 
      				pointOffsetWidth * options.pointPadding,
      			pointWidth = mathMax(pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), 1),
      			colIndex = (reversedXAxis ? columnCount - 
      				series.columnIndex : series.columnIndex) || 0,
      			pointXOffset = pointPadding + (groupPadding + colIndex *
      				pointOffsetWidth -(categoryWidth / 2)) *
      				(reversedXAxis ? -1 : 1),
      			threshold = options.threshold || 0,
      			translatedThreshold = series.yAxis.getThreshold(threshold),
      			minPointLength = pick(options.minPointLength, 5);
      		
      		// record the new values
      		each(data, function(point) {
      			var plotY = point.plotY,
      				yBottom = point.yBottom || translatedThreshold,
      				barX = point.plotX + pointXOffset,
      				barY = mathCeil(mathMin(plotY, yBottom)), 
      				barH = mathCeil(mathMax(plotY, yBottom) - barY),
      				stack = series.yAxis.stacks[(point.y < 0 ? '-' : '') + series.stackKey],
      				trackerY,
      				shapeArgs;
      			
      			// Record the offset'ed position and width of the bar to be able to align the stacking total correctly
      			if (stacking && series.visible && stack && stack[point.x]) {
      				stack[point.x].setOffset(pointXOffset, pointWidth);
      			}
      			
      			// handle options.minPointLength and tracker for small points
      			if (mathAbs(barH) < minPointLength) { 
      				if (minPointLength) {
      					barH = minPointLength;
      					barY = 
      						mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
      							yBottom - minPointLength : // keep position
      							translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
      				}
      				trackerY = barY - 3;
      			}
      			
      			extend(point, {
      				barX: barX,
      				barY: barY, 
      				barW: pointWidth,
      				barH: barH
      			});
      			
      			// create shape type and shape args that are reused in drawPoints and drawTracker
      			point.shapeType = 'rect';
      			shapeArgs = extend(chart.renderer.Element.prototype.crisp.apply({}, [
      				borderWidth,
      				barX,
      				barY,
      				pointWidth,
      				barH
      			]), {
      				r: options.borderRadius
      			});
      			if (borderWidth % 2) { // correct for shorting in crisp method, visible in stacked columns with 1px border
      				shapeArgs.y -= 1;
      				shapeArgs.height += 1;
      			}
      			point.shapeArgs = shapeArgs;
      			
      			// make small columns responsive to mouse
      			point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
      				height: mathMax(6, barH + 3),
      				y: trackerY
      			});
      		});
      		
      	},
      	
      	getSymbol: function(){
      	},
      	
      	/** 
      	 * Columns have no graph
      	 */
      	drawGraph: function() {},
      	
      	/**
      	 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
      	 * apply for columns and bars. This method is inherited by scatter series.
      	 * 
      	 */
      	drawPoints: function() {
      		var series = this,
      			options = series.options,
      			renderer = series.chart.renderer,
      			graphic,
      			shapeArgs;		
      		
      		
      		// draw the columns
      		each(series.data, function(point) {			
      			var plotY = point.plotY;
      			if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
      				graphic = point.graphic;
      				shapeArgs = point.shapeArgs;
      				if (graphic) { // update
      					stop(graphic);
      					graphic.animate(shapeArgs);
      				
      				} else {
      					point.graphic = renderer[point.shapeType](shapeArgs)
      						.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
      						.add(series.group)
      						.shadow(options.shadow);
      				}
      			
      			}
      		});
      	},
      	/**
      	 * Draw the individual tracker elements.
      	 * This method is inherited by scatter and pie charts too.
      	 */
      	drawTracker: function() {
      		var series = this,
      			chart = series.chart,
      			renderer = chart.renderer,
      			shapeArgs,
      			tracker,
      			trackerLabel = +new Date(),
      			cursor = series.options.cursor,
      			css = cursor && { cursor: cursor },
      			rel;
      			
      		each(series.data, function(point) {
      			tracker = point.tracker;
      			shapeArgs = point.trackerArgs || point.shapeArgs;
      			delete shapeArgs.strokeWidth;
      			if (point.y !== null) {
      				if (tracker) {// update
      					tracker.attr(shapeArgs);
      					
      				} else {
      					point.tracker = 
      						renderer[point.shapeType](shapeArgs)
      						.attr({
      							isTracker: trackerLabel,
      							fill: TRACKER_FILL,
      							visibility: series.visible ? VISIBLE : HIDDEN,
      							zIndex: 1
      						})
      						.on(hasTouch ? 'touchstart' : 'mouseover', function(event) {
      							rel = event.relatedTarget || event.fromElement;
      							if (chart.hoverSeries !== series && attr(rel, 'isTracker') !== trackerLabel) {
      								series.onMouseOver();
      							}
      							point.onMouseOver();
      							
      						})
      						.on('mouseout', function(event) {
      							if (!series.options.stickyTracking) {
      								rel = event.relatedTarget || event.toElement;
      								if (attr(rel, 'isTracker') !== trackerLabel) {
      									series.onMouseOut();
      								}
      							}
      						})
      						.css(css)
      						.add(point.group || chart.trackerGroup); // pies have point group - see issue #118
      				}
      			}
      		});
      	},
      	
      	
      	/**
      	 * Animate the column heights one by one from zero
      	 * @param {Boolean} init Whether to initialize the animation or run it 
      	 */
      	animate: function(init) {
      		var series = this,
      			data = series.data;
      			
      		if (!init) { // run the animation
      			/*
      			 * Note: Ideally the animation should be initialized by calling
      			 * series.group.hide(), and then calling series.group.show()
      			 * after the animation was started. But this rendered the shadows
      			 * invisible in IE8 standards mode. If the columns flicker on large
      			 * datasets, this is the cause.
      			 */
      			
      			each(data, function(point) {
      				var graphic = point.graphic,
      					shapeArgs = point.shapeArgs;
      				
      				if (graphic) {
      					// start values
      					graphic.attr({ 
      						height: 0,
      						y: series.yAxis.translate(0, 0, 1)
      					});
      					
      					// animate
      					graphic.animate({ 
      						height: shapeArgs.height,
      						y: shapeArgs.y
      					}, series.options.animation);
      				}
      			});
      			
      			
      			// delete this function to allow it only once
      			series.animate = null;
      		}
      		
      	},
      	/**
      	 * Remove this series from the chart
      	 */
      	remove: function() {
      		var series = this,
      			chart = series.chart;
      			
      		// column and bar series affects other series of the same type
      		// as they are either stacked or grouped
      		if (chart.hasRendered) {
      			each(chart.series, function(otherSeries) {
      				if (otherSeries.type === series.type) {
      					otherSeries.isDirty = true;
      				}
      			});
      		}
      		
      		Series.prototype.remove.apply(series, arguments);
      	}
      });
      seriesTypes.column = ColumnSeries;
      
      var BarSeries = extendClass(ColumnSeries, {
      	type: 'bar',
      	init: function(chart) {
      		chart.inverted = this.inverted = true;
      		ColumnSeries.prototype.init.apply(this, arguments);
      	}
      });
      seriesTypes.bar = BarSeries;
      
      /**
       * The scatter series class
       */
      var ScatterSeries = extendClass(Series, {
      	type: 'scatter',
      	
      	/**
      	 * Extend the base Series' translate method by adding shape type and
      	 * arguments for the point trackers
      	 */
      	translate: function() {
      		var series = this;
      
      		Series.prototype.translate.apply(series);
      
      		each(series.data, function(point) {
      			point.shapeType = 'circle';
      			point.shapeArgs = {
      				x: point.plotX,
      				y: point.plotY,
      				r: series.chart.options.tooltip.snap
      			};
      		});
      	},
      	
      	
      	/**
      	 * Create individual tracker elements for each point
      	 */
      	//drawTracker: ColumnSeries.prototype.drawTracker,
      	drawTracker: function() {
      		var series = this,
      			cursor = series.options.cursor,
      			css = cursor && { cursor: cursor },
      			graphic;
      			
      		each(series.data, function(point) {
      			graphic = point.graphic;
      			if (graphic) { // doesn't exist for null points
      				graphic
      					.attr({ isTracker: true })
      					.on('mouseover', function(event) {
      						series.onMouseOver();
      						point.onMouseOver();					
      					})
      					.on('mouseout', function(event) {
      						if (!series.options.stickyTracking) {
      							series.onMouseOut();
      						}
      					})
      					.css(css);
      			}
      		});
      
      	},
      	
      	/**
      	 * Cleaning the data is not necessary in a scatter plot
      	 */
      	cleanData: function() {}
      });
      seriesTypes.scatter = ScatterSeries;
      
      /**
       * Extended point object for pies
       */
      var PiePoint = extendClass(Point, {
      	/**
      	 * Initiate the pie slice
      	 */
      	init: function () {
      		
      		Point.prototype.init.apply(this, arguments);
      		
      		var point = this,
      			toggleSlice;
      		
      		//visible: options.visible !== false,
      		extend(point, {
      			visible: point.visible !== false,
      			name: pick(point.name, 'Slice')
      		});
      		
      		// add event listener for select
      		toggleSlice = function() {
      			point.slice();
      		};
      		addEvent(point, 'select', toggleSlice);
      		addEvent(point, 'unselect', toggleSlice);
      		
      		return point;
      	},
      	
      	/**
      	 * Toggle the visibility of the pie slice
      	 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
      	 *    visibility is toggled
      	 */
      	setVisible: function(vis) {	
      		var point = this, 
      			chart = point.series.chart,
      			tracker = point.tracker,
      			dataLabel = point.dataLabel,
      			connector = point.connector,
      			shadowGroup = point.shadowGroup,
      			method;
      		
      		// if called without an argument, toggle visibility
      		point.visible = vis = vis === UNDEFINED ? !point.visible : vis;
      		
      		method = vis ? 'show' : 'hide';
      		
      		point.group[method]();
      		if (tracker) {
      			tracker[method]();
      		}
      		if (dataLabel) {
      			dataLabel[method]();
      		}
      		if (connector) {
      			connector[method]();
      		}
      		if (shadowGroup) {
      			shadowGroup[method]();
      		}
      		if (point.legendItem) {
      			chart.legend.colorizeItem(point, vis);
      		}
      	},
      	
      	/**
      	 * Set or toggle whether the slice is cut out from the pie
      	 * @param {Boolean} sliced When undefined, the slice state is toggled 
      	 * @param {Boolean} redraw Whether to redraw the chart. True by default.
      	 */
      	slice: function(sliced, redraw, animation) {
      		var point = this,
      			series = point.series,
      			chart = series.chart,
      			slicedTranslation = point.slicedTranslation,
      			translation;
      			
      		setAnimation(animation, chart);
      		
      		// redraw is true by default
      		redraw = pick(redraw, true);
      			
      		// if called without an argument, toggle
      		sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;
      		
      		translation = {
      			translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
      			translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
      		};
      		point.group.animate(translation);
      		if (point.shadowGroup) {
      			point.shadowGroup.animate(translation);
      		}
      		
      	}
      });
      
      /**
       * The Pie series class
       */
      var PieSeries = extendClass(Series, {
      	type: 'pie',
      	isCartesian: false,
      	pointClass: PiePoint,
      	pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
      		stroke: 'borderColor',
      		'stroke-width': 'borderWidth',
      		fill: 'color'
      	},
      	
      	/**
      	 * Pies have one color each point
      	 */
      	getColor: function() {
      		// record first color for use in setData
      		this.initialColor = this.chart.counters.color;
      	},
      	
      	/**
      	 * Animate the column heights one by one from zero
      	 * @param {Boolean} init Whether to initialize the animation or run it 
      	 */
      	animate: function(init) {
      		var series = this,
      			data = series.data;
      			
      		each(data, function(point) {
      			var graphic = point.graphic,
      				args = point.shapeArgs,
      				up = -mathPI / 2;
      			
      			if (graphic) {
      				// start values
      				graphic.attr({ 
      					r: 0,
      					start: up,
      					end: up
      				});
      				
      				// animate
      				graphic.animate({ 
      					r: args.r,
      					start: args.start,
      					end: args.end
      				}, series.options.animation);
      			}
      		});
      		
      		// delete this function to allow it only once
      		series.animate = null;
      		
      	},
      	/**
      	 * Do translation for pie slices
      	 */
      	translate: function() {
      		var total = 0,
      			series = this,
      			cumulative = -0.25, // start at top
      			precision = 1000, // issue #172
      			options = series.options,
      			slicedOffset = options.slicedOffset,
      			connectorOffset = slicedOffset + options.borderWidth,
      			positions = options.center.concat([options.size, options.innerSize || 0]),
      			chart = series.chart,
      			plotWidth = chart.plotWidth,
      			plotHeight = chart.plotHeight,
      			start,
      			end,
      			angle,
      			data = series.data,
      			circ = 2 * mathPI,
      			fraction,
      			smallestSize = mathMin(plotWidth, plotHeight),
      			isPercent,
      			radiusX, // the x component of the radius vector for a given point
      			radiusY,
      			labelDistance = options.dataLabels.distance;
      			
      		// get positions - either an integer or a percentage string must be given
      		positions = map(positions, function(length, i) {
      			
      			isPercent = /%$/.test(length);			
      			return isPercent ? 
      				// i == 0: centerX, relative to width
      				// i == 1: centerY, relative to height
      				// i == 2: size, relative to smallestSize
      				// i == 4: innerSize, relative to smallestSize
      				[plotWidth, plotHeight, smallestSize, smallestSize][i] *
      					pInt(length) / 100:
      				length;
      		});
      		
      		// utility for getting the x value from a given y, used for anticollision logic in data labels
      		series.getX = function(y, left) {
      			
      			angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));
      			
      			return positions[0] + 
      				(left ? -1 : 1) *
      				(mathCos(angle) * (positions[2] / 2 + labelDistance));
      		};
      		
      		// set center for later use
      		series.center = positions;
      					
      		// get the total sum
      		each(data, function(point) {
      			total += point.y;
      		});
      		
      		each(data, function(point) {
      			// set start and end angle
      			fraction = total ? point.y / total : 0;
      			start = mathRound(cumulative * circ * precision) / precision;
      			cumulative += fraction;
      			end = mathRound(cumulative * circ * precision) / precision;
      			
      			// set the shape
      			point.shapeType = 'arc';
      			point.shapeArgs = {
      				x: positions[0],
      				y: positions[1],
      				r: positions[2] / 2,
      				innerR: positions[3] / 2,
      				start: start,
      				end: end
      			};
      			
      			// center for the sliced out slice
      			angle = (end + start) / 2;
      			point.slicedTranslation = map([
      				mathCos(angle) * slicedOffset + chart.plotLeft, 
      				mathSin(angle) * slicedOffset + chart.plotTop
      			], mathRound);
      			
      			// set the anchor point for tooltips
      			radiusX = mathCos(angle) * positions[2] / 2;
      			series.radiusY = radiusY = mathSin(angle) * positions[2] / 2;
      			point.tooltipPos = [
      				positions[0] + radiusX * 0.7,
      				positions[1] + radiusY * 0.7
      			];
      			
      			// set the anchor point for data labels			
      			point.labelPos = [
      				positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
      				positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
      				positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
      				positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
      				positions[0] + radiusX, // landing point for connector
      				positions[1] + radiusY, // a/a
      				labelDistance < 0 ? // alignment
      					'center' :
      					angle < circ / 4 ? 'left' : 'right', // alignment
      				angle // center angle
      			];
      			
      			// API properties
      			point.percentage = fraction * 100;
      			point.total = total;
      			
      		});
      		
      		
      		this.setTooltipPoints();
      	},
      	
      	/**
      	 * Render the slices
      	 */
      	render: function() {
      		var series = this;
      			
      		// cache attributes for shapes
      		//series.getAttribs();
      
      		this.drawPoints();
      		
      		// draw the mouse tracking area
      		if (series.options.enableMouseTracking !== false) {
      			series.drawTracker();
      		}
      		
      		this.drawDataLabels();
      		
      		if (series.options.animation && series.animate) {
      			series.animate();
      		}
      		
      		series.isDirty = false; // means data is in accordance with what you see
      	},
      	
      	/**
      	 * Draw the data points
      	 */
      	drawPoints: function() {
      		var series = this,
      			chart = series.chart,
      			renderer = chart.renderer,
      			groupTranslation,
      			//center,
      			graphic,
      			group,
      			shadow = series.options.shadow,
      			shadowGroup,
      			shapeArgs;
      			
      		
      		// draw the slices
      		each(series.data, function(point) {
      			graphic = point.graphic;
      			shapeArgs = point.shapeArgs;
      			group = point.group;
      			shadowGroup = point.shadowGroup;
      
      			// put the shadow behind all points
      			if (shadow && !shadowGroup) {
      				shadowGroup = point.shadowGroup = renderer.g('shadow')
      					.attr({ zIndex: 4 })
      					.add();
      			}
      		
      			// create the group the first time
      			if (!group) {
      				group = point.group = renderer.g('point')
      					.attr({ zIndex: 5 })
      					.add();
      			}
      			
      			// if the point is sliced, use special translation, else use plot area traslation
      			groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
      			group.translate(groupTranslation[0], groupTranslation[1]);
      			if (shadowGroup) {
      				shadowGroup.translate(groupTranslation[0], groupTranslation[1]);
      			}
      				
      			
      			// draw the slice
      			if (graphic) {
      				graphic.animate(shapeArgs);
      			} else {
      				point.graphic = 
      					renderer.arc(shapeArgs)
      					.attr(extend(
      						point.pointAttr[NORMAL_STATE],
      						{ 'stroke-linejoin': 'round' }
      					))
      					.add(point.group)
      					.shadow(shadow, shadowGroup);
      			}
      			
      			// detect point specific visibility
      			if (point.visible === false) {
      				point.setVisible(false);
      			}
      					
      		});
      		
      	},
      	
      	/**
      	 * Override the base drawDataLabels method by pie specific functionality
      	 */
      	drawDataLabels: function() {
      		var series = this,
      			data = series.data,
      			point,
      			chart = series.chart,
      			options = series.options.dataLabels,
      			connectorPadding = pick(options.connectorPadding, 10),
      			connectorWidth = pick(options.connectorWidth, 1),
      			connector,
      			connectorPath,
      			distanceOption = options.distance,
      			radiusY = series.radiusY,
      			outside = distanceOption > 0,
      			dataLabel,
      			labelPos,
      			labelHeight,
      			lastY,
      			centerY = series.center[1],
      			halves = [// divide the points into right and left halves for anti collision
      				[], // right
      				[]  // left
      			],
      			x,
      			y,
      			visibility,
      			overlapping,
      			rankArr,
      			secondPass,
      			sign,
      			lowerHalf,
      			sort,
      			i = 2,
      			j;
      			
      		// get out if not enabled
      		if (!options.enabled) {
      			return;
      		}
      			
      		// run parent method
      		Series.prototype.drawDataLabels.apply(series);
      		
      		// arrange points for detection collision
      		each(data, function(point) {
      			halves[
      				point.labelPos[7] < mathPI / 2 ? 0 : 1
      			].push(point);
      		});
      		halves[1].reverse();
      		
      		// define the sorting algorithm
      		sort = function(a, b) {
      			return b.y - a.y;
      		};
      		
      		// assume equal label heights
      		labelHeight = halves[0][0] && halves[0][0].dataLabel && pInt(halves[0][0].dataLabel.styles.lineHeight);
      			
      		/* Loop over the points in each quartile, starting from the top and bottom
      		 * of the pie to detect overlapping labels.
      		 */
      		while (i--) {
      			
      			var slots = [],
      				slotsLength,
      				usedSlots = [],
      				points = halves[i],
      				pos,
      				length = points.length,
      				slotIndex;
      			
      			lowerHalf = i % 3;
      			sign = lowerHalf ? 1 : -1;
      			
      			// build the slots
      			for (pos = centerY + radiusY - distanceOption; pos <= centerY - radiusY + distanceOption; pos += labelHeight) {
      				slots.push(pos);
      				// visualize the slot 
      				/*	
      				var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
      					slotY = pos + chart.plotTop;
      				if (!isNaN(slotX)) {
      					chart.renderer.rect(slotX, slotY - 7, 100, labelHeight)
      						.attr({
      							'stroke-width': 1,
      							stroke: 'silver'
      						})
      						.add(); 
      					chart.renderer.text('Slot '+ (slots.length - 1), slotX, slotY + 4)
      						.attr({
      							fill: 'silver'
      						}).add();
      				}
      				// */
      			}
      			slotsLength = slots.length;
      			
      			// if there are more values than available slots, remove lowest values
      			if (length > slotsLength) {
      				// create an array for sorting and ranking the points within each quarter
      				rankArr = [].concat(points);
      				rankArr.sort(sort);
      				j = length;
      				while (j--) {
      					rankArr[j].rank = j;
      				}
      				j = length;
      				while (j--) {
      					if (points[j].rank >= slotsLength) {
      						points.splice(j, 1);		
      					}
      				}
      				length = points.length;
      			}
      				
      			// The label goes to the nearest open slot, but not closer to the edge than
      			// the label's index.				
      			for (j = 0; j < length; j++) {
      				
      				point = points[j];
      				labelPos = point.labelPos;	
      				
      				var closest = 9999,
      					distance,
      					slotI;
      				
      				// find the closest slot index
      				for (slotI = 0; slotI < slotsLength; slotI++) {
      					distance = mathAbs(slots[slotI] - labelPos[1]);
      					if (distance < closest) {
      						closest = distance;
      						slotIndex = slotI;
      					}
      				}
      				
      				// if that slot index is closer to the edges of the slots, move it
      				// to the closest appropriate slot
      				if (slotIndex < j && slots[j] !== null) { // cluster at the top
      					slotIndex = j;
      				} else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
      					slotIndex = slotsLength - length + j;
      				} else { 
      					// Slot is taken, find next free slot below. In the next run, the next slice will find the
      					// slot above these, because it is the closest one 
      					while(slots[slotIndex] === null) {
      						slotIndex++;
      					}
      				}
      				
      				usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
      				slots[slotIndex] = null; // mark as taken
      			}
      			// sort them in order to fill in from the top
      			usedSlots.sort(sort);
      			
      			
      			// now the used slots are sorted, fill them up sequentially
      			for (j = 0; j < length; j++) {
      				
      				point = points[j];
      				labelPos = point.labelPos;
      				dataLabel = point.dataLabel;
      				var slot = usedSlots.pop(),
      					naturalY = labelPos[1];
      
      				visibility = point.visible === false ? HIDDEN : VISIBLE;
      				slotIndex = slot.i;
      
      				// if the slot next to currrent slot is free, the y value is allowed 
      				// to fall back to the natural position
      				y = slot.y;
      				if ((naturalY > y && slots[slotIndex + 1] !== null) ||
      						(naturalY < y &&  slots[slotIndex - 1] !== null)) {
      					y = naturalY;
      				}
      				
      				// get the x
      				x = series.getX(y, i);
      				
      				// move or place the data label
      				dataLabel
      					.attr({
      						visibility: visibility,
      						align: labelPos[6]
      					})[dataLabel.moved ? 'animate' : 'attr']({
      						x: x + options.x + 
      							({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
      						y: y + options.y
      					});
      				dataLabel.moved = true;
      				
      				// draw the connector
      				if (outside && connectorWidth) {
      					connector = point.connector;
      						
      					connectorPath = [
      						M,
      						x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
      						L,
      						x, y, // first break, next to the label
      						L,
      						labelPos[2], labelPos[3], // second break
      						L,
      						labelPos[4], labelPos[5] // base
      					];
      						
      					if (connector) {
      						connector.animate({ d: connectorPath });
      						connector.attr('visibility', visibility);
      					
      					} else {		
      						point.connector = connector = series.chart.renderer.path(connectorPath).attr({
      							'stroke-width': connectorWidth,
      							stroke: options.connectorColor || '#606060',
      							visibility: visibility,
      							zIndex: 3
      						})
      						.translate(chart.plotLeft, chart.plotTop)
      						.add();
      					}
      				}
      			}
      		}
      	},
      	
      	/**
      	 * Draw point specific tracker objects. Inherit directly from column series.
      	 */
      	drawTracker: ColumnSeries.prototype.drawTracker,
      	
      	/**
      	 * Pies don't have point marker symbols
      	 */
      	getSymbol: function() {}
      	
      });
      seriesTypes.pie = PieSeries;
      
      
      // global variables
      win.Highcharts = {
      	Chart: Chart,
      	dateFormat: dateFormat,
      	pathAnim: pathAnim,
      	getOptions: getOptions,
      	numberFormat: numberFormat,
      	Point: Point,
      	Color: Color,
      	Renderer: Renderer,
      	seriesTypes: seriesTypes,
      	setOptions: setOptions,
      	Series: Series,
      		
      	// Expose utility funcitons for modules
      	addEvent: addEvent,
      	createElement: createElement,
      	discardElement: discardElement,
      	css: css,
      	each: each,
      	extend: extend,
      	map: map,
      	merge: merge,
      	pick: pick,
      	extendClass: extendClass,
      	product: 'Highcharts',
      	version: '2.1.6'
      };
      }());
      
      var Report = {};
      Report.plot = function(selector, projects){  
        var sources = [], specs = [], labels = [];
        for(var i = 0; i < projects.length; i++){
          var project = projects[i];
          labels.push(project[0]);
          sources.push(project[1]);
          specs.push(project[2]);
        }
          
      	var chart = new Highcharts.Chart({
      		chart: {
      			renderTo: 'plot',
      			defaultSeriesType: 'column'
      		},
      		title: {
      			text: null // 'Stacked column chart'
      		},
      		xAxis: {
      			categories: labels,
      			labels: {
      			  rotation: -45, 
      			  align: 'right'
      			}
      		},
      		yAxis: {
      			min: 0,
      			title: {
      				text: 'Characters Count'
      			},
      			stackLabels: {
      				enabled: true,
      				style: {
      					fontWeight: 'bold',
      					color: (Highcharts.theme && Highcharts.theme.textColor) || 'gray'
      				}
      			}
      		},
      		legend: {
      			align: 'right',
      			x: -100,
      			verticalAlign: 'top',
      			y: 20,
      			floating: true,
      			backgroundColor: (Highcharts.theme && Highcharts.theme.legendBackgroundColorSolid) || 'white',
      			borderColor: '#CCC',
      			borderWidth: 1,
      			shadow: false
      		},
      		tooltip: {
      			formatter: function() {
      				return '<b>'+ this.x +'</b><br/>'+
      					 this.series.name +': '+ this.y +'<br/>'+
      					 'Total: '+ this.point.stackTotal;
      			}
      		},
      		plotOptions: {
      			column: {
      				stacking: 'normal',
      				dataLabels: {
      					enabled: true,
      					color: (Highcharts.theme && Highcharts.theme.dataLabelsColor) || 'white'
      				}
      			}
      		},		
          series: [{
            name: 'Specs',
      			data: specs			
      		}, {			
      		  name: 'Sources',
      			data: sources
      		}]
      	});
      
      };
    </script>
  </head>
  <body>
    <h1>Projects Statistics</h1>
    <div class="plot" id="plot"><div class="highcharts-container" id="highcharts-0" style="position: relative; overflow-x: hidden; overflow-y: hidden; width: 800px; height: 600px; text-align: left; font-family: &#39;Lucida Grande&#39;, &#39;Lucida Sans Unicode&#39;, Verdana, Arial, Helvetica, sans-serif; font-size: 12px; "><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="800" height="600"><defs><clippath id="highcharts-1"><rect rx="0" ry="0" fill="none" x="0" y="0" width="712" height="511" stroke-width="0.000001"></rect></clippath></defs><rect rx="5" ry="5" fill="#FFFFFF" x="0" y="0" width="800" height="600" stroke-width="0.000001" stroke="#4572A7"></rect><g class="highcharts-grid" zIndex="1"></g><g class="highcharts-grid" zIndex="1"><path d="M 78 521.5 L 790 521.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 464.5 L 790 464.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 407.5 L 790 407.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 350.5 L 790 350.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 294.5 L 790 294.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 237.5 L 790 237.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 180.5 L 790 180.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 123.5 L 790 123.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 66.5 L 790 66.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path><path d="M 78 10.5 L 790 10.5" fill="none" stroke="#C0C0C0" stroke-width="1"></path></g><g class="highcharts-series-group" zIndex="3"><g class="highcharts-series" clip-path="url(file://localhost/Users/alex/other_projects/code_stats/projects_statistics.html#highcharts-1)" visibility="visible" transform="translate(78,10)"><rect rx="0" ry="0" fill="none" x="23.5" y="46.5" width="40" height="301" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="23.5" y="46.5" width="40" height="301" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="23.5" y="46.5" width="40" height="301" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="23.5" y="46.5" width="40" height="301" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="112.5" y="125.5" width="40" height="248" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="112.5" y="125.5" width="40" height="248" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="112.5" y="125.5" width="40" height="248" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="112.5" y="125.5" width="40" height="248" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="201.5" y="334.5" width="40" height="97" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="201.5" y="334.5" width="40" height="97" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="201.5" y="334.5" width="40" height="97" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="201.5" y="334.5" width="40" height="97" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="290.5" y="423.5" width="40" height="48" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="290.5" y="423.5" width="40" height="48" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="290.5" y="423.5" width="40" height="48" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="290.5" y="423.5" width="40" height="48" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="379.5" y="457.5" width="40" height="28" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="379.5" y="457.5" width="40" height="28" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="379.5" y="457.5" width="40" height="28" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="379.5" y="457.5" width="40" height="28" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="468.5" y="467.5" width="40" height="20" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="468.5" y="467.5" width="40" height="20" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="468.5" y="467.5" width="40" height="20" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="468.5" y="467.5" width="40" height="20" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="557.5" y="473.5" width="40" height="22" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="557.5" y="473.5" width="40" height="22" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="557.5" y="473.5" width="40" height="22" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="557.5" y="473.5" width="40" height="22" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="646.5" y="494.5" width="40" height="9" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="646.5" y="494.5" width="40" height="9" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="646.5" y="494.5" width="40" height="9" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#4572A7" x="646.5" y="494.5" width="40" height="9" stroke-width="1" stroke="#FFFFFF" r="0"></rect></g><g class="highcharts-series" clip-path="url(file://localhost/Users/alex/other_projects/code_stats/projects_statistics.html#highcharts-1)" visibility="visible" transform="translate(78,10)"><rect rx="0" ry="0" fill="none" x="23.5" y="347.5" width="40" height="163" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="23.5" y="347.5" width="40" height="163" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="23.5" y="347.5" width="40" height="163" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="23.5" y="347.5" width="40" height="163" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="112.5" y="373.5" width="40" height="137" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="112.5" y="373.5" width="40" height="137" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="112.5" y="373.5" width="40" height="137" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="112.5" y="373.5" width="40" height="137" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="201.5" y="431.5" width="40" height="79" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="201.5" y="431.5" width="40" height="79" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="201.5" y="431.5" width="40" height="79" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="201.5" y="431.5" width="40" height="79" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="290.5" y="471.5" width="40" height="39" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="290.5" y="471.5" width="40" height="39" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="290.5" y="471.5" width="40" height="39" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="290.5" y="471.5" width="40" height="39" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="379.5" y="485.5" width="40" height="25" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="379.5" y="485.5" width="40" height="25" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="379.5" y="485.5" width="40" height="25" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="379.5" y="485.5" width="40" height="25" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="468.5" y="487.5" width="40" height="23" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="468.5" y="487.5" width="40" height="23" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="468.5" y="487.5" width="40" height="23" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="468.5" y="487.5" width="40" height="23" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="557.5" y="495.5" width="40" height="15" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="557.5" y="495.5" width="40" height="15" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="557.5" y="495.5" width="40" height="15" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="557.5" y="495.5" width="40" height="15" stroke-width="1" stroke="#FFFFFF" r="0"></rect><rect rx="0" ry="0" fill="none" x="646.5" y="503.5" width="40" height="7" stroke-width="5" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="646.5" y="503.5" width="40" height="7" stroke-width="3" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="none" x="646.5" y="503.5" width="40" height="7" stroke-width="1" stroke="rgb(0, 0, 0)" r="0" isShadow="true" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="0" ry="0" fill="#AA4643" x="646.5" y="503.5" width="40" height="7" stroke-width="1" stroke="#FFFFFF" r="0"></rect></g></g><g class="highcharts-stack-labels" visibility="visible" zIndex="6" transform="translate(78,10)"><text x="45" y="40" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="45">2045936</tspan></text><text x="134" y="120" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="134">1697182</tspan></text><text x="223" y="328" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="223">778977</tspan></text><text x="312" y="417" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="312">386346</tspan></text><text x="401" y="452" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="401">233976</tspan></text><text x="490" y="462" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="490">191332</tspan></text><text x="579" y="467" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="579">167006</tspan></text><text x="668" y="488" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:gray;line-height:14px;font-weight:bold;fill:gray;" text-anchor="middle" visibility="visible"><tspan x="668">73567</tspan></text></g><g class="highcharts-data-labels" visibility="visible" zIndex="6" transform="translate(78,10)"><text x="45" y="202" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="45">1327936</tspan></text><text x="134" y="254" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="134">1092213</tspan></text><text x="223" y="388" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="223">430746</tspan></text><text x="312" y="452" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="312">213649</tspan></text><text x="401" y="476" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="401">123890</tspan></text><text x="490" y="482" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="490">88241</tspan></text><text x="579" y="489" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="579">97365</tspan></text><text x="668" y="504" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="668">39927</tspan></text></g><g class="highcharts-data-labels" visibility="visible" zIndex="6" transform="translate(78,10)"><text x="45" y="434" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="45">718000</tspan></text><text x="134" y="447" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="134">604969</tspan></text><text x="223" y="476" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="223">348231</tspan></text><text x="312" y="496" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="312">172697</tspan></text><text x="401" y="503" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="401">110086</tspan></text><text x="490" y="504" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="490">103091</tspan></text><text x="579" y="508" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="579">69641</tspan></text><text x="668" y="512" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:white;line-height:14px;fill:white;" text-anchor="middle" zIndex="1"><tspan x="668">33640</tspan></text></g><g class="highcharts-legend" zIndex="7" transform="translate(519,30)"><rect rx="5" ry="5" fill="white" x="0.5" y="0.5" width="170" height="24" stroke-width="1" stroke="#CCC" visibility="visible"></rect><text x="30" y="18" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:12px;cursor:pointer;color:#3E576F;fill:#3E576F;" zIndex="2"><tspan x="30">Specs</tspan></text><text x="104" y="18" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:12px;cursor:pointer;color:#3E576F;fill:#3E576F;" zIndex="2"><tspan x="104">Sources</tspan></text><rect rx="2" ry="2" fill="#4572A7" x="9.5" y="7.5" width="16" height="12" stroke-width="1" zIndex="3" stroke="#FFFFFF" r="0"></rect><rect rx="2" ry="2" fill="#AA4643" x="83.5" y="7.5" width="16" height="12" stroke-width="1" zIndex="3" stroke="#FFFFFF" r="0"></rect></g><g class="highcharts-axis" zIndex="7"><text x="122.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 122.5 534)"><tspan x="122.5">actionpack</tspan></text><text x="211.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 211.5 534)"><tspan x="211.5">activerecord</tspan></text><text x="300.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 300.5 534)"><tspan x="300.5">activesupport</tspan></text><text x="389.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 389.5 534)"><tspan x="389.5">railties</tspan></text><text x="478.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 478.5 534)"><tspan x="478.5">activemodel</tspan></text><text x="567.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 567.5 534)"><tspan x="567.5">core</tspan></text><text x="656.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 656.5 534)"><tspan x="656.5">activeresource</tspan></text><text x="745.5" y="534.6532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;color:#666;line-height:14px;fill:#666;" text-anchor="end" transform="rotate(-45 745.5 534)"><tspan x="745.5">actionmailer</tspan></text><path d="M 167.5 520.6532829120242 L 167.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 256.5 520.6532829120242 L 256.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 345.5 520.6532829120242 L 345.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 434.5 520.6532829120242 L 434.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 523.5 520.6532829120242 L 523.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 612.5 520.6532829120242 L 612.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 701.5 520.6532829120242 L 701.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path><path d="M 790.5 520.6532829120242 L 790.5 525.6532829120242" fill="none" stroke="#C0D0E0" stroke-width="1"></path></g><g class="highcharts-axis" zIndex="7"><text x="70" y="526.2532829120242" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">0k</tspan></text><text x="70" y="469.47550513424636" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">250k</tspan></text><text x="70" y="412.69772735646865" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">500k</tspan></text><text x="70" y="355.9199495786908" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">750k</tspan></text><text x="70" y="299.1421718009131" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">1000k</tspan></text><text x="70" y="242.36439402313525" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">1250k</tspan></text><text x="70" y="185.58661624535748" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">1500k</tspan></text><text x="70" y="128.80883846757973" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">1750k</tspan></text><text x="70" y="72.03106068980195" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">2000k</tspan></text><text x="70" y="15.253282912024181" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:11px;width:336px;color:#666;line-height:14px;fill:#666;" text-anchor="end"><tspan x="70">2250k</tspan></text></g><text x="25" y="265.5" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:12px;color:#6D869F;font-weight:bold;fill:#6D869F;" zIndex="7" transform="rotate(270 25 265)" text-anchor="middle"><tspan x="25">Characters Count</tspan></text><path d="M 78 521.5 L 790 521.5" fill="none" stroke="#C0D0E0" stroke-width="1" zIndex="7"></path><g class="highcharts-tooltip" zIndex="8" visibility="hidden"><rect rx="5" ry="5" fill="none" x="7" y="7" width="0" height="0" stroke-width="5" fill-opacity="0.85" isShadow="true" stroke="rgb(0, 0, 0)" stroke-opacity="0.05" transform="translate(1,1)"></rect><rect rx="5" ry="5" fill="none" x="7" y="7" width="0" height="0" stroke-width="3" fill-opacity="0.85" isShadow="true" stroke="rgb(0, 0, 0)" stroke-opacity="0.1" transform="translate(1,1)"></rect><rect rx="5" ry="5" fill="none" x="7" y="7" width="0" height="0" stroke-width="1" fill-opacity="0.85" isShadow="true" stroke="rgb(0, 0, 0)" stroke-opacity="0.15000000000000002" transform="translate(1,1)"></rect><rect rx="5" ry="5" fill="rgb(255,255,255)" x="7" y="7" width="0" height="0" stroke-width="2" fill-opacity="0.85"></rect><text x="12" y="24" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:12px;color:#333333;padding:0;white-space:nowrap;fill:#333333;" zIndex="1"><tspan x="12"> </tspan></text></g><text x="790" y="595" style="font-family:&quot;Lucida Grande&quot;, &quot;Lucida Sans Unicode&quot;, Verdana, Arial, Helvetica, sans-serif;font-size:10px;cursor:pointer;color:#909090;fill:#909090;" text-anchor="end" zIndex="8"><tspan x="790">Highcharts.com</tspan></text><g class="highcharts-tracker" zIndex="9" transform="translate(78,10)"><rect rx="0" ry="0" fill="rgb(192,192,192)" x="23" y="46" width="41" height="301" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="112" y="125" width="41" height="248" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="201" y="334" width="41" height="97" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="290" y="423" width="41" height="48" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="379" y="457" width="41" height="28" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="468" y="467" width="41" height="20" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="557" y="473" width="41" height="22" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="646" y="494" width="41" height="9" stroke-width="0.000001" isTracker="1312442942368" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="23" y="347" width="41" height="163" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="112" y="373" width="41" height="137" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="201" y="431" width="41" height="79" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="290" y="471" width="41" height="39" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="379" y="485" width="41" height="25" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="468" y="487" width="41" height="23" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="557" y="495" width="41" height="15" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect><rect rx="0" ry="0" fill="rgb(192,192,192)" x="646" y="503" width="41" height="7" stroke-width="0.000001" isTracker="1312442942374" fill-opacity="0.000001" visibility="visible" zIndex="1" style=""></rect></g></svg></div></div>
    <h1>Details</h1>
    <script type="text/javascript">
      Report.plot('#chart', [
      ['actionpack', 718000, 1327936],
      ['activerecord', 604969, 1092213],
      ['activesupport', 348231, 430746],
      ['railties', 172697, 213649],
      ['activemodel', 110086, 123890],
      ['core', 103091, 88241],
      ['activeresource', 69641, 97365],
      ['actionmailer', 33640, 39927]
      ]);
    </script>
    <table class="report">
      <thead>
        <tr>
          <th>Name</th>
          <th>Chars</th>
          <th>By Lang</th>
          <th>Ignored</th>
          <th>Spec Chars</th>
          <th>Spec by Lang</th>
          <th>Spec Ignored</th>
          <th>Unknown</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>actionpack</td>
          <td class="nowrap bold">718 000</td>
          <td class="nowrap">Ruby: 711 021<br>Erb: 3 871<br>Yaml: 3 108</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">1 327 936</td>
          <td class="nowrap">Ruby: 1 320 139<br>Erb: 6 474<br>Yaml: 1 323</td>
          <td class="nowrap">JavaScript: 106</td>
          <td>builder, css, erb~, gemspec, html, javascript, jpg, mab, png, rake, rdoc, sql, styles, txt</td>
        </tr>
        <tr>
          <td>activerecord</td>
          <td class="nowrap bold">604 969</td>
          <td class="nowrap">Ruby: 604 024<br>Yaml: 945</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">1 092 213</td>
          <td class="nowrap">Ruby: 1 069 307<br>Yaml: 22 906</td>
          <td class="nowrap"></td>
          <td>csv, gemspec, jpg, log, rake, rdoc</td>
        </tr>
        <tr>
          <td>activesupport</td>
          <td class="nowrap bold">348 231</td>
          <td class="nowrap">Ruby: 347 475<br>Yaml: 756</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">430 746</td>
          <td class="nowrap">Ruby: 430 746</td>
          <td class="nowrap"></td>
          <td>dat, gemspec, rdoc</td>
        </tr>
        <tr>
          <td>railties</td>
          <td class="nowrap bold">172 697</td>
          <td class="nowrap">Ruby: 166 093<br>Yaml: 4 701<br>Erb: 1 903</td>
          <td class="nowrap">JavaScript: 0</td>
          <td class="nowrap bold">213 649</td>
          <td class="nowrap">Ruby: 213 591<br>Yaml: 58</td>
          <td class="nowrap"></td>
          <td>css, gemspec, html, ico, png, rake, rdoc, ru, tt, txt</td>
        </tr>
        <tr>
          <td>activemodel</td>
          <td class="nowrap bold">110 086</td>
          <td class="nowrap">Ruby: 109 206<br>Yaml: 880</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">123 890</td>
          <td class="nowrap">Ruby: 123 890</td>
          <td class="nowrap"></td>
          <td>gemspec, rdoc</td>
        </tr>
        <tr>
          <td>core</td>
          <td class="nowrap bold">103 091</td>
          <td class="nowrap">Ruby: 91 977<br>Yaml: 10 899<br>Erb: 215</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">88 241</td>
          <td class="nowrap">Ruby: 85 998<br>Erb: 1 963<br>Haml: 280</td>
          <td class="nowrap"></td>
          <td>md</td>
        </tr>
        <tr>
          <td>activeresource</td>
          <td class="nowrap bold">69 641</td>
          <td class="nowrap">Ruby: 69 641</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">97 365</td>
          <td class="nowrap">Ruby: 97 365</td>
          <td class="nowrap"></td>
          <td>gemspec, rdoc</td>
        </tr>
        <tr>
          <td>actionmailer</td>
          <td class="nowrap bold">33 640</td>
          <td class="nowrap">Ruby: 33 640</td>
          <td class="nowrap"></td>
          <td class="nowrap bold">39 927</td>
          <td class="nowrap">Ruby: 38 518<br>Erb: 1 335<br>Haml: 74</td>
          <td class="nowrap"></td>
          <td>bak, erb~, gemspec, jpg, rdoc, rxml</td>
        </tr>
      </tbody>
    </table>
    <p class="powered">
      Powered by <a href="https://github.com/alexeypetrushin/code_stats">code_stats</a>
    </p>
  

</body></html>